{"./LICENSE": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n    1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n    2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n    3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n    4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n    5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n    6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n    7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n    8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n    9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n    END OF TERMS AND CONDITIONS\n\n    APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n    Copyright [yyyy] [name of copyright owner]\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n----------\nThe following license is exclusively used by the template generated header files.\n\nBSD 3-Clause License\n\nCopyright (c) 2019, \"WebGPU native\" developers\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n", "./ZIG_VERSION": "0.11.0\n", "./include/tint/external_texture_options.h": "// Copyright 2023 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_TINT_EXTERNAL_TEXTURE_OPTIONS_H_\n#define INCLUDE_TINT_EXTERNAL_TEXTURE_OPTIONS_H_\n\n#include <unordered_map>\n\n#include \"tint/binding_point.h\"\n\nnamespace tint {\n\n/// Options used to specify mappings of binding points for external textures.\nstruct ExternalTextureOptions {\n    /// This struct identifies the binding groups and locations for new bindings to\n    /// use when transforming a texture_external instance.\n    struct BindingPoints {\n        /// The desired binding location of the texture_2d representing plane #1 when\n        /// a texture_external binding is expanded.\n        BindingPoint plane_1;\n        /// The desired binding location of the ExternalTextureParams uniform when a\n        /// texture_external binding is expanded.\n        BindingPoint params;\n\n        /// Reflect the fields of this class so that it can be used by tint::ForeachField()\n        TINT_REFLECT(plane_1, params);\n    };\n\n    /// BindingsMap is a map where the key is the binding location of a\n    /// texture_external and the value is a struct containing the desired\n    /// locations for new bindings expanded from the texture_external instance.\n    using BindingsMap = std::unordered_map<BindingPoint, BindingPoints>;\n\n    /// A map of new binding points to use.\n    BindingsMap bindings_map;\n\n    /// Reflect the fields of this class so that it can be used by tint::ForeachField()\n    TINT_REFLECT(bindings_map);\n};\n\n}  // namespace tint\n\n#endif  // INCLUDE_TINT_EXTERNAL_TEXTURE_OPTIONS_H_\n", "./include/tint/binding_remapper_options.h": "// Copyright 2023 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_TINT_BINDING_REMAPPER_OPTIONS_H_\n#define INCLUDE_TINT_BINDING_REMAPPER_OPTIONS_H_\n\n#include <unordered_map>\n\n#include \"src/tint/lang/core/access.h\"\n#include \"tint/binding_point.h\"\n\nnamespace tint {\n\n/// Options used to specify mappings of binding points.\nstruct BindingRemapperOptions {\n    /// BindingPoints is a map of old binding point to new binding point\n    using BindingPoints = std::unordered_map<BindingPoint, BindingPoint>;\n\n    /// AccessControls is a map of old binding point to new access control\n    using AccessControls = std::unordered_map<BindingPoint, core::Access>;\n\n    /// A map of old binding point to new binding point\n    BindingPoints binding_points;\n\n    /// A map of old binding point to new access controls\n    AccessControls access_controls;\n\n    /// If true, then validation will be disabled for binding point collisions\n    /// generated by this transform\n    bool allow_collisions = false;\n\n    /// Reflect the fields of this class so that it can be used by tint::ForeachField()\n    TINT_REFLECT(binding_points, access_controls, allow_collisions);\n};\n\n}  // namespace tint\n\n#endif  // INCLUDE_TINT_BINDING_REMAPPER_OPTIONS_H_\n", "./include/tint/tint.h": "// Copyright 2020 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_TINT_TINT_H_\n#define INCLUDE_TINT_TINT_H_\n\n// Guard for accidental includes to private headers\n#define CURRENTLY_IN_TINT_PUBLIC_HEADER\n\n// TODO(tint:88): When implementing support for an install target, all of these\n//                headers will need to be moved to include/tint/.\n\n#include \"src/tint/lang/core/type/manager.h\"\n#include \"src/tint/lang/wgsl/ast/transform/first_index_offset.h\"\n#include \"src/tint/lang/wgsl/ast/transform/manager.h\"\n#include \"src/tint/lang/wgsl/ast/transform/renamer.h\"\n#include \"src/tint/lang/wgsl/ast/transform/single_entry_point.h\"\n#include \"src/tint/lang/wgsl/ast/transform/substitute_override.h\"\n#include \"src/tint/lang/wgsl/ast/transform/vertex_pulling.h\"\n#include \"src/tint/lang/wgsl/helpers/flatten_bindings.h\"\n#include \"src/tint/lang/wgsl/inspector/inspector.h\"\n#include \"src/tint/utils/diagnostic/formatter.h\"\n#include \"src/tint/utils/diagnostic/printer.h\"\n#include \"tint/array_length_from_uniform_options.h\"\n#include \"tint/binding_point.h\"\n#include \"tint/binding_remapper_options.h\"\n#include \"tint/external_texture_options.h\"\n\n#if TINT_BUILD_SPV_READER\n#include \"src/tint/lang/spirv/reader/reader.h\"\n#endif  // TINT_BUILD_SPV_READER\n\n#if TINT_BUILD_WGSL_READER\n#include \"src/tint/lang/wgsl/reader/reader.h\"\n#endif  // TINT_BUILD_WGSL_READER\n\n#if TINT_BUILD_SPV_WRITER\n#include \"src/tint/lang/spirv/writer/writer.h\"\n#endif  // TINT_BUILD_SPV_WRITER\n\n#if TINT_BUILD_WGSL_WRITER\n#include \"src/tint/lang/wgsl/writer/writer.h\"\n#endif  // TINT_BUILD_WGSL_WRITER\n\n#if TINT_BUILD_MSL_WRITER\n#include \"src/tint/lang/msl/writer/writer.h\"\n#endif  // TINT_BUILD_MSL_WRITER\n\n#if TINT_BUILD_HLSL_WRITER\n#include \"src/tint/lang/hlsl/writer/writer.h\"\n#endif  // TINT_BUILD_HLSL_WRITER\n\n#if TINT_BUILD_GLSL_WRITER\n#include \"src/tint/lang/glsl/writer/writer.h\"\n#endif  // TINT_BUILD_GLSL_WRITER\n\nnamespace tint {\n\n/// Initialize initializes the Tint library. Call before using the Tint API.\nvoid Initialize();\n\n/// Shutdown uninitializes the Tint library. Call after using the Tint API.\nvoid Shutdown();\n\n}  // namespace tint\n\n#undef CURRENTLY_IN_TINT_PUBLIC_HEADER\n\n#endif  // INCLUDE_TINT_TINT_H_\n", "./include/tint/binding_point.h": "// Copyright 2021 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_TINT_BINDING_POINT_H_\n#define INCLUDE_TINT_BINDING_POINT_H_\n\n#include <stdint.h>\n\n#include <functional>\n\n#include \"src/tint/utils/math/hash.h\"\n#include \"src/tint/utils/reflection/reflection.h\"\n#include \"src/tint/utils/text/string_stream.h\"\n#include \"src/tint/utils/traits/traits.h\"\n\nnamespace tint {\n\n/// BindingPoint holds a group and binding index.\nstruct BindingPoint {\n    /// The `@group` part of the binding point\n    uint32_t group = 0;\n    /// The `@binding` part of the binding point\n    uint32_t binding = 0;\n\n    /// Reflect the fields of this class so that it can be used by tint::ForeachField()\n    TINT_REFLECT(group, binding);\n\n    /// Equality operator\n    /// @param rhs the BindingPoint to compare against\n    /// @returns true if this BindingPoint is equal to `rhs`\n    inline bool operator==(const BindingPoint& rhs) const {\n        return group == rhs.group && binding == rhs.binding;\n    }\n\n    /// Inequality operator\n    /// @param rhs the BindingPoint to compare against\n    /// @returns true if this BindingPoint is not equal to `rhs`\n    inline bool operator!=(const BindingPoint& rhs) const { return !(*this == rhs); }\n\n    /// Less-than operator\n    /// @param rhs the BindingPoint to compare against\n    /// @returns true if this BindingPoint comes before @p rhs\n    inline bool operator<(const BindingPoint& rhs) const {\n        if (group < rhs.group) {\n            return true;\n        }\n        if (group > rhs.group) {\n            return false;\n        }\n        return binding < rhs.binding;\n    }\n};\n\n/// Prints the BindingPoint @p bp to @p o\n/// @param o the stream to write to\n/// @param bp the BindingPoint\n/// @return the stream so calls can be chained\ntemplate <typename STREAM, typename = traits::EnableIfIsOStream<STREAM>>\nauto& operator<<(STREAM& o, const BindingPoint& bp) {\n    return o << \"[group: \" << bp.group << \", binding: \" << bp.binding << \"]\";\n}\n\n}  // namespace tint\n\nnamespace std {\n\n/// Custom std::hash specialization for tint::BindingPoint so BindingPoints can be used as keys for\n/// std::unordered_map and std::unordered_set.\ntemplate <>\nclass hash<tint::BindingPoint> {\n  public:\n    /// @param binding_point the binding point to create a hash for\n    /// @return the hash value\n    inline std::size_t operator()(const tint::BindingPoint& binding_point) const {\n        return tint::Hash(binding_point.group, binding_point.binding);\n    }\n};\n\n}  // namespace std\n\n#endif  // INCLUDE_TINT_BINDING_POINT_H_\n", "./include/tint/array_length_from_uniform_options.h": "// Copyright 2021 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_TINT_ARRAY_LENGTH_FROM_UNIFORM_OPTIONS_H_\n#define INCLUDE_TINT_ARRAY_LENGTH_FROM_UNIFORM_OPTIONS_H_\n\n#include <unordered_map>\n\n#include \"tint/binding_point.h\"\n\nnamespace tint {\n\n/// Options used to specify a mapping of binding points to indices into a UBO\n/// from which to load buffer sizes.\nstruct ArrayLengthFromUniformOptions {\n    /// The binding point to use to generate a uniform buffer from which to read\n    /// buffer sizes.\n    BindingPoint ubo_binding;\n    /// The mapping from storage buffer binding points to the index into the\n    /// uniform buffer where the length of the buffer is stored.\n    std::unordered_map<BindingPoint, uint32_t> bindpoint_to_size_index;\n\n    /// Reflect the fields of this class so that it can be used by tint::ForeachField()\n    TINT_REFLECT(ubo_binding, bindpoint_to_size_index);\n};\n\n}  // namespace tint\n\n#endif  // INCLUDE_TINT_ARRAY_LENGTH_FROM_UNIFORM_OPTIONS_H_\n", "./include/tint/override_id.h": "// Copyright 2022 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef SRC_TINT_OVERRIDE_ID_H_\n#define SRC_TINT_OVERRIDE_ID_H_\n\n#include <stdint.h>\n#include <functional>\n\n#include \"src/tint/utils/reflection/reflection.h\"\n\nnamespace tint {\n\n/// OverrideId is a numerical identifier for an override variable, unique per program.\nstruct OverrideId {\n    uint16_t value = 0;\n\n    /// Reflect the fields of this struct so that it can be used by tint::ForeachField()\n    TINT_REFLECT(value);\n};\n\n/// Equality operator for OverrideId\n/// @param lhs the OverrideId on the left of the '=' operator\n/// @param rhs the OverrideId on the right of the '=' operator\n/// @returns true if `lhs` is equal to `rhs`\ninline bool operator==(OverrideId lhs, OverrideId rhs) {\n    return lhs.value == rhs.value;\n}\n\n/// Less-than operator for OverrideId\n/// @param lhs the OverrideId on the left of the '<' operator\n/// @param rhs the OverrideId on the right of the '<' operator\n/// @returns true if `lhs` comes before `rhs`\ninline bool operator<(OverrideId lhs, OverrideId rhs) {\n    return lhs.value < rhs.value;\n}\n\n}  // namespace tint\n\nnamespace std {\n\n/// Custom std::hash specialization for tint::OverrideId.\ntemplate <>\nclass hash<tint::OverrideId> {\n  public:\n    /// @param id the override identifier\n    /// @return the hash of the override identifier\n    inline std::size_t operator()(tint::OverrideId id) const {\n        return std::hash<decltype(tint::OverrideId::value)>()(id.value);\n    }\n};\n\n}  // namespace std\n\n#endif  // SRC_TINT_OVERRIDE_ID_H_\n", "./include/webgpu/webgpu_cpp.h": "// Copyright 2022 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_WEBGPU_WEBGPU_CPP_H_\n#define INCLUDE_WEBGPU_WEBGPU_CPP_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#endif  // INCLUDE_WEBGPU_WEBGPU_CPP_H_\n", "./include/webgpu/webgpu_glfw.h": "// Copyright 2022 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_WEBGPU_WEBGPU_GLFW_H_\n#define INCLUDE_WEBGPU_WEBGPU_GLFW_H_\n\n#include <memory>\n\n#include \"webgpu/webgpu_cpp.h\"\n\n#if defined(WGPU_GLFW_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(WGPU_GLFW_IMPLEMENTATION)\n#define WGPU_GLFW_EXPORT __declspec(dllexport)\n#else\n#define WGPU_GLFW_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(WGPU_GLFW_IMPLEMENTATION)\n#define WGPU_GLFW_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define WGPU_GLFW_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(WGPU_GLFW_SHARED_LIBRARY)\n#define WGPU_GLFW_EXPORT\n#endif  // defined(WGPU_GLFW_SHARED_LIBRARY)\n\nstruct GLFWwindow;\n\nnamespace wgpu::glfw {\n\n// Does the necessary setup on the GLFWwindow to allow creating a wgpu::Surface with it and\n// calls `instance.CreateSurface` with the correct descriptor for this window.\n// Returns a null wgpu::Surface on failure.\nWGPU_GLFW_EXPORT wgpu::Surface CreateSurfaceForWindow(const wgpu::Instance& instance,\n                                                      GLFWwindow* window);\n\n// Use for testing only. Does everything that CreateSurfaceForWindow does except the call to\n// CreateSurface. Useful to be able to modify the descriptor for testing, or when trying to\n// avoid using the global proc table.\nWGPU_GLFW_EXPORT std::unique_ptr<wgpu::ChainedStruct> SetupWindowAndGetSurfaceDescriptor(\n    GLFWwindow* window);\n\n}  // namespace wgpu::glfw\n\n#endif  // INCLUDE_WEBGPU_WEBGPU_GLFW_H_\n", "./include/webgpu/webgpu.h": "// Copyright 2022 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_WEBGPU_WEBGPU_H_\n#define INCLUDE_WEBGPU_WEBGPU_H_\n\n#include \"dawn/webgpu.h\"\n\n#endif  // INCLUDE_WEBGPU_WEBGPU_H_\n", "./include/dawn/BUILD.gn": "# Copyright 2019 The Dawn Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport(\"../../scripts/dawn_overrides_with_defaults.gni\")\n\nimport(\"${dawn_root}/generator/dawn_generator.gni\")\nimport(\"${dawn_root}/scripts/dawn_component.gni\")\n\n###############################################################################\n# Dawn headers\n###############################################################################\n\ndawn_json_generator(\"headers_gen\") {\n  target = \"headers\"\n  outputs = [\n    \"include/dawn/dawn_proc_table.h\",\n    \"include/dawn/webgpu.h\",\n  ]\n}\n\nsource_set(\"headers\") {\n  all_dependent_configs = [ \":public\" ]\n  public_deps = [ \":headers_gen\" ]\n\n  sources = get_target_outputs(\":headers_gen\")\n}\n\n###############################################################################\n# Dawn C++ headers\n###############################################################################\n\ndawn_json_generator(\"cpp_headers_gen\") {\n  target = \"cpp_headers\"\n  outputs = [\n    \"include/dawn/webgpu_cpp.h\",\n    \"include/dawn/webgpu_cpp_chained_struct.h\",\n    \"include/dawn/webgpu_cpp_print.h\",\n  ]\n}\n\nsource_set(\"cpp_headers\") {\n  public_deps = [\n    \":cpp_headers_gen\",\n    \":headers\",\n  ]\n\n  sources = get_target_outputs(\":cpp_headers_gen\")\n  sources += [ \"${dawn_root}/include/dawn/EnumClassBitmasks.h\" ]\n}\n\n###############################################################################\n# Dawn public include directories\n###############################################################################\n\nconfig(\"public\") {\n  include_dirs = [\n    \"${target_gen_dir}/../../include\",\n    \"${dawn_root}/include\",\n  ]\n}\n", "./include/dawn/webgpu_cpp.h": "#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n#ifndef WEBGPU_CPP_H_\n#define WEBGPU_CPP_H_\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/webgpu_cpp_chained_struct.h\"\n#include \"dawn/EnumClassBitmasks.h\"\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n\nnamespace wgpu {\n\n    static constexpr uint32_t kArrayLayerCountUndefined = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n    static constexpr uint32_t kCopyStrideUndefined = WGPU_COPY_STRIDE_UNDEFINED;\n    static constexpr uint32_t kLimitU32Undefined = WGPU_LIMIT_U32_UNDEFINED;\n    static constexpr uint64_t kLimitU64Undefined = WGPU_LIMIT_U64_UNDEFINED;\n    static constexpr uint32_t kMipLevelCountUndefined = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n    static constexpr size_t kWholeMapSize = WGPU_WHOLE_MAP_SIZE;\n    static constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\n\n    enum class AdapterType : uint32_t {\n        DiscreteGPU = 0x00000000,\n        IntegratedGPU = 0x00000001,\n        CPU = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class AddressMode : uint32_t {\n        Repeat = 0x00000000,\n        MirrorRepeat = 0x00000001,\n        ClampToEdge = 0x00000002,\n    };\n\n    enum class AlphaMode : uint32_t {\n        Premultiplied = 0x00000000,\n        Unpremultiplied = 0x00000001,\n        Opaque = 0x00000002,\n    };\n\n    enum class BackendType : uint32_t {\n        Undefined = 0x00000000,\n        Null = 0x00000001,\n        WebGPU = 0x00000002,\n        D3D11 = 0x00000003,\n        D3D12 = 0x00000004,\n        Metal = 0x00000005,\n        Vulkan = 0x00000006,\n        OpenGL = 0x00000007,\n        OpenGLES = 0x00000008,\n    };\n\n    enum class BlendFactor : uint32_t {\n        Zero = 0x00000000,\n        One = 0x00000001,\n        Src = 0x00000002,\n        OneMinusSrc = 0x00000003,\n        SrcAlpha = 0x00000004,\n        OneMinusSrcAlpha = 0x00000005,\n        Dst = 0x00000006,\n        OneMinusDst = 0x00000007,\n        DstAlpha = 0x00000008,\n        OneMinusDstAlpha = 0x00000009,\n        SrcAlphaSaturated = 0x0000000A,\n        Constant = 0x0000000B,\n        OneMinusConstant = 0x0000000C,\n        Src1 = 0x0000000D,\n        OneMinusSrc1 = 0x0000000E,\n        Src1Alpha = 0x0000000F,\n        OneMinusSrc1Alpha = 0x00000010,\n    };\n\n    enum class BlendOperation : uint32_t {\n        Add = 0x00000000,\n        Subtract = 0x00000001,\n        ReverseSubtract = 0x00000002,\n        Min = 0x00000003,\n        Max = 0x00000004,\n    };\n\n    enum class BufferBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Uniform = 0x00000001,\n        Storage = 0x00000002,\n        ReadOnlyStorage = 0x00000003,\n    };\n\n    enum class BufferMapAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        ValidationError = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n        DestroyedBeforeCallback = 0x00000004,\n        UnmappedBeforeCallback = 0x00000005,\n        MappingAlreadyPending = 0x00000006,\n        OffsetOutOfRange = 0x00000007,\n        SizeOutOfRange = 0x00000008,\n    };\n\n    enum class BufferMapState : uint32_t {\n        Unmapped = 0x00000000,\n        Pending = 0x00000001,\n        Mapped = 0x00000002,\n    };\n\n    enum class CompareFunction : uint32_t {\n        Undefined = 0x00000000,\n        Never = 0x00000001,\n        Less = 0x00000002,\n        LessEqual = 0x00000003,\n        Greater = 0x00000004,\n        GreaterEqual = 0x00000005,\n        Equal = 0x00000006,\n        NotEqual = 0x00000007,\n        Always = 0x00000008,\n    };\n\n    enum class CompilationInfoRequestStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        DeviceLost = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class CompilationMessageType : uint32_t {\n        Error = 0x00000000,\n        Warning = 0x00000001,\n        Info = 0x00000002,\n    };\n\n    enum class ComputePassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class CreatePipelineAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        ValidationError = 0x00000001,\n        InternalError = 0x00000002,\n        DeviceLost = 0x00000003,\n        DeviceDestroyed = 0x00000004,\n        Unknown = 0x00000005,\n    };\n\n    enum class CullMode : uint32_t {\n        None = 0x00000000,\n        Front = 0x00000001,\n        Back = 0x00000002,\n    };\n\n    enum class DeviceLostReason : uint32_t {\n        Undefined = 0x00000000,\n        Destroyed = 0x00000001,\n    };\n\n    enum class ErrorFilter : uint32_t {\n        Validation = 0x00000000,\n        OutOfMemory = 0x00000001,\n        Internal = 0x00000002,\n    };\n\n    enum class ErrorType : uint32_t {\n        NoError = 0x00000000,\n        Validation = 0x00000001,\n        OutOfMemory = 0x00000002,\n        Internal = 0x00000003,\n        Unknown = 0x00000004,\n        DeviceLost = 0x00000005,\n    };\n\n    enum class ExternalTextureRotation : uint32_t {\n        Rotate0Degrees = 0x00000000,\n        Rotate90Degrees = 0x00000001,\n        Rotate180Degrees = 0x00000002,\n        Rotate270Degrees = 0x00000003,\n    };\n\n    enum class FeatureName : uint32_t {\n        Undefined = 0x00000000,\n        DepthClipControl = 0x00000001,\n        Depth32FloatStencil8 = 0x00000002,\n        TimestampQuery = 0x00000003,\n        PipelineStatisticsQuery = 0x00000004,\n        TextureCompressionBC = 0x00000005,\n        TextureCompressionETC2 = 0x00000006,\n        TextureCompressionASTC = 0x00000007,\n        IndirectFirstInstance = 0x00000008,\n        ShaderF16 = 0x00000009,\n        RG11B10UfloatRenderable = 0x0000000A,\n        BGRA8UnormStorage = 0x0000000B,\n        Float32Filterable = 0x0000000C,\n        DawnInternalUsages = 0x000003EA,\n        DawnMultiPlanarFormats = 0x000003EB,\n        DawnNative = 0x000003EC,\n        ChromiumExperimentalDp4a = 0x000003ED,\n        TimestampQueryInsidePasses = 0x000003EE,\n        ImplicitDeviceSynchronization = 0x000003EF,\n        SurfaceCapabilities = 0x000003F0,\n        TransientAttachments = 0x000003F1,\n        MSAARenderToSingleSampled = 0x000003F2,\n        DualSourceBlending = 0x000003F3,\n        D3D11MultithreadProtected = 0x000003F4,\n        ANGLETextureSharing = 0x000003F5,\n        SharedTextureMemoryVkDedicatedAllocation = 0x0000044C,\n        SharedTextureMemoryAHardwareBuffer = 0x0000044D,\n        SharedTextureMemoryDmaBuf = 0x0000044E,\n        SharedTextureMemoryOpaqueFD = 0x0000044F,\n        SharedTextureMemoryZirconHandle = 0x00000450,\n        SharedTextureMemoryDXGISharedHandle = 0x00000451,\n        SharedTextureMemoryD3D11Texture2D = 0x00000452,\n        SharedTextureMemoryIOSurface = 0x00000453,\n        SharedTextureMemoryEGLImage = 0x00000454,\n        SharedFenceVkSemaphoreOpaqueFD = 0x000004B0,\n        SharedFenceVkSemaphoreSyncFD = 0x000004B1,\n        SharedFenceVkSemaphoreZirconHandle = 0x000004B2,\n        SharedFenceDXGISharedHandle = 0x000004B3,\n        SharedFenceMTLSharedEvent = 0x000004B4,\n    };\n\n    enum class FilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class FrontFace : uint32_t {\n        CCW = 0x00000000,\n        CW = 0x00000001,\n    };\n\n    enum class IndexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint16 = 0x00000001,\n        Uint32 = 0x00000002,\n    };\n\n    enum class LoadOp : uint32_t {\n        Undefined = 0x00000000,\n        Clear = 0x00000001,\n        Load = 0x00000002,\n    };\n\n    enum class LoggingType : uint32_t {\n        Verbose = 0x00000000,\n        Info = 0x00000001,\n        Warning = 0x00000002,\n        Error = 0x00000003,\n    };\n\n    enum class MipmapFilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class PipelineStatisticName : uint32_t {\n        VertexShaderInvocations = 0x00000000,\n        ClipperInvocations = 0x00000001,\n        ClipperPrimitivesOut = 0x00000002,\n        FragmentShaderInvocations = 0x00000003,\n        ComputeShaderInvocations = 0x00000004,\n    };\n\n    enum class PowerPreference : uint32_t {\n        Undefined = 0x00000000,\n        LowPower = 0x00000001,\n        HighPerformance = 0x00000002,\n    };\n\n    enum class PresentMode : uint32_t {\n        Immediate = 0x00000000,\n        Mailbox = 0x00000001,\n        Fifo = 0x00000002,\n    };\n\n    enum class PrimitiveTopology : uint32_t {\n        PointList = 0x00000000,\n        LineList = 0x00000001,\n        LineStrip = 0x00000002,\n        TriangleList = 0x00000003,\n        TriangleStrip = 0x00000004,\n    };\n\n    enum class QueryType : uint32_t {\n        Occlusion = 0x00000000,\n        PipelineStatistics = 0x00000001,\n        Timestamp = 0x00000002,\n    };\n\n    enum class QueueWorkDoneStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n    };\n\n    enum class RenderPassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class RequestAdapterStatus : uint32_t {\n        Success = 0x00000000,\n        Unavailable = 0x00000001,\n        Error = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class RequestDeviceStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n    };\n\n    enum class SType : uint32_t {\n        Invalid = 0x00000000,\n        SurfaceDescriptorFromMetalLayer = 0x00000001,\n        SurfaceDescriptorFromWindowsHWND = 0x00000002,\n        SurfaceDescriptorFromXlibWindow = 0x00000003,\n        SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n        ShaderModuleSPIRVDescriptor = 0x00000005,\n        ShaderModuleWGSLDescriptor = 0x00000006,\n        PrimitiveDepthClipControl = 0x00000007,\n        SurfaceDescriptorFromWaylandSurface = 0x00000008,\n        SurfaceDescriptorFromAndroidNativeWindow = 0x00000009,\n        SurfaceDescriptorFromWindowsCoreWindow = 0x0000000B,\n        ExternalTextureBindingEntry = 0x0000000C,\n        ExternalTextureBindingLayout = 0x0000000D,\n        SurfaceDescriptorFromWindowsSwapChainPanel = 0x0000000E,\n        RenderPassDescriptorMaxDrawCount = 0x0000000F,\n        DawnTextureInternalUsageDescriptor = 0x000003E8,\n        DawnEncoderInternalUsageDescriptor = 0x000003EB,\n        DawnInstanceDescriptor = 0x000003EC,\n        DawnCacheDeviceDescriptor = 0x000003ED,\n        DawnAdapterPropertiesPowerPreference = 0x000003EE,\n        DawnBufferDescriptorErrorInfoFromWireClient = 0x000003EF,\n        DawnTogglesDescriptor = 0x000003F0,\n        DawnShaderModuleSPIRVOptionsDescriptor = 0x000003F1,\n        RequestAdapterOptionsLUID = 0x000003F2,\n        RequestAdapterOptionsGetGLProc = 0x000003F3,\n        DawnMultisampleStateRenderToSingleSampled = 0x000003F4,\n        DawnRenderPassColorAttachmentRenderToSingleSampled = 0x000003F5,\n        SharedTextureMemoryVkImageDescriptor = 0x0000044C,\n        SharedTextureMemoryVkDedicatedAllocationDescriptor = 0x0000044D,\n        SharedTextureMemoryAHardwareBufferDescriptor = 0x0000044E,\n        SharedTextureMemoryDmaBufDescriptor = 0x0000044F,\n        SharedTextureMemoryOpaqueFDDescriptor = 0x00000450,\n        SharedTextureMemoryZirconHandleDescriptor = 0x00000451,\n        SharedTextureMemoryDXGISharedHandleDescriptor = 0x00000452,\n        SharedTextureMemoryD3D11Texture2DDescriptor = 0x00000453,\n        SharedTextureMemoryIOSurfaceDescriptor = 0x00000454,\n        SharedTextureMemoryEGLImageDescriptor = 0x00000455,\n        SharedTextureMemoryInitializedBeginState = 0x000004B0,\n        SharedTextureMemoryInitializedEndState = 0x000004B1,\n        SharedTextureMemoryVkImageLayoutBeginState = 0x000004B2,\n        SharedTextureMemoryVkImageLayoutEndState = 0x000004B3,\n        SharedFenceVkSemaphoreOpaqueFDDescriptor = 0x000004B4,\n        SharedFenceVkSemaphoreOpaqueFDExportInfo = 0x000004B5,\n        SharedFenceVkSemaphoreSyncFDDescriptor = 0x000004B6,\n        SharedFenceVkSemaphoreSyncFDExportInfo = 0x000004B7,\n        SharedFenceVkSemaphoreZirconHandleDescriptor = 0x000004B8,\n        SharedFenceVkSemaphoreZirconHandleExportInfo = 0x000004B9,\n        SharedFenceDXGISharedHandleDescriptor = 0x000004BA,\n        SharedFenceDXGISharedHandleExportInfo = 0x000004BB,\n        SharedFenceMTLSharedEventDescriptor = 0x000004BC,\n        SharedFenceMTLSharedEventExportInfo = 0x000004BD,\n    };\n\n    enum class SamplerBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Filtering = 0x00000001,\n        NonFiltering = 0x00000002,\n        Comparison = 0x00000003,\n    };\n\n    enum class SharedFenceType : uint32_t {\n        Undefined = 0x00000000,\n        VkSemaphoreOpaqueFD = 0x00000001,\n        VkSemaphoreSyncFD = 0x00000002,\n        VkSemaphoreZirconHandle = 0x00000003,\n        DXGISharedHandle = 0x00000004,\n        MTLSharedEvent = 0x00000005,\n    };\n\n    enum class StencilOperation : uint32_t {\n        Keep = 0x00000000,\n        Zero = 0x00000001,\n        Replace = 0x00000002,\n        Invert = 0x00000003,\n        IncrementClamp = 0x00000004,\n        DecrementClamp = 0x00000005,\n        IncrementWrap = 0x00000006,\n        DecrementWrap = 0x00000007,\n    };\n\n    enum class StorageTextureAccess : uint32_t {\n        Undefined = 0x00000000,\n        WriteOnly = 0x00000001,\n    };\n\n    enum class StoreOp : uint32_t {\n        Undefined = 0x00000000,\n        Store = 0x00000001,\n        Discard = 0x00000002,\n    };\n\n    enum class TextureAspect : uint32_t {\n        All = 0x00000000,\n        StencilOnly = 0x00000001,\n        DepthOnly = 0x00000002,\n        Plane0Only = 0x00000003,\n        Plane1Only = 0x00000004,\n    };\n\n    enum class TextureDimension : uint32_t {\n        e1D = 0x00000000,\n        e2D = 0x00000001,\n        e3D = 0x00000002,\n    };\n\n    enum class TextureFormat : uint32_t {\n        Undefined = 0x00000000,\n        R8Unorm = 0x00000001,\n        R8Snorm = 0x00000002,\n        R8Uint = 0x00000003,\n        R8Sint = 0x00000004,\n        R16Uint = 0x00000005,\n        R16Sint = 0x00000006,\n        R16Float = 0x00000007,\n        RG8Unorm = 0x00000008,\n        RG8Snorm = 0x00000009,\n        RG8Uint = 0x0000000A,\n        RG8Sint = 0x0000000B,\n        R32Float = 0x0000000C,\n        R32Uint = 0x0000000D,\n        R32Sint = 0x0000000E,\n        RG16Uint = 0x0000000F,\n        RG16Sint = 0x00000010,\n        RG16Float = 0x00000011,\n        RGBA8Unorm = 0x00000012,\n        RGBA8UnormSrgb = 0x00000013,\n        RGBA8Snorm = 0x00000014,\n        RGBA8Uint = 0x00000015,\n        RGBA8Sint = 0x00000016,\n        BGRA8Unorm = 0x00000017,\n        BGRA8UnormSrgb = 0x00000018,\n        RGB10A2Unorm = 0x00000019,\n        RG11B10Ufloat = 0x0000001A,\n        RGB9E5Ufloat = 0x0000001B,\n        RG32Float = 0x0000001C,\n        RG32Uint = 0x0000001D,\n        RG32Sint = 0x0000001E,\n        RGBA16Uint = 0x0000001F,\n        RGBA16Sint = 0x00000020,\n        RGBA16Float = 0x00000021,\n        RGBA32Float = 0x00000022,\n        RGBA32Uint = 0x00000023,\n        RGBA32Sint = 0x00000024,\n        Stencil8 = 0x00000025,\n        Depth16Unorm = 0x00000026,\n        Depth24Plus = 0x00000027,\n        Depth24PlusStencil8 = 0x00000028,\n        Depth32Float = 0x00000029,\n        Depth32FloatStencil8 = 0x0000002A,\n        BC1RGBAUnorm = 0x0000002B,\n        BC1RGBAUnormSrgb = 0x0000002C,\n        BC2RGBAUnorm = 0x0000002D,\n        BC2RGBAUnormSrgb = 0x0000002E,\n        BC3RGBAUnorm = 0x0000002F,\n        BC3RGBAUnormSrgb = 0x00000030,\n        BC4RUnorm = 0x00000031,\n        BC4RSnorm = 0x00000032,\n        BC5RGUnorm = 0x00000033,\n        BC5RGSnorm = 0x00000034,\n        BC6HRGBUfloat = 0x00000035,\n        BC6HRGBFloat = 0x00000036,\n        BC7RGBAUnorm = 0x00000037,\n        BC7RGBAUnormSrgb = 0x00000038,\n        ETC2RGB8Unorm = 0x00000039,\n        ETC2RGB8UnormSrgb = 0x0000003A,\n        ETC2RGB8A1Unorm = 0x0000003B,\n        ETC2RGB8A1UnormSrgb = 0x0000003C,\n        ETC2RGBA8Unorm = 0x0000003D,\n        ETC2RGBA8UnormSrgb = 0x0000003E,\n        EACR11Unorm = 0x0000003F,\n        EACR11Snorm = 0x00000040,\n        EACRG11Unorm = 0x00000041,\n        EACRG11Snorm = 0x00000042,\n        ASTC4x4Unorm = 0x00000043,\n        ASTC4x4UnormSrgb = 0x00000044,\n        ASTC5x4Unorm = 0x00000045,\n        ASTC5x4UnormSrgb = 0x00000046,\n        ASTC5x5Unorm = 0x00000047,\n        ASTC5x5UnormSrgb = 0x00000048,\n        ASTC6x5Unorm = 0x00000049,\n        ASTC6x5UnormSrgb = 0x0000004A,\n        ASTC6x6Unorm = 0x0000004B,\n        ASTC6x6UnormSrgb = 0x0000004C,\n        ASTC8x5Unorm = 0x0000004D,\n        ASTC8x5UnormSrgb = 0x0000004E,\n        ASTC8x6Unorm = 0x0000004F,\n        ASTC8x6UnormSrgb = 0x00000050,\n        ASTC8x8Unorm = 0x00000051,\n        ASTC8x8UnormSrgb = 0x00000052,\n        ASTC10x5Unorm = 0x00000053,\n        ASTC10x5UnormSrgb = 0x00000054,\n        ASTC10x6Unorm = 0x00000055,\n        ASTC10x6UnormSrgb = 0x00000056,\n        ASTC10x8Unorm = 0x00000057,\n        ASTC10x8UnormSrgb = 0x00000058,\n        ASTC10x10Unorm = 0x00000059,\n        ASTC10x10UnormSrgb = 0x0000005A,\n        ASTC12x10Unorm = 0x0000005B,\n        ASTC12x10UnormSrgb = 0x0000005C,\n        ASTC12x12Unorm = 0x0000005D,\n        ASTC12x12UnormSrgb = 0x0000005E,\n        R8BG8Biplanar420Unorm = 0x0000005F,\n    };\n\n    enum class TextureSampleType : uint32_t {\n        Undefined = 0x00000000,\n        Float = 0x00000001,\n        UnfilterableFloat = 0x00000002,\n        Depth = 0x00000003,\n        Sint = 0x00000004,\n        Uint = 0x00000005,\n    };\n\n    enum class TextureViewDimension : uint32_t {\n        Undefined = 0x00000000,\n        e1D = 0x00000001,\n        e2D = 0x00000002,\n        e2DArray = 0x00000003,\n        Cube = 0x00000004,\n        CubeArray = 0x00000005,\n        e3D = 0x00000006,\n    };\n\n    enum class VertexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint8x2 = 0x00000001,\n        Uint8x4 = 0x00000002,\n        Sint8x2 = 0x00000003,\n        Sint8x4 = 0x00000004,\n        Unorm8x2 = 0x00000005,\n        Unorm8x4 = 0x00000006,\n        Snorm8x2 = 0x00000007,\n        Snorm8x4 = 0x00000008,\n        Uint16x2 = 0x00000009,\n        Uint16x4 = 0x0000000A,\n        Sint16x2 = 0x0000000B,\n        Sint16x4 = 0x0000000C,\n        Unorm16x2 = 0x0000000D,\n        Unorm16x4 = 0x0000000E,\n        Snorm16x2 = 0x0000000F,\n        Snorm16x4 = 0x00000010,\n        Float16x2 = 0x00000011,\n        Float16x4 = 0x00000012,\n        Float32 = 0x00000013,\n        Float32x2 = 0x00000014,\n        Float32x3 = 0x00000015,\n        Float32x4 = 0x00000016,\n        Uint32 = 0x00000017,\n        Uint32x2 = 0x00000018,\n        Uint32x3 = 0x00000019,\n        Uint32x4 = 0x0000001A,\n        Sint32 = 0x0000001B,\n        Sint32x2 = 0x0000001C,\n        Sint32x3 = 0x0000001D,\n        Sint32x4 = 0x0000001E,\n    };\n\n    enum class VertexStepMode : uint32_t {\n        Vertex = 0x00000000,\n        Instance = 0x00000001,\n        VertexBufferNotUsed = 0x00000002,\n    };\n\n\n    enum class BufferUsage : uint32_t {\n        None = 0x00000000,\n        MapRead = 0x00000001,\n        MapWrite = 0x00000002,\n        CopySrc = 0x00000004,\n        CopyDst = 0x00000008,\n        Index = 0x00000010,\n        Vertex = 0x00000020,\n        Uniform = 0x00000040,\n        Storage = 0x00000080,\n        Indirect = 0x00000100,\n        QueryResolve = 0x00000200,\n    };\n\n    enum class ColorWriteMask : uint32_t {\n        None = 0x00000000,\n        Red = 0x00000001,\n        Green = 0x00000002,\n        Blue = 0x00000004,\n        Alpha = 0x00000008,\n        All = 0x0000000F,\n    };\n\n    enum class MapMode : uint32_t {\n        None = 0x00000000,\n        Read = 0x00000001,\n        Write = 0x00000002,\n    };\n\n    enum class ShaderStage : uint32_t {\n        None = 0x00000000,\n        Vertex = 0x00000001,\n        Fragment = 0x00000002,\n        Compute = 0x00000004,\n    };\n\n    enum class TextureUsage : uint32_t {\n        None = 0x00000000,\n        CopySrc = 0x00000001,\n        CopyDst = 0x00000002,\n        TextureBinding = 0x00000004,\n        StorageBinding = 0x00000008,\n        RenderAttachment = 0x00000010,\n        TransientAttachment = 0x00000020,\n    };\n\n\n    using BufferMapCallback = WGPUBufferMapCallback;\n    using CompilationInfoCallback = WGPUCompilationInfoCallback;\n    using CreateComputePipelineAsyncCallback = WGPUCreateComputePipelineAsyncCallback;\n    using CreateRenderPipelineAsyncCallback = WGPUCreateRenderPipelineAsyncCallback;\n    using DeviceLostCallback = WGPUDeviceLostCallback;\n    using ErrorCallback = WGPUErrorCallback;\n    using LoggingCallback = WGPULoggingCallback;\n    using Proc = WGPUProc;\n    using QueueWorkDoneCallback = WGPUQueueWorkDoneCallback;\n    using RequestAdapterCallback = WGPURequestAdapterCallback;\n    using RequestDeviceCallback = WGPURequestDeviceCallback;\n\n    class Adapter;\n    class BindGroup;\n    class BindGroupLayout;\n    class Buffer;\n    class CommandBuffer;\n    class CommandEncoder;\n    class ComputePassEncoder;\n    class ComputePipeline;\n    class Device;\n    class ExternalTexture;\n    class Instance;\n    class PipelineLayout;\n    class QuerySet;\n    class Queue;\n    class RenderBundle;\n    class RenderBundleEncoder;\n    class RenderPassEncoder;\n    class RenderPipeline;\n    class Sampler;\n    class ShaderModule;\n    class SharedFence;\n    class SharedTextureMemory;\n    class Surface;\n    class SwapChain;\n    class Texture;\n    class TextureView;\n\n    struct AdapterProperties;\n    struct BindGroupEntry;\n    struct BlendComponent;\n    struct BufferBindingLayout;\n    struct BufferDescriptor;\n    struct Color;\n    struct CommandBufferDescriptor;\n    struct CommandEncoderDescriptor;\n    struct CompilationMessage;\n    struct ComputePassTimestampWrite;\n    struct ConstantEntry;\n    struct CopyTextureForBrowserOptions;\n    struct DawnAdapterPropertiesPowerPreference;\n    struct DawnBufferDescriptorErrorInfoFromWireClient;\n    struct DawnCacheDeviceDescriptor;\n    struct DawnEncoderInternalUsageDescriptor;\n    struct DawnMultisampleStateRenderToSingleSampled;\n    struct DawnRenderPassColorAttachmentRenderToSingleSampled;\n    struct DawnShaderModuleSPIRVOptionsDescriptor;\n    struct DawnTextureInternalUsageDescriptor;\n    struct DawnTogglesDescriptor;\n    struct Extent2D;\n    struct Extent3D;\n    struct ExternalTextureBindingEntry;\n    struct ExternalTextureBindingLayout;\n    struct InstanceDescriptor;\n    struct Limits;\n    struct MultisampleState;\n    struct Origin2D;\n    struct Origin3D;\n    struct PipelineLayoutDescriptor;\n    struct PrimitiveDepthClipControl;\n    struct PrimitiveState;\n    struct QuerySetDescriptor;\n    struct QueueDescriptor;\n    struct RenderBundleDescriptor;\n    struct RenderBundleEncoderDescriptor;\n    struct RenderPassDepthStencilAttachment;\n    struct RenderPassDescriptorMaxDrawCount;\n    struct RenderPassTimestampWrite;\n    struct RequestAdapterOptions;\n    struct SamplerBindingLayout;\n    struct SamplerDescriptor;\n    struct ShaderModuleDescriptor;\n    struct ShaderModuleSPIRVDescriptor;\n    struct ShaderModuleWGSLDescriptor;\n    struct SharedFenceDescriptor;\n    struct SharedFenceDXGISharedHandleDescriptor;\n    struct SharedFenceDXGISharedHandleExportInfo;\n    struct SharedFenceExportInfo;\n    struct SharedFenceMTLSharedEventDescriptor;\n    struct SharedFenceMTLSharedEventExportInfo;\n    struct SharedFenceVkSemaphoreOpaqueFDDescriptor;\n    struct SharedFenceVkSemaphoreOpaqueFDExportInfo;\n    struct SharedFenceVkSemaphoreSyncFDDescriptor;\n    struct SharedFenceVkSemaphoreSyncFDExportInfo;\n    struct SharedFenceVkSemaphoreZirconHandleDescriptor;\n    struct SharedFenceVkSemaphoreZirconHandleExportInfo;\n    struct SharedTextureMemoryAHardwareBufferDescriptor;\n    struct SharedTextureMemoryBeginAccessDescriptor;\n    struct SharedTextureMemoryDescriptor;\n    struct SharedTextureMemoryDmaBufDescriptor;\n    struct SharedTextureMemoryDXGISharedHandleDescriptor;\n    struct SharedTextureMemoryEGLImageDescriptor;\n    struct SharedTextureMemoryEndAccessState;\n    struct SharedTextureMemoryIOSurfaceDescriptor;\n    struct SharedTextureMemoryOpaqueFDDescriptor;\n    struct SharedTextureMemoryVkDedicatedAllocationDescriptor;\n    struct SharedTextureMemoryVkImageLayoutBeginState;\n    struct SharedTextureMemoryVkImageLayoutEndState;\n    struct SharedTextureMemoryZirconHandleDescriptor;\n    struct StencilFaceState;\n    struct StorageTextureBindingLayout;\n    struct SurfaceDescriptor;\n    struct SurfaceDescriptorFromAndroidNativeWindow;\n    struct SurfaceDescriptorFromCanvasHTMLSelector;\n    struct SurfaceDescriptorFromMetalLayer;\n    struct SurfaceDescriptorFromWaylandSurface;\n    struct SurfaceDescriptorFromWindowsCoreWindow;\n    struct SurfaceDescriptorFromWindowsHWND;\n    struct SurfaceDescriptorFromWindowsSwapChainPanel;\n    struct SurfaceDescriptorFromXlibWindow;\n    struct SwapChainDescriptor;\n    struct TextureBindingLayout;\n    struct TextureDataLayout;\n    struct TextureViewDescriptor;\n    struct VertexAttribute;\n    struct BindGroupDescriptor;\n    struct BindGroupLayoutEntry;\n    struct BlendState;\n    struct CompilationInfo;\n    struct ComputePassDescriptor;\n    struct DepthStencilState;\n    struct ExternalTextureDescriptor;\n    struct ImageCopyBuffer;\n    struct ImageCopyExternalTexture;\n    struct ImageCopyTexture;\n    struct ProgrammableStageDescriptor;\n    struct RenderPassColorAttachment;\n    struct RequiredLimits;\n    struct SharedTextureMemoryProperties;\n    struct SharedTextureMemoryVkImageDescriptor;\n    struct SupportedLimits;\n    struct TextureDescriptor;\n    struct VertexBufferLayout;\n    struct BindGroupLayoutDescriptor;\n    struct ColorTargetState;\n    struct ComputePipelineDescriptor;\n    struct DeviceDescriptor;\n    struct RenderPassDescriptor;\n    struct VertexState;\n    struct FragmentState;\n    struct RenderPipelineDescriptor;\n\n\n    // Special class for booleans in order to allow implicit conversions.\n    class Bool {\n      public:\n        constexpr Bool() = default;\n        // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n        constexpr Bool(bool value) : mValue(static_cast<WGPUBool>(value)) {}\n        // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n        Bool(WGPUBool value): mValue(value) {}\n\n        constexpr operator bool() const { return static_cast<bool>(mValue); }\n\n      private:\n        friend struct std::hash<Bool>;\n        // Default to false.\n        WGPUBool mValue = static_cast<WGPUBool>(false);\n    };\n\n    template<typename Derived, typename CType>\n    class ObjectBase {\n      public:\n        ObjectBase() = default;\n        ObjectBase(CType handle): mHandle(handle) {\n            if (mHandle) Derived::WGPUReference(mHandle);\n        }\n        ~ObjectBase() {\n            if (mHandle) Derived::WGPURelease(mHandle);\n        }\n\n        ObjectBase(ObjectBase const& other)\n            : ObjectBase(other.Get()) {\n        }\n        Derived& operator=(ObjectBase const& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                if (mHandle) Derived::WGPUReference(mHandle);\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(ObjectBase&& other) {\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n        Derived& operator=(ObjectBase&& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                other.mHandle = 0;\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(std::nullptr_t) {}\n        Derived& operator=(std::nullptr_t) {\n            if (mHandle != nullptr) {\n                Derived::WGPURelease(mHandle);\n                mHandle = nullptr;\n            }\n            return static_cast<Derived&>(*this);\n        }\n\n        bool operator==(std::nullptr_t) const {\n            return mHandle == nullptr;\n        }\n        bool operator!=(std::nullptr_t) const {\n            return mHandle != nullptr;\n        }\n\n        explicit operator bool() const {\n            return mHandle != nullptr;\n        }\n        CType Get() const {\n            return mHandle;\n        }\n        // TODO(dawn:1639) Deprecate Release after uses have been removed.\n        CType Release() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        CType MoveToCHandle() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        static Derived Acquire(CType handle) {\n            Derived result;\n            result.mHandle = handle;\n            return result;\n        }\n\n      protected:\n        CType mHandle = nullptr;\n    };\n\n\n\n    class Adapter : public ObjectBase<Adapter, WGPUAdapter> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Device CreateDevice(DeviceDescriptor const * descriptor = nullptr) const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        Instance GetInstance() const;\n        Bool GetLimits(SupportedLimits * limits) const;\n        void GetProperties(AdapterProperties * properties) const;\n        Bool HasFeature(FeatureName feature) const;\n        void RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Adapter, WGPUAdapter>;\n        static void WGPUReference(WGPUAdapter handle);\n        static void WGPURelease(WGPUAdapter handle);\n    };\n\n    class BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroup, WGPUBindGroup>;\n        static void WGPUReference(WGPUBindGroup handle);\n        static void WGPURelease(WGPUBindGroup handle);\n    };\n\n    class BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n        static void WGPUReference(WGPUBindGroupLayout handle);\n        static void WGPURelease(WGPUBindGroupLayout handle);\n    };\n\n    class Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void const * GetConstMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        BufferMapState GetMapState() const;\n        void * GetMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        uint64_t GetSize() const;\n        BufferUsage GetUsage() const;\n        void MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Unmap() const;\n\n      private:\n        friend ObjectBase<Buffer, WGPUBuffer>;\n        static void WGPUReference(WGPUBuffer handle);\n        static void WGPURelease(WGPUBuffer handle);\n    };\n\n    class CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n        static void WGPUReference(WGPUCommandBuffer handle);\n        static void WGPURelease(WGPUCommandBuffer handle);\n    };\n\n    class CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n        RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n        void ClearBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n        void CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        void CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n        void InjectValidationError(char const * message) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const;\n        void SetLabel(char const * label) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n        static void WGPUReference(WGPUCommandEncoder handle);\n        static void WGPURelease(WGPUCommandEncoder handle);\n    };\n\n    class ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n        void DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(ComputePipeline const& pipeline) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n        static void WGPUReference(WGPUComputePassEncoder handle);\n        static void WGPURelease(WGPUComputePassEncoder handle);\n    };\n\n    class ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n        static void WGPUReference(WGPUComputePipeline handle);\n        static void WGPURelease(WGPUComputePipeline handle);\n    };\n\n    class Device : public ObjectBase<Device, WGPUDevice> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n        BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n        Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n        CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n        ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n        void CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const;\n        Buffer CreateErrorBuffer(BufferDescriptor const * descriptor) const;\n        ExternalTexture CreateErrorExternalTexture() const;\n        ShaderModule CreateErrorShaderModule(ShaderModuleDescriptor const * descriptor, char const * errorMessage) const;\n        Texture CreateErrorTexture(TextureDescriptor const * descriptor) const;\n        ExternalTexture CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const;\n        PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n        QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n        RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n        RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n        void CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const;\n        Sampler CreateSampler(SamplerDescriptor const * descriptor = nullptr) const;\n        ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n        SwapChain CreateSwapChain(Surface const& surface, SwapChainDescriptor const * descriptor) const;\n        Texture CreateTexture(TextureDescriptor const * descriptor) const;\n        void Destroy() const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        void ForceLoss(DeviceLostReason type, char const * message) const;\n        Adapter GetAdapter() const;\n        Bool GetLimits(SupportedLimits * limits) const;\n        Queue GetQueue() const;\n        TextureUsage GetSupportedSurfaceUsage(Surface const& surface) const;\n        Bool HasFeature(FeatureName feature) const;\n        SharedFence ImportSharedFence(SharedFenceDescriptor const * descriptor) const;\n        SharedTextureMemory ImportSharedTextureMemory(SharedTextureMemoryDescriptor const * descriptor) const;\n        void InjectError(ErrorType type, char const * message) const;\n        void PopErrorScope(ErrorCallback callback, void * userdata) const;\n        void PushErrorScope(ErrorFilter filter) const;\n        void SetDeviceLostCallback(DeviceLostCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void SetLoggingCallback(LoggingCallback callback, void * userdata) const;\n        void SetUncapturedErrorCallback(ErrorCallback callback, void * userdata) const;\n        void Tick() const;\n        void ValidateTextureDescriptor(TextureDescriptor const * descriptor) const;\n\n      private:\n        friend ObjectBase<Device, WGPUDevice>;\n        static void WGPUReference(WGPUDevice handle);\n        static void WGPURelease(WGPUDevice handle);\n    };\n\n    class ExternalTexture : public ObjectBase<ExternalTexture, WGPUExternalTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void Expire() const;\n        void Refresh() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ExternalTexture, WGPUExternalTexture>;\n        static void WGPUReference(WGPUExternalTexture handle);\n        static void WGPURelease(WGPUExternalTexture handle);\n    };\n\n    class Instance : public ObjectBase<Instance, WGPUInstance> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n        void ProcessEvents() const;\n        void RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Instance, WGPUInstance>;\n        static void WGPUReference(WGPUInstance handle);\n        static void WGPURelease(WGPUInstance handle);\n    };\n\n    class PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n        static void WGPUReference(WGPUPipelineLayout handle);\n        static void WGPURelease(WGPUPipelineLayout handle);\n    };\n\n    class QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        uint32_t GetCount() const;\n        QueryType GetType() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<QuerySet, WGPUQuerySet>;\n        static void WGPUReference(WGPUQuerySet handle);\n        static void WGPURelease(WGPUQuerySet handle);\n    };\n\n    class Queue : public ObjectBase<Queue, WGPUQueue> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void CopyExternalTextureForBrowser(ImageCopyExternalTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n        void CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n        void OnSubmittedWorkDone(uint64_t signalValue, QueueWorkDoneCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Submit(size_t commandCount, CommandBuffer const * commands) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n        void WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const;\n\n      private:\n        friend ObjectBase<Queue, WGPUQueue>;\n        static void WGPUReference(WGPUQueue handle);\n        static void WGPURelease(WGPUQueue handle);\n    };\n\n    class RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<RenderBundle, WGPURenderBundle>;\n        static void WGPUReference(WGPURenderBundle handle);\n        static void WGPURelease(WGPURenderBundle handle);\n    };\n\n    class RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n\n      private:\n        friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n        static void WGPUReference(WGPURenderBundleEncoder handle);\n        static void WGPURelease(WGPURenderBundleEncoder handle);\n    };\n\n    class RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void BeginOcclusionQuery(uint32_t queryIndex) const;\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndOcclusionQuery() const;\n        void ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetBlendConstant(Color const * color) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n        void SetStencilReference(uint32_t reference) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n        static void WGPUReference(WGPURenderPassEncoder handle);\n        static void WGPURelease(WGPURenderPassEncoder handle);\n    };\n\n    class RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n        static void WGPUReference(WGPURenderPipeline handle);\n        static void WGPURelease(WGPURenderPipeline handle);\n    };\n\n    class Sampler : public ObjectBase<Sampler, WGPUSampler> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Sampler, WGPUSampler>;\n        static void WGPUReference(WGPUSampler handle);\n        static void WGPURelease(WGPUSampler handle);\n    };\n\n    class ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ShaderModule, WGPUShaderModule>;\n        static void WGPUReference(WGPUShaderModule handle);\n        static void WGPURelease(WGPUShaderModule handle);\n    };\n\n    class SharedFence : public ObjectBase<SharedFence, WGPUSharedFence> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void ExportInfo(SharedFenceExportInfo * info) const;\n\n      private:\n        friend ObjectBase<SharedFence, WGPUSharedFence>;\n        static void WGPUReference(WGPUSharedFence handle);\n        static void WGPURelease(WGPUSharedFence handle);\n    };\n\n    class SharedTextureMemory : public ObjectBase<SharedTextureMemory, WGPUSharedTextureMemory> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void BeginAccess(Texture const& texture, SharedTextureMemoryBeginAccessDescriptor const * descriptor) const;\n        Texture CreateTexture(TextureDescriptor const * descriptor) const;\n        void EndAccess(Texture const& texture, SharedTextureMemoryEndAccessState * descriptor) const;\n        void GetProperties(SharedTextureMemoryProperties * properties) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<SharedTextureMemory, WGPUSharedTextureMemory>;\n        static void WGPUReference(WGPUSharedTextureMemory handle);\n        static void WGPURelease(WGPUSharedTextureMemory handle);\n    };\n\n    class Surface : public ObjectBase<Surface, WGPUSurface> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<Surface, WGPUSurface>;\n        static void WGPUReference(WGPUSurface handle);\n        static void WGPURelease(WGPUSurface handle);\n    };\n\n    class SwapChain : public ObjectBase<SwapChain, WGPUSwapChain> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Texture GetCurrentTexture() const;\n        TextureView GetCurrentTextureView() const;\n        void Present() const;\n\n      private:\n        friend ObjectBase<SwapChain, WGPUSwapChain>;\n        static void WGPUReference(WGPUSwapChain handle);\n        static void WGPURelease(WGPUSwapChain handle);\n    };\n\n    class Texture : public ObjectBase<Texture, WGPUTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n        void Destroy() const;\n        uint32_t GetDepthOrArrayLayers() const;\n        TextureDimension GetDimension() const;\n        TextureFormat GetFormat() const;\n        uint32_t GetHeight() const;\n        uint32_t GetMipLevelCount() const;\n        uint32_t GetSampleCount() const;\n        TextureUsage GetUsage() const;\n        uint32_t GetWidth() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Texture, WGPUTexture>;\n        static void WGPUReference(WGPUTexture handle);\n        static void WGPURelease(WGPUTexture handle);\n    };\n\n    class TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<TextureView, WGPUTextureView>;\n        static void WGPUReference(WGPUTextureView handle);\n        static void WGPURelease(WGPUTextureView handle);\n    };\n\n\n    Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr);\n    Proc GetProcAddress(Device device, char const * procName);\n\n    struct AdapterProperties {\n        AdapterProperties() = default;\n        ~AdapterProperties();\n        AdapterProperties(const AdapterProperties&) = delete;\n        AdapterProperties& operator=(const AdapterProperties&) = delete;\n        AdapterProperties(AdapterProperties&&);\n        AdapterProperties& operator=(AdapterProperties&&);\n        ChainedStructOut  * nextInChain = nullptr;\n        uint32_t const vendorID = {};\n        char const * const vendorName = nullptr;\n        char const * const architecture = nullptr;\n        uint32_t const deviceID = {};\n        char const * const name = nullptr;\n        char const * const driverDescription = nullptr;\n        AdapterType const adapterType = {};\n        BackendType const backendType = {};\n        Bool const compatibilityMode = false;\n    };\n\n    struct BindGroupEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        Buffer buffer;\n        uint64_t offset = 0;\n        uint64_t size = WGPU_WHOLE_SIZE;\n        Sampler sampler;\n        TextureView textureView;\n    };\n\n    struct BlendComponent {\n        BlendOperation operation = BlendOperation::Add;\n        BlendFactor srcFactor = BlendFactor::One;\n        BlendFactor dstFactor = BlendFactor::Zero;\n    };\n\n    struct BufferBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        BufferBindingType type = BufferBindingType::Undefined;\n        Bool hasDynamicOffset = false;\n        uint64_t minBindingSize = 0;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BufferUsage usage;\n        uint64_t size;\n        Bool mappedAtCreation = false;\n    };\n\n    struct Color {\n        double r;\n        double g;\n        double b;\n        double a;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CompilationMessage {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * message = nullptr;\n        CompilationMessageType type;\n        uint64_t lineNum;\n        uint64_t linePos;\n        uint64_t offset;\n        uint64_t length;\n        uint64_t utf16LinePos;\n        uint64_t utf16Offset;\n        uint64_t utf16Length;\n    };\n\n    struct ComputePassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        ComputePassTimestampLocation location;\n    };\n\n    struct ConstantEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * key;\n        double value;\n    };\n\n    struct CopyTextureForBrowserOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        Bool flipY = false;\n        Bool needsColorSpaceConversion = false;\n        AlphaMode srcAlphaMode = AlphaMode::Unpremultiplied;\n        float const * srcTransferFunctionParameters = nullptr;\n        float const * conversionMatrix = nullptr;\n        float const * dstTransferFunctionParameters = nullptr;\n        AlphaMode dstAlphaMode = AlphaMode::Unpremultiplied;\n        Bool internalUsage = false;\n    };\n\n    // Can be chained in AdapterProperties\n    struct DawnAdapterPropertiesPowerPreference : ChainedStructOut {\n        DawnAdapterPropertiesPowerPreference() {\n            sType = SType::DawnAdapterPropertiesPowerPreference;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(PowerPreference ));\n        alignas(kFirstMemberAlignment) PowerPreference powerPreference = PowerPreference::Undefined;\n    };\n\n    // Can be chained in BufferDescriptor\n    struct DawnBufferDescriptorErrorInfoFromWireClient : ChainedStruct {\n        DawnBufferDescriptorErrorInfoFromWireClient() {\n            sType = SType::DawnBufferDescriptorErrorInfoFromWireClient;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n        alignas(kFirstMemberAlignment) Bool outOfMemory = false;\n    };\n\n    // Can be chained in DeviceDescriptor\n    struct DawnCacheDeviceDescriptor : ChainedStruct {\n        DawnCacheDeviceDescriptor() {\n            sType = SType::DawnCacheDeviceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * isolationKey = \"\";\n    };\n\n    // Can be chained in CommandEncoderDescriptor\n    struct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n        DawnEncoderInternalUsageDescriptor() {\n            sType = SType::DawnEncoderInternalUsageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n        alignas(kFirstMemberAlignment) Bool useInternalUsages = false;\n    };\n\n    // Can be chained in MultisampleState\n    struct DawnMultisampleStateRenderToSingleSampled : ChainedStruct {\n        DawnMultisampleStateRenderToSingleSampled() {\n            sType = SType::DawnMultisampleStateRenderToSingleSampled;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n        alignas(kFirstMemberAlignment) Bool enabled = false;\n    };\n\n    // Can be chained in RenderPassColorAttachment\n    struct DawnRenderPassColorAttachmentRenderToSingleSampled : ChainedStruct {\n        DawnRenderPassColorAttachmentRenderToSingleSampled() {\n            sType = SType::DawnRenderPassColorAttachmentRenderToSingleSampled;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t implicitSampleCount = 1;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct DawnShaderModuleSPIRVOptionsDescriptor : ChainedStruct {\n        DawnShaderModuleSPIRVOptionsDescriptor() {\n            sType = SType::DawnShaderModuleSPIRVOptionsDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n        alignas(kFirstMemberAlignment) Bool allowNonUniformDerivatives = false;\n    };\n\n    // Can be chained in TextureDescriptor\n    struct DawnTextureInternalUsageDescriptor : ChainedStruct {\n        DawnTextureInternalUsageDescriptor() {\n            sType = SType::DawnTextureInternalUsageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureUsage ));\n        alignas(kFirstMemberAlignment) TextureUsage internalUsage = TextureUsage::None;\n    };\n\n    // Can be chained in InstanceDescriptor\n    // Can be chained in RequestAdapterOptions\n    // Can be chained in DeviceDescriptor\n    struct DawnTogglesDescriptor : ChainedStruct {\n        DawnTogglesDescriptor() {\n            sType = SType::DawnTogglesDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n        alignas(kFirstMemberAlignment) size_t enabledTogglesCount = 0;\n        const char* const * enabledToggles;\n        size_t disabledTogglesCount = 0;\n        const char* const * disabledToggles;\n    };\n\n    struct Extent2D {\n        uint32_t width;\n        uint32_t height;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height = 1;\n        uint32_t depthOrArrayLayers = 1;\n    };\n\n    // Can be chained in BindGroupEntry\n    struct ExternalTextureBindingEntry : ChainedStruct {\n        ExternalTextureBindingEntry() {\n            sType = SType::ExternalTextureBindingEntry;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(ExternalTexture ));\n        alignas(kFirstMemberAlignment) ExternalTexture externalTexture;\n    };\n\n    // Can be chained in BindGroupLayoutEntry\n    struct ExternalTextureBindingLayout : ChainedStruct {\n        ExternalTextureBindingLayout() {\n            sType = SType::ExternalTextureBindingLayout;\n        }\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n    };\n\n    struct Limits {\n        uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroupsPlusVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindingsPerBindGroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxBufferSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachmentBytesPerSample = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n    };\n\n    struct MultisampleState {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t count = 1;\n        uint32_t mask = 0xFFFFFFFF;\n        Bool alphaToCoverageEnabled = false;\n    };\n\n    struct Origin2D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t bindGroupLayoutCount;\n        BindGroupLayout const * bindGroupLayouts;\n    };\n\n    // Can be chained in PrimitiveState\n    struct PrimitiveDepthClipControl : ChainedStruct {\n        PrimitiveDepthClipControl() {\n            sType = SType::PrimitiveDepthClipControl;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n        alignas(kFirstMemberAlignment) Bool unclippedDepth = false;\n    };\n\n    struct PrimitiveState {\n        ChainedStruct const * nextInChain = nullptr;\n        PrimitiveTopology topology = PrimitiveTopology::TriangleList;\n        IndexFormat stripIndexFormat = IndexFormat::Undefined;\n        FrontFace frontFace = FrontFace::CCW;\n        CullMode cullMode = CullMode::None;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        QueryType type;\n        uint32_t count;\n        PipelineStatisticName const * pipelineStatistics;\n        size_t pipelineStatisticsCount = 0;\n    };\n\n    struct QueueDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t colorFormatsCount;\n        TextureFormat const * colorFormats;\n        TextureFormat depthStencilFormat = TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n        Bool depthReadOnly = false;\n        Bool stencilReadOnly = false;\n    };\n\n    struct RenderPassDepthStencilAttachment {\n        TextureView view;\n        LoadOp depthLoadOp = LoadOp::Undefined;\n        StoreOp depthStoreOp = StoreOp::Undefined;\n        float depthClearValue = NAN;\n        Bool depthReadOnly = false;\n        LoadOp stencilLoadOp = LoadOp::Undefined;\n        StoreOp stencilStoreOp = StoreOp::Undefined;\n        uint32_t stencilClearValue = 0;\n        Bool stencilReadOnly = false;\n    };\n\n    // Can be chained in RenderPassDescriptor\n    struct RenderPassDescriptorMaxDrawCount : ChainedStruct {\n        RenderPassDescriptorMaxDrawCount() {\n            sType = SType::RenderPassDescriptorMaxDrawCount;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n        alignas(kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n    };\n\n    struct RenderPassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        RenderPassTimestampLocation location;\n    };\n\n    struct RequestAdapterOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        Surface compatibleSurface;\n        PowerPreference powerPreference = PowerPreference::Undefined;\n        BackendType backendType = BackendType::Undefined;\n        Bool forceFallbackAdapter = false;\n        Bool compatibilityMode = false;\n    };\n\n    struct SamplerBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        SamplerBindingType type = SamplerBindingType::Undefined;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        AddressMode addressModeU = AddressMode::ClampToEdge;\n        AddressMode addressModeV = AddressMode::ClampToEdge;\n        AddressMode addressModeW = AddressMode::ClampToEdge;\n        FilterMode magFilter = FilterMode::Nearest;\n        FilterMode minFilter = FilterMode::Nearest;\n        MipmapFilterMode mipmapFilter = MipmapFilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 32.0f;\n        CompareFunction compare = CompareFunction::Undefined;\n        uint16_t maxAnisotropy = 1;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = SType::ShaderModuleSPIRVDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t codeSize;\n        uint32_t const * code;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = SType::ShaderModuleWGSLDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * code;\n    };\n\n    struct SharedFenceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in SharedFenceDescriptor\n    struct SharedFenceDXGISharedHandleDescriptor : ChainedStruct {\n        SharedFenceDXGISharedHandleDescriptor() {\n            sType = SType::SharedFenceDXGISharedHandleDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * handle;\n    };\n\n    // Can be chained in SharedFenceExportInfo\n    struct SharedFenceDXGISharedHandleExportInfo : ChainedStructOut {\n        SharedFenceDXGISharedHandleExportInfo() {\n            sType = SType::SharedFenceDXGISharedHandleExportInfo;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * handle;\n    };\n\n    struct SharedFenceExportInfo {\n        ChainedStructOut  * nextInChain = nullptr;\n        SharedFenceType type;\n    };\n\n    // Can be chained in SharedFenceDescriptor\n    struct SharedFenceMTLSharedEventDescriptor : ChainedStruct {\n        SharedFenceMTLSharedEventDescriptor() {\n            sType = SType::SharedFenceMTLSharedEventDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * sharedEvent;\n    };\n\n    // Can be chained in SharedFenceExportInfo\n    struct SharedFenceMTLSharedEventExportInfo : ChainedStructOut {\n        SharedFenceMTLSharedEventExportInfo() {\n            sType = SType::SharedFenceMTLSharedEventExportInfo;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * sharedEvent;\n    };\n\n    // Can be chained in SharedFenceDescriptor\n    struct SharedFenceVkSemaphoreOpaqueFDDescriptor : ChainedStruct {\n        SharedFenceVkSemaphoreOpaqueFDDescriptor() {\n            sType = SType::SharedFenceVkSemaphoreOpaqueFDDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n        alignas(kFirstMemberAlignment) int handle;\n    };\n\n    // Can be chained in SharedFenceExportInfo\n    struct SharedFenceVkSemaphoreOpaqueFDExportInfo : ChainedStructOut {\n        SharedFenceVkSemaphoreOpaqueFDExportInfo() {\n            sType = SType::SharedFenceVkSemaphoreOpaqueFDExportInfo;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n        alignas(kFirstMemberAlignment) int handle;\n    };\n\n    // Can be chained in SharedFenceDescriptor\n    struct SharedFenceVkSemaphoreSyncFDDescriptor : ChainedStruct {\n        SharedFenceVkSemaphoreSyncFDDescriptor() {\n            sType = SType::SharedFenceVkSemaphoreSyncFDDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n        alignas(kFirstMemberAlignment) int handle;\n    };\n\n    // Can be chained in SharedFenceExportInfo\n    struct SharedFenceVkSemaphoreSyncFDExportInfo : ChainedStructOut {\n        SharedFenceVkSemaphoreSyncFDExportInfo() {\n            sType = SType::SharedFenceVkSemaphoreSyncFDExportInfo;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n        alignas(kFirstMemberAlignment) int handle;\n    };\n\n    // Can be chained in SharedFenceDescriptor\n    struct SharedFenceVkSemaphoreZirconHandleDescriptor : ChainedStruct {\n        SharedFenceVkSemaphoreZirconHandleDescriptor() {\n            sType = SType::SharedFenceVkSemaphoreZirconHandleDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t handle;\n    };\n\n    // Can be chained in SharedFenceExportInfo\n    struct SharedFenceVkSemaphoreZirconHandleExportInfo : ChainedStructOut {\n        SharedFenceVkSemaphoreZirconHandleExportInfo() {\n            sType = SType::SharedFenceVkSemaphoreZirconHandleExportInfo;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t handle;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryAHardwareBufferDescriptor : ChainedStruct {\n        SharedTextureMemoryAHardwareBufferDescriptor() {\n            sType = SType::SharedTextureMemoryAHardwareBufferDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * handle;\n    };\n\n    struct SharedTextureMemoryBeginAccessDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        Bool initialized;\n        size_t fenceCount;\n        SharedFence const * fences;\n        uint64_t const * signaledValues;\n    };\n\n    struct SharedTextureMemoryDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryDmaBufDescriptor : ChainedStruct {\n        SharedTextureMemoryDmaBufDescriptor() {\n            sType = SType::SharedTextureMemoryDmaBufDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n        alignas(kFirstMemberAlignment) int memoryFD;\n        uint64_t allocationSize;\n        uint64_t drmModifier;\n        size_t planeCount;\n        uint64_t const * planeOffsets;\n        uint32_t const * planeStrides;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryDXGISharedHandleDescriptor : ChainedStruct {\n        SharedTextureMemoryDXGISharedHandleDescriptor() {\n            sType = SType::SharedTextureMemoryDXGISharedHandleDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * handle;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryEGLImageDescriptor : ChainedStruct {\n        SharedTextureMemoryEGLImageDescriptor() {\n            sType = SType::SharedTextureMemoryEGLImageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * image;\n    };\n\n    struct SharedTextureMemoryEndAccessState {\n        SharedTextureMemoryEndAccessState() = default;\n        ~SharedTextureMemoryEndAccessState();\n        SharedTextureMemoryEndAccessState(const SharedTextureMemoryEndAccessState&) = delete;\n        SharedTextureMemoryEndAccessState& operator=(const SharedTextureMemoryEndAccessState&) = delete;\n        SharedTextureMemoryEndAccessState(SharedTextureMemoryEndAccessState&&);\n        SharedTextureMemoryEndAccessState& operator=(SharedTextureMemoryEndAccessState&&);\n        ChainedStructOut  * nextInChain = nullptr;\n        Bool const initialized = {};\n        size_t const fenceCount = {};\n        SharedFence const * const fences = {};\n        uint64_t const * const signaledValues = {};\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryIOSurfaceDescriptor : ChainedStruct {\n        SharedTextureMemoryIOSurfaceDescriptor() {\n            sType = SType::SharedTextureMemoryIOSurfaceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * ioSurface;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryOpaqueFDDescriptor : ChainedStruct {\n        SharedTextureMemoryOpaqueFDDescriptor() {\n            sType = SType::SharedTextureMemoryOpaqueFDDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n        alignas(kFirstMemberAlignment) int memoryFD;\n        uint64_t allocationSize;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryVkDedicatedAllocationDescriptor : ChainedStruct {\n        SharedTextureMemoryVkDedicatedAllocationDescriptor() {\n            sType = SType::SharedTextureMemoryVkDedicatedAllocationDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n        alignas(kFirstMemberAlignment) Bool dedicatedAllocation;\n    };\n\n    // Can be chained in SharedTextureMemoryBeginAccessDescriptor\n    struct SharedTextureMemoryVkImageLayoutBeginState : ChainedStruct {\n        SharedTextureMemoryVkImageLayoutBeginState() {\n            sType = SType::SharedTextureMemoryVkImageLayoutBeginState;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n        alignas(kFirstMemberAlignment) int32_t oldLayout;\n        int32_t newLayout;\n    };\n\n    // Can be chained in SharedTextureMemoryEndAccessState\n    struct SharedTextureMemoryVkImageLayoutEndState : ChainedStructOut {\n        SharedTextureMemoryVkImageLayoutEndState() {\n            sType = SType::SharedTextureMemoryVkImageLayoutEndState;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n        alignas(kFirstMemberAlignment) int32_t oldLayout;\n        int32_t newLayout;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryZirconHandleDescriptor : ChainedStruct {\n        SharedTextureMemoryZirconHandleDescriptor() {\n            sType = SType::SharedTextureMemoryZirconHandleDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t memoryFD;\n        uint64_t allocationSize;\n    };\n\n    struct StencilFaceState {\n        CompareFunction compare = CompareFunction::Always;\n        StencilOperation failOp = StencilOperation::Keep;\n        StencilOperation depthFailOp = StencilOperation::Keep;\n        StencilOperation passOp = StencilOperation::Keep;\n    };\n\n    struct StorageTextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        StorageTextureAccess access = StorageTextureAccess::Undefined;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromAndroidNativeWindow : ChainedStruct {\n        SurfaceDescriptorFromAndroidNativeWindow() {\n            sType = SType::SurfaceDescriptorFromAndroidNativeWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * window;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromCanvasHTMLSelector : ChainedStruct {\n        SurfaceDescriptorFromCanvasHTMLSelector() {\n            sType = SType::SurfaceDescriptorFromCanvasHTMLSelector;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * selector;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromMetalLayer : ChainedStruct {\n        SurfaceDescriptorFromMetalLayer() {\n            sType = SType::SurfaceDescriptorFromMetalLayer;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * layer;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWaylandSurface : ChainedStruct {\n        SurfaceDescriptorFromWaylandSurface() {\n            sType = SType::SurfaceDescriptorFromWaylandSurface;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * display;\n        void * surface;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n        SurfaceDescriptorFromWindowsCoreWindow() {\n            sType = SType::SurfaceDescriptorFromWindowsCoreWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * coreWindow;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWindowsHWND : ChainedStruct {\n        SurfaceDescriptorFromWindowsHWND() {\n            sType = SType::SurfaceDescriptorFromWindowsHWND;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * hinstance;\n        void * hwnd;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n        SurfaceDescriptorFromWindowsSwapChainPanel() {\n            sType = SType::SurfaceDescriptorFromWindowsSwapChainPanel;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * swapChainPanel;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromXlibWindow : ChainedStruct {\n        SurfaceDescriptorFromXlibWindow() {\n            sType = SType::SurfaceDescriptorFromXlibWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * display;\n        uint32_t window;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        PresentMode presentMode;\n    };\n\n    struct TextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureSampleType sampleType = TextureSampleType::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n        Bool multisampled = false;\n    };\n\n    struct TextureDataLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n        uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension dimension = TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct VertexAttribute {\n        VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayout layout;\n        size_t entryCount;\n        BindGroupEntry const * entries;\n    };\n\n    struct BindGroupLayoutEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        ShaderStage visibility;\n        BufferBindingLayout buffer;\n        SamplerBindingLayout sampler;\n        TextureBindingLayout texture;\n        StorageTextureBindingLayout storageTexture;\n    };\n\n    struct BlendState {\n        BlendComponent color;\n        BlendComponent alpha;\n    };\n\n    struct CompilationInfo {\n        ChainedStruct const * nextInChain = nullptr;\n        size_t messageCount;\n        CompilationMessage const * messages;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t timestampWriteCount = 0;\n        ComputePassTimestampWrite const * timestampWrites;\n    };\n\n    struct DepthStencilState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        Bool depthWriteEnabled;\n        CompareFunction depthCompare;\n        StencilFaceState stencilFront;\n        StencilFaceState stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n    };\n\n    struct ExternalTextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureView plane0;\n        TextureView plane1;\n        Origin2D visibleOrigin;\n        Extent2D visibleSize;\n        Bool doYuvToRgbConversionOnly = false;\n        float const * yuvToRgbConversionMatrix = nullptr;\n        float const * srcTransferFunctionParameters;\n        float const * dstTransferFunctionParameters;\n        float const * gamutConversionMatrix;\n        Bool flipY = false;\n        ExternalTextureRotation rotation = ExternalTextureRotation::Rotate0Degrees;\n    };\n\n    struct ImageCopyBuffer {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureDataLayout layout;\n        Buffer buffer;\n    };\n\n    struct ImageCopyExternalTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        ExternalTexture externalTexture;\n        Origin3D origin;\n        Extent2D naturalSize;\n    };\n\n    struct ImageCopyTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        Texture texture;\n        uint32_t mipLevel = 0;\n        Origin3D origin;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n    };\n\n    struct RenderPassColorAttachment {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureView view;\n        TextureView resolveTarget;\n        LoadOp loadOp;\n        StoreOp storeOp;\n        Color clearValue;\n    };\n\n    struct RequiredLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct SharedTextureMemoryProperties {\n        ChainedStructOut  * nextInChain = nullptr;\n        TextureUsage usage;\n        Extent3D size;\n        TextureFormat format;\n    };\n\n    // Can be chained in SharedTextureMemoryDescriptor\n    struct SharedTextureMemoryVkImageDescriptor : ChainedStruct {\n        SharedTextureMemoryVkImageDescriptor() {\n            sType = SType::SharedTextureMemoryVkImageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n        alignas(kFirstMemberAlignment) int32_t vkFormat;\n        int32_t vkUsageFlags;\n        Extent3D vkExtent3D;\n    };\n\n    struct SupportedLimits {\n        ChainedStructOut  * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureDimension dimension = TextureDimension::e2D;\n        Extent3D size;\n        TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n        size_t viewFormatCount = 0;\n        TextureFormat const * viewFormats;\n    };\n\n    struct VertexBufferLayout {\n        uint64_t arrayStride;\n        VertexStepMode stepMode = VertexStepMode::Vertex;\n        size_t attributeCount;\n        VertexAttribute const * attributes;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t entryCount;\n        BindGroupLayoutEntry const * entries;\n    };\n\n    struct ColorTargetState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        BlendState const * blend = nullptr;\n        ColorWriteMask writeMask = ColorWriteMask::All;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout;\n        ProgrammableStageDescriptor compute;\n    };\n\n    struct DeviceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t requiredFeaturesCount = 0;\n        FeatureName const * requiredFeatures = nullptr;\n        RequiredLimits const * requiredLimits = nullptr;\n        QueueDescriptor defaultQueue;\n        DeviceLostCallback deviceLostCallback = nullptr;\n        void * deviceLostUserdata = nullptr;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t colorAttachmentCount;\n        RenderPassColorAttachment const * colorAttachments;\n        RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n        QuerySet occlusionQuerySet;\n        size_t timestampWriteCount = 0;\n        RenderPassTimestampWrite const * timestampWrites;\n    };\n\n    struct VertexState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n        size_t bufferCount = 0;\n        VertexBufferLayout const * buffers;\n    };\n\n    struct FragmentState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n        size_t targetCount;\n        ColorTargetState const * targets;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout;\n        VertexState vertex;\n        PrimitiveState primitive;\n        DepthStencilState const * depthStencil = nullptr;\n        MultisampleState multisample;\n        FragmentState const * fragment = nullptr;\n    };\n\n\n    // The operators of EnumClassBitmmasks in the dawn:: namespace need to be imported\n    // in the wgpu namespace for Argument Dependent Lookup.\n    DAWN_IMPORT_BITMASK_OPERATORS\n}  // namespace wgpu\n\nnamespace dawn {\n    template<>\n    struct IsDawnBitmask<wgpu::BufferUsage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ColorWriteMask> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::MapMode> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ShaderStage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::TextureUsage> {\n        static constexpr bool enable = true;\n    };\n\n} // namespace dawn\n\nnamespace std {\n// Custom boolean class needs corresponding hash function so that it appears as a transparent bool.\ntemplate <>\nstruct hash<wgpu::Bool> {\n  public:\n    size_t operator()(const wgpu::Bool &v) const {\n        return hash<bool>()(v);\n    }\n};\n}  // namespace std\n\n#endif // WEBGPU_CPP_H_\n", "./include/dawn/dawn_thread_dispatch_proc.h": "// Copyright 2020 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_DAWN_THREAD_DISPATCH_PROC_H_\n#define INCLUDE_DAWN_DAWN_THREAD_DISPATCH_PROC_H_\n\n#include \"dawn/dawn_proc.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Call dawnProcSetProcs(&dawnThreadDispatchProcTable) and then use dawnProcSetPerThreadProcs\n// to set per-thread procs.\nWGPU_EXPORT extern DawnProcTable dawnThreadDispatchProcTable;\nWGPU_EXPORT void dawnProcSetDefaultThreadProcs(const DawnProcTable* procs);\nWGPU_EXPORT void dawnProcSetPerThreadProcs(const DawnProcTable* procs);\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n#endif  // INCLUDE_DAWN_DAWN_THREAD_DISPATCH_PROC_H_\n", "./include/dawn/webgpu_cpp_chained_struct.h": "#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n#ifndef WEBGPU_CPP_CHAINED_STRUCT_H_\n#define WEBGPU_CPP_CHAINED_STRUCT_H_\n\n#include <cstddef>\n#include <cstdint>\n\n// This header file declares the ChainedStruct structures separately from the WebGPU\n// headers so that dependencies can directly extend structures without including the larger header\n// which exposes capabilities that may require correctly set proc tables.\nnamespace wgpu {\n\n    namespace detail {\n        constexpr size_t ConstexprMax(size_t a, size_t b) {\n            return a > b ? a : b;\n        }\n    }  // namespace detail\n\n    enum class SType : uint32_t;\n\n    struct ChainedStruct {\n        ChainedStruct const * nextInChain = nullptr;\n        SType sType = SType(0u);\n    };\n\n    struct ChainedStructOut {\n        ChainedStructOut * nextInChain = nullptr;\n        SType sType = SType(0u);\n    };\n\n}  // namespace wgpu}\n\n#endif // WEBGPU_CPP_CHAINED_STRUCT_H_\n", "./include/dawn/dawn_proc_table.h": "\n#ifndef DAWN_DAWN_PROC_TABLE_H_\n#define DAWN_DAWN_PROC_TABLE_H_\n\n#include \"dawn/webgpu.h\"\n\n// Note: Often allocated as a static global. Do not add a complex constructor.\ntypedef struct DawnProcTable {\n    WGPUProcAdapterPropertiesFreeMembers adapterPropertiesFreeMembers;\n    WGPUProcCreateInstance createInstance;\n    WGPUProcGetProcAddress getProcAddress;\n    WGPUProcSharedTextureMemoryEndAccessStateFreeMembers sharedTextureMemoryEndAccessStateFreeMembers;\n\n    WGPUProcAdapterCreateDevice adapterCreateDevice;\n    WGPUProcAdapterEnumerateFeatures adapterEnumerateFeatures;\n    WGPUProcAdapterGetInstance adapterGetInstance;\n    WGPUProcAdapterGetLimits adapterGetLimits;\n    WGPUProcAdapterGetProperties adapterGetProperties;\n    WGPUProcAdapterHasFeature adapterHasFeature;\n    WGPUProcAdapterRequestDevice adapterRequestDevice;\n    WGPUProcAdapterReference adapterReference;\n    WGPUProcAdapterRelease adapterRelease;\n\n    WGPUProcBindGroupSetLabel bindGroupSetLabel;\n    WGPUProcBindGroupReference bindGroupReference;\n    WGPUProcBindGroupRelease bindGroupRelease;\n\n    WGPUProcBindGroupLayoutSetLabel bindGroupLayoutSetLabel;\n    WGPUProcBindGroupLayoutReference bindGroupLayoutReference;\n    WGPUProcBindGroupLayoutRelease bindGroupLayoutRelease;\n\n    WGPUProcBufferDestroy bufferDestroy;\n    WGPUProcBufferGetConstMappedRange bufferGetConstMappedRange;\n    WGPUProcBufferGetMapState bufferGetMapState;\n    WGPUProcBufferGetMappedRange bufferGetMappedRange;\n    WGPUProcBufferGetSize bufferGetSize;\n    WGPUProcBufferGetUsage bufferGetUsage;\n    WGPUProcBufferMapAsync bufferMapAsync;\n    WGPUProcBufferSetLabel bufferSetLabel;\n    WGPUProcBufferUnmap bufferUnmap;\n    WGPUProcBufferReference bufferReference;\n    WGPUProcBufferRelease bufferRelease;\n\n    WGPUProcCommandBufferSetLabel commandBufferSetLabel;\n    WGPUProcCommandBufferReference commandBufferReference;\n    WGPUProcCommandBufferRelease commandBufferRelease;\n\n    WGPUProcCommandEncoderBeginComputePass commandEncoderBeginComputePass;\n    WGPUProcCommandEncoderBeginRenderPass commandEncoderBeginRenderPass;\n    WGPUProcCommandEncoderClearBuffer commandEncoderClearBuffer;\n    WGPUProcCommandEncoderCopyBufferToBuffer commandEncoderCopyBufferToBuffer;\n    WGPUProcCommandEncoderCopyBufferToTexture commandEncoderCopyBufferToTexture;\n    WGPUProcCommandEncoderCopyTextureToBuffer commandEncoderCopyTextureToBuffer;\n    WGPUProcCommandEncoderCopyTextureToTexture commandEncoderCopyTextureToTexture;\n    WGPUProcCommandEncoderFinish commandEncoderFinish;\n    WGPUProcCommandEncoderInjectValidationError commandEncoderInjectValidationError;\n    WGPUProcCommandEncoderInsertDebugMarker commandEncoderInsertDebugMarker;\n    WGPUProcCommandEncoderPopDebugGroup commandEncoderPopDebugGroup;\n    WGPUProcCommandEncoderPushDebugGroup commandEncoderPushDebugGroup;\n    WGPUProcCommandEncoderResolveQuerySet commandEncoderResolveQuerySet;\n    WGPUProcCommandEncoderSetLabel commandEncoderSetLabel;\n    WGPUProcCommandEncoderWriteBuffer commandEncoderWriteBuffer;\n    WGPUProcCommandEncoderWriteTimestamp commandEncoderWriteTimestamp;\n    WGPUProcCommandEncoderReference commandEncoderReference;\n    WGPUProcCommandEncoderRelease commandEncoderRelease;\n\n    WGPUProcComputePassEncoderDispatchWorkgroups computePassEncoderDispatchWorkgroups;\n    WGPUProcComputePassEncoderDispatchWorkgroupsIndirect computePassEncoderDispatchWorkgroupsIndirect;\n    WGPUProcComputePassEncoderEnd computePassEncoderEnd;\n    WGPUProcComputePassEncoderInsertDebugMarker computePassEncoderInsertDebugMarker;\n    WGPUProcComputePassEncoderPopDebugGroup computePassEncoderPopDebugGroup;\n    WGPUProcComputePassEncoderPushDebugGroup computePassEncoderPushDebugGroup;\n    WGPUProcComputePassEncoderSetBindGroup computePassEncoderSetBindGroup;\n    WGPUProcComputePassEncoderSetLabel computePassEncoderSetLabel;\n    WGPUProcComputePassEncoderSetPipeline computePassEncoderSetPipeline;\n    WGPUProcComputePassEncoderWriteTimestamp computePassEncoderWriteTimestamp;\n    WGPUProcComputePassEncoderReference computePassEncoderReference;\n    WGPUProcComputePassEncoderRelease computePassEncoderRelease;\n\n    WGPUProcComputePipelineGetBindGroupLayout computePipelineGetBindGroupLayout;\n    WGPUProcComputePipelineSetLabel computePipelineSetLabel;\n    WGPUProcComputePipelineReference computePipelineReference;\n    WGPUProcComputePipelineRelease computePipelineRelease;\n\n    WGPUProcDeviceCreateBindGroup deviceCreateBindGroup;\n    WGPUProcDeviceCreateBindGroupLayout deviceCreateBindGroupLayout;\n    WGPUProcDeviceCreateBuffer deviceCreateBuffer;\n    WGPUProcDeviceCreateCommandEncoder deviceCreateCommandEncoder;\n    WGPUProcDeviceCreateComputePipeline deviceCreateComputePipeline;\n    WGPUProcDeviceCreateComputePipelineAsync deviceCreateComputePipelineAsync;\n    WGPUProcDeviceCreateErrorBuffer deviceCreateErrorBuffer;\n    WGPUProcDeviceCreateErrorExternalTexture deviceCreateErrorExternalTexture;\n    WGPUProcDeviceCreateErrorShaderModule deviceCreateErrorShaderModule;\n    WGPUProcDeviceCreateErrorTexture deviceCreateErrorTexture;\n    WGPUProcDeviceCreateExternalTexture deviceCreateExternalTexture;\n    WGPUProcDeviceCreatePipelineLayout deviceCreatePipelineLayout;\n    WGPUProcDeviceCreateQuerySet deviceCreateQuerySet;\n    WGPUProcDeviceCreateRenderBundleEncoder deviceCreateRenderBundleEncoder;\n    WGPUProcDeviceCreateRenderPipeline deviceCreateRenderPipeline;\n    WGPUProcDeviceCreateRenderPipelineAsync deviceCreateRenderPipelineAsync;\n    WGPUProcDeviceCreateSampler deviceCreateSampler;\n    WGPUProcDeviceCreateShaderModule deviceCreateShaderModule;\n    WGPUProcDeviceCreateSwapChain deviceCreateSwapChain;\n    WGPUProcDeviceCreateTexture deviceCreateTexture;\n    WGPUProcDeviceDestroy deviceDestroy;\n    WGPUProcDeviceEnumerateFeatures deviceEnumerateFeatures;\n    WGPUProcDeviceForceLoss deviceForceLoss;\n    WGPUProcDeviceGetAdapter deviceGetAdapter;\n    WGPUProcDeviceGetLimits deviceGetLimits;\n    WGPUProcDeviceGetQueue deviceGetQueue;\n    WGPUProcDeviceGetSupportedSurfaceUsage deviceGetSupportedSurfaceUsage;\n    WGPUProcDeviceHasFeature deviceHasFeature;\n    WGPUProcDeviceImportSharedFence deviceImportSharedFence;\n    WGPUProcDeviceImportSharedTextureMemory deviceImportSharedTextureMemory;\n    WGPUProcDeviceInjectError deviceInjectError;\n    WGPUProcDevicePopErrorScope devicePopErrorScope;\n    WGPUProcDevicePushErrorScope devicePushErrorScope;\n    WGPUProcDeviceSetDeviceLostCallback deviceSetDeviceLostCallback;\n    WGPUProcDeviceSetLabel deviceSetLabel;\n    WGPUProcDeviceSetLoggingCallback deviceSetLoggingCallback;\n    WGPUProcDeviceSetUncapturedErrorCallback deviceSetUncapturedErrorCallback;\n    WGPUProcDeviceTick deviceTick;\n    WGPUProcDeviceValidateTextureDescriptor deviceValidateTextureDescriptor;\n    WGPUProcDeviceReference deviceReference;\n    WGPUProcDeviceRelease deviceRelease;\n\n    WGPUProcExternalTextureDestroy externalTextureDestroy;\n    WGPUProcExternalTextureExpire externalTextureExpire;\n    WGPUProcExternalTextureRefresh externalTextureRefresh;\n    WGPUProcExternalTextureSetLabel externalTextureSetLabel;\n    WGPUProcExternalTextureReference externalTextureReference;\n    WGPUProcExternalTextureRelease externalTextureRelease;\n\n    WGPUProcInstanceCreateSurface instanceCreateSurface;\n    WGPUProcInstanceProcessEvents instanceProcessEvents;\n    WGPUProcInstanceRequestAdapter instanceRequestAdapter;\n    WGPUProcInstanceReference instanceReference;\n    WGPUProcInstanceRelease instanceRelease;\n\n    WGPUProcPipelineLayoutSetLabel pipelineLayoutSetLabel;\n    WGPUProcPipelineLayoutReference pipelineLayoutReference;\n    WGPUProcPipelineLayoutRelease pipelineLayoutRelease;\n\n    WGPUProcQuerySetDestroy querySetDestroy;\n    WGPUProcQuerySetGetCount querySetGetCount;\n    WGPUProcQuerySetGetType querySetGetType;\n    WGPUProcQuerySetSetLabel querySetSetLabel;\n    WGPUProcQuerySetReference querySetReference;\n    WGPUProcQuerySetRelease querySetRelease;\n\n    WGPUProcQueueCopyExternalTextureForBrowser queueCopyExternalTextureForBrowser;\n    WGPUProcQueueCopyTextureForBrowser queueCopyTextureForBrowser;\n    WGPUProcQueueOnSubmittedWorkDone queueOnSubmittedWorkDone;\n    WGPUProcQueueSetLabel queueSetLabel;\n    WGPUProcQueueSubmit queueSubmit;\n    WGPUProcQueueWriteBuffer queueWriteBuffer;\n    WGPUProcQueueWriteTexture queueWriteTexture;\n    WGPUProcQueueReference queueReference;\n    WGPUProcQueueRelease queueRelease;\n\n    WGPUProcRenderBundleSetLabel renderBundleSetLabel;\n    WGPUProcRenderBundleReference renderBundleReference;\n    WGPUProcRenderBundleRelease renderBundleRelease;\n\n    WGPUProcRenderBundleEncoderDraw renderBundleEncoderDraw;\n    WGPUProcRenderBundleEncoderDrawIndexed renderBundleEncoderDrawIndexed;\n    WGPUProcRenderBundleEncoderDrawIndexedIndirect renderBundleEncoderDrawIndexedIndirect;\n    WGPUProcRenderBundleEncoderDrawIndirect renderBundleEncoderDrawIndirect;\n    WGPUProcRenderBundleEncoderFinish renderBundleEncoderFinish;\n    WGPUProcRenderBundleEncoderInsertDebugMarker renderBundleEncoderInsertDebugMarker;\n    WGPUProcRenderBundleEncoderPopDebugGroup renderBundleEncoderPopDebugGroup;\n    WGPUProcRenderBundleEncoderPushDebugGroup renderBundleEncoderPushDebugGroup;\n    WGPUProcRenderBundleEncoderSetBindGroup renderBundleEncoderSetBindGroup;\n    WGPUProcRenderBundleEncoderSetIndexBuffer renderBundleEncoderSetIndexBuffer;\n    WGPUProcRenderBundleEncoderSetLabel renderBundleEncoderSetLabel;\n    WGPUProcRenderBundleEncoderSetPipeline renderBundleEncoderSetPipeline;\n    WGPUProcRenderBundleEncoderSetVertexBuffer renderBundleEncoderSetVertexBuffer;\n    WGPUProcRenderBundleEncoderReference renderBundleEncoderReference;\n    WGPUProcRenderBundleEncoderRelease renderBundleEncoderRelease;\n\n    WGPUProcRenderPassEncoderBeginOcclusionQuery renderPassEncoderBeginOcclusionQuery;\n    WGPUProcRenderPassEncoderDraw renderPassEncoderDraw;\n    WGPUProcRenderPassEncoderDrawIndexed renderPassEncoderDrawIndexed;\n    WGPUProcRenderPassEncoderDrawIndexedIndirect renderPassEncoderDrawIndexedIndirect;\n    WGPUProcRenderPassEncoderDrawIndirect renderPassEncoderDrawIndirect;\n    WGPUProcRenderPassEncoderEnd renderPassEncoderEnd;\n    WGPUProcRenderPassEncoderEndOcclusionQuery renderPassEncoderEndOcclusionQuery;\n    WGPUProcRenderPassEncoderExecuteBundles renderPassEncoderExecuteBundles;\n    WGPUProcRenderPassEncoderInsertDebugMarker renderPassEncoderInsertDebugMarker;\n    WGPUProcRenderPassEncoderPopDebugGroup renderPassEncoderPopDebugGroup;\n    WGPUProcRenderPassEncoderPushDebugGroup renderPassEncoderPushDebugGroup;\n    WGPUProcRenderPassEncoderSetBindGroup renderPassEncoderSetBindGroup;\n    WGPUProcRenderPassEncoderSetBlendConstant renderPassEncoderSetBlendConstant;\n    WGPUProcRenderPassEncoderSetIndexBuffer renderPassEncoderSetIndexBuffer;\n    WGPUProcRenderPassEncoderSetLabel renderPassEncoderSetLabel;\n    WGPUProcRenderPassEncoderSetPipeline renderPassEncoderSetPipeline;\n    WGPUProcRenderPassEncoderSetScissorRect renderPassEncoderSetScissorRect;\n    WGPUProcRenderPassEncoderSetStencilReference renderPassEncoderSetStencilReference;\n    WGPUProcRenderPassEncoderSetVertexBuffer renderPassEncoderSetVertexBuffer;\n    WGPUProcRenderPassEncoderSetViewport renderPassEncoderSetViewport;\n    WGPUProcRenderPassEncoderWriteTimestamp renderPassEncoderWriteTimestamp;\n    WGPUProcRenderPassEncoderReference renderPassEncoderReference;\n    WGPUProcRenderPassEncoderRelease renderPassEncoderRelease;\n\n    WGPUProcRenderPipelineGetBindGroupLayout renderPipelineGetBindGroupLayout;\n    WGPUProcRenderPipelineSetLabel renderPipelineSetLabel;\n    WGPUProcRenderPipelineReference renderPipelineReference;\n    WGPUProcRenderPipelineRelease renderPipelineRelease;\n\n    WGPUProcSamplerSetLabel samplerSetLabel;\n    WGPUProcSamplerReference samplerReference;\n    WGPUProcSamplerRelease samplerRelease;\n\n    WGPUProcShaderModuleGetCompilationInfo shaderModuleGetCompilationInfo;\n    WGPUProcShaderModuleSetLabel shaderModuleSetLabel;\n    WGPUProcShaderModuleReference shaderModuleReference;\n    WGPUProcShaderModuleRelease shaderModuleRelease;\n\n    WGPUProcSharedFenceExportInfo sharedFenceExportInfo;\n    WGPUProcSharedFenceReference sharedFenceReference;\n    WGPUProcSharedFenceRelease sharedFenceRelease;\n\n    WGPUProcSharedTextureMemoryBeginAccess sharedTextureMemoryBeginAccess;\n    WGPUProcSharedTextureMemoryCreateTexture sharedTextureMemoryCreateTexture;\n    WGPUProcSharedTextureMemoryEndAccess sharedTextureMemoryEndAccess;\n    WGPUProcSharedTextureMemoryGetProperties sharedTextureMemoryGetProperties;\n    WGPUProcSharedTextureMemorySetLabel sharedTextureMemorySetLabel;\n    WGPUProcSharedTextureMemoryReference sharedTextureMemoryReference;\n    WGPUProcSharedTextureMemoryRelease sharedTextureMemoryRelease;\n\n    WGPUProcSurfaceReference surfaceReference;\n    WGPUProcSurfaceRelease surfaceRelease;\n\n    WGPUProcSwapChainGetCurrentTexture swapChainGetCurrentTexture;\n    WGPUProcSwapChainGetCurrentTextureView swapChainGetCurrentTextureView;\n    WGPUProcSwapChainPresent swapChainPresent;\n    WGPUProcSwapChainReference swapChainReference;\n    WGPUProcSwapChainRelease swapChainRelease;\n\n    WGPUProcTextureCreateView textureCreateView;\n    WGPUProcTextureDestroy textureDestroy;\n    WGPUProcTextureGetDepthOrArrayLayers textureGetDepthOrArrayLayers;\n    WGPUProcTextureGetDimension textureGetDimension;\n    WGPUProcTextureGetFormat textureGetFormat;\n    WGPUProcTextureGetHeight textureGetHeight;\n    WGPUProcTextureGetMipLevelCount textureGetMipLevelCount;\n    WGPUProcTextureGetSampleCount textureGetSampleCount;\n    WGPUProcTextureGetUsage textureGetUsage;\n    WGPUProcTextureGetWidth textureGetWidth;\n    WGPUProcTextureSetLabel textureSetLabel;\n    WGPUProcTextureReference textureReference;\n    WGPUProcTextureRelease textureRelease;\n\n    WGPUProcTextureViewSetLabel textureViewSetLabel;\n    WGPUProcTextureViewReference textureViewReference;\n    WGPUProcTextureViewRelease textureViewRelease;\n\n\n} DawnProcTable;\n\n#endif  // DAWN_DAWN_PROC_TABLE_H_\n", "./include/dawn/dawn_proc.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_DAWN_PROC_H_\n#define INCLUDE_DAWN_DAWN_PROC_H_\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/webgpu.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Sets the static proctable used by libdawn_proc to implement the Dawn entrypoints. Passing NULL\n// for `procs` sets up the null proctable that contains only null function pointers. It is the\n// default value of the proctable. Setting the proctable back to null is good practice when you\n// are done using libdawn_proc since further usage will cause a segfault instead of calling an\n// unexpected function.\nWGPU_EXPORT void dawnProcSetProcs(const DawnProcTable* procs);\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n#endif  // INCLUDE_DAWN_DAWN_PROC_H_\n", "./include/dawn/webgpu_cpp_print.h": "\n#ifndef WEBGPU_CPP_PRINT_H_\n#define WEBGPU_CPP_PRINT_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#include <iomanip>\n#include <ios>\n#include <ostream>\n#include <type_traits>\n\nnamespace wgpu {\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AdapterType value) {\n      switch (value) {\n      case AdapterType::DiscreteGPU:\n        o << \"AdapterType::DiscreteGPU\";\n        break;\n      case AdapterType::IntegratedGPU:\n        o << \"AdapterType::IntegratedGPU\";\n        break;\n      case AdapterType::CPU:\n        o << \"AdapterType::CPU\";\n        break;\n      case AdapterType::Unknown:\n        o << \"AdapterType::Unknown\";\n        break;\n          default:\n            o << \"AdapterType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AdapterType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AddressMode value) {\n      switch (value) {\n      case AddressMode::Repeat:\n        o << \"AddressMode::Repeat\";\n        break;\n      case AddressMode::MirrorRepeat:\n        o << \"AddressMode::MirrorRepeat\";\n        break;\n      case AddressMode::ClampToEdge:\n        o << \"AddressMode::ClampToEdge\";\n        break;\n          default:\n            o << \"AddressMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AddressMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AlphaMode value) {\n      switch (value) {\n      case AlphaMode::Premultiplied:\n        o << \"AlphaMode::Premultiplied\";\n        break;\n      case AlphaMode::Unpremultiplied:\n        o << \"AlphaMode::Unpremultiplied\";\n        break;\n      case AlphaMode::Opaque:\n        o << \"AlphaMode::Opaque\";\n        break;\n          default:\n            o << \"AlphaMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AlphaMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BackendType value) {\n      switch (value) {\n      case BackendType::Undefined:\n        o << \"BackendType::Undefined\";\n        break;\n      case BackendType::Null:\n        o << \"BackendType::Null\";\n        break;\n      case BackendType::WebGPU:\n        o << \"BackendType::WebGPU\";\n        break;\n      case BackendType::D3D11:\n        o << \"BackendType::D3D11\";\n        break;\n      case BackendType::D3D12:\n        o << \"BackendType::D3D12\";\n        break;\n      case BackendType::Metal:\n        o << \"BackendType::Metal\";\n        break;\n      case BackendType::Vulkan:\n        o << \"BackendType::Vulkan\";\n        break;\n      case BackendType::OpenGL:\n        o << \"BackendType::OpenGL\";\n        break;\n      case BackendType::OpenGLES:\n        o << \"BackendType::OpenGLES\";\n        break;\n          default:\n            o << \"BackendType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BackendType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendFactor value) {\n      switch (value) {\n      case BlendFactor::Zero:\n        o << \"BlendFactor::Zero\";\n        break;\n      case BlendFactor::One:\n        o << \"BlendFactor::One\";\n        break;\n      case BlendFactor::Src:\n        o << \"BlendFactor::Src\";\n        break;\n      case BlendFactor::OneMinusSrc:\n        o << \"BlendFactor::OneMinusSrc\";\n        break;\n      case BlendFactor::SrcAlpha:\n        o << \"BlendFactor::SrcAlpha\";\n        break;\n      case BlendFactor::OneMinusSrcAlpha:\n        o << \"BlendFactor::OneMinusSrcAlpha\";\n        break;\n      case BlendFactor::Dst:\n        o << \"BlendFactor::Dst\";\n        break;\n      case BlendFactor::OneMinusDst:\n        o << \"BlendFactor::OneMinusDst\";\n        break;\n      case BlendFactor::DstAlpha:\n        o << \"BlendFactor::DstAlpha\";\n        break;\n      case BlendFactor::OneMinusDstAlpha:\n        o << \"BlendFactor::OneMinusDstAlpha\";\n        break;\n      case BlendFactor::SrcAlphaSaturated:\n        o << \"BlendFactor::SrcAlphaSaturated\";\n        break;\n      case BlendFactor::Constant:\n        o << \"BlendFactor::Constant\";\n        break;\n      case BlendFactor::OneMinusConstant:\n        o << \"BlendFactor::OneMinusConstant\";\n        break;\n      case BlendFactor::Src1:\n        o << \"BlendFactor::Src1\";\n        break;\n      case BlendFactor::OneMinusSrc1:\n        o << \"BlendFactor::OneMinusSrc1\";\n        break;\n      case BlendFactor::Src1Alpha:\n        o << \"BlendFactor::Src1Alpha\";\n        break;\n      case BlendFactor::OneMinusSrc1Alpha:\n        o << \"BlendFactor::OneMinusSrc1Alpha\";\n        break;\n          default:\n            o << \"BlendFactor::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendFactor>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendOperation value) {\n      switch (value) {\n      case BlendOperation::Add:\n        o << \"BlendOperation::Add\";\n        break;\n      case BlendOperation::Subtract:\n        o << \"BlendOperation::Subtract\";\n        break;\n      case BlendOperation::ReverseSubtract:\n        o << \"BlendOperation::ReverseSubtract\";\n        break;\n      case BlendOperation::Min:\n        o << \"BlendOperation::Min\";\n        break;\n      case BlendOperation::Max:\n        o << \"BlendOperation::Max\";\n        break;\n          default:\n            o << \"BlendOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferBindingType value) {\n      switch (value) {\n      case BufferBindingType::Undefined:\n        o << \"BufferBindingType::Undefined\";\n        break;\n      case BufferBindingType::Uniform:\n        o << \"BufferBindingType::Uniform\";\n        break;\n      case BufferBindingType::Storage:\n        o << \"BufferBindingType::Storage\";\n        break;\n      case BufferBindingType::ReadOnlyStorage:\n        o << \"BufferBindingType::ReadOnlyStorage\";\n        break;\n          default:\n            o << \"BufferBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapAsyncStatus value) {\n      switch (value) {\n      case BufferMapAsyncStatus::Success:\n        o << \"BufferMapAsyncStatus::Success\";\n        break;\n      case BufferMapAsyncStatus::ValidationError:\n        o << \"BufferMapAsyncStatus::ValidationError\";\n        break;\n      case BufferMapAsyncStatus::Unknown:\n        o << \"BufferMapAsyncStatus::Unknown\";\n        break;\n      case BufferMapAsyncStatus::DeviceLost:\n        o << \"BufferMapAsyncStatus::DeviceLost\";\n        break;\n      case BufferMapAsyncStatus::DestroyedBeforeCallback:\n        o << \"BufferMapAsyncStatus::DestroyedBeforeCallback\";\n        break;\n      case BufferMapAsyncStatus::UnmappedBeforeCallback:\n        o << \"BufferMapAsyncStatus::UnmappedBeforeCallback\";\n        break;\n      case BufferMapAsyncStatus::MappingAlreadyPending:\n        o << \"BufferMapAsyncStatus::MappingAlreadyPending\";\n        break;\n      case BufferMapAsyncStatus::OffsetOutOfRange:\n        o << \"BufferMapAsyncStatus::OffsetOutOfRange\";\n        break;\n      case BufferMapAsyncStatus::SizeOutOfRange:\n        o << \"BufferMapAsyncStatus::SizeOutOfRange\";\n        break;\n          default:\n            o << \"BufferMapAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapState value) {\n      switch (value) {\n      case BufferMapState::Unmapped:\n        o << \"BufferMapState::Unmapped\";\n        break;\n      case BufferMapState::Pending:\n        o << \"BufferMapState::Pending\";\n        break;\n      case BufferMapState::Mapped:\n        o << \"BufferMapState::Mapped\";\n        break;\n          default:\n            o << \"BufferMapState::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapState>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompareFunction value) {\n      switch (value) {\n      case CompareFunction::Undefined:\n        o << \"CompareFunction::Undefined\";\n        break;\n      case CompareFunction::Never:\n        o << \"CompareFunction::Never\";\n        break;\n      case CompareFunction::Less:\n        o << \"CompareFunction::Less\";\n        break;\n      case CompareFunction::LessEqual:\n        o << \"CompareFunction::LessEqual\";\n        break;\n      case CompareFunction::Greater:\n        o << \"CompareFunction::Greater\";\n        break;\n      case CompareFunction::GreaterEqual:\n        o << \"CompareFunction::GreaterEqual\";\n        break;\n      case CompareFunction::Equal:\n        o << \"CompareFunction::Equal\";\n        break;\n      case CompareFunction::NotEqual:\n        o << \"CompareFunction::NotEqual\";\n        break;\n      case CompareFunction::Always:\n        o << \"CompareFunction::Always\";\n        break;\n          default:\n            o << \"CompareFunction::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompareFunction>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationInfoRequestStatus value) {\n      switch (value) {\n      case CompilationInfoRequestStatus::Success:\n        o << \"CompilationInfoRequestStatus::Success\";\n        break;\n      case CompilationInfoRequestStatus::Error:\n        o << \"CompilationInfoRequestStatus::Error\";\n        break;\n      case CompilationInfoRequestStatus::DeviceLost:\n        o << \"CompilationInfoRequestStatus::DeviceLost\";\n        break;\n      case CompilationInfoRequestStatus::Unknown:\n        o << \"CompilationInfoRequestStatus::Unknown\";\n        break;\n          default:\n            o << \"CompilationInfoRequestStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationInfoRequestStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationMessageType value) {\n      switch (value) {\n      case CompilationMessageType::Error:\n        o << \"CompilationMessageType::Error\";\n        break;\n      case CompilationMessageType::Warning:\n        o << \"CompilationMessageType::Warning\";\n        break;\n      case CompilationMessageType::Info:\n        o << \"CompilationMessageType::Info\";\n        break;\n          default:\n            o << \"CompilationMessageType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationMessageType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ComputePassTimestampLocation value) {\n      switch (value) {\n      case ComputePassTimestampLocation::Beginning:\n        o << \"ComputePassTimestampLocation::Beginning\";\n        break;\n      case ComputePassTimestampLocation::End:\n        o << \"ComputePassTimestampLocation::End\";\n        break;\n          default:\n            o << \"ComputePassTimestampLocation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ComputePassTimestampLocation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CreatePipelineAsyncStatus value) {\n      switch (value) {\n      case CreatePipelineAsyncStatus::Success:\n        o << \"CreatePipelineAsyncStatus::Success\";\n        break;\n      case CreatePipelineAsyncStatus::ValidationError:\n        o << \"CreatePipelineAsyncStatus::ValidationError\";\n        break;\n      case CreatePipelineAsyncStatus::InternalError:\n        o << \"CreatePipelineAsyncStatus::InternalError\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceLost:\n        o << \"CreatePipelineAsyncStatus::DeviceLost\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceDestroyed:\n        o << \"CreatePipelineAsyncStatus::DeviceDestroyed\";\n        break;\n      case CreatePipelineAsyncStatus::Unknown:\n        o << \"CreatePipelineAsyncStatus::Unknown\";\n        break;\n          default:\n            o << \"CreatePipelineAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CreatePipelineAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CullMode value) {\n      switch (value) {\n      case CullMode::None:\n        o << \"CullMode::None\";\n        break;\n      case CullMode::Front:\n        o << \"CullMode::Front\";\n        break;\n      case CullMode::Back:\n        o << \"CullMode::Back\";\n        break;\n          default:\n            o << \"CullMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CullMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, DeviceLostReason value) {\n      switch (value) {\n      case DeviceLostReason::Undefined:\n        o << \"DeviceLostReason::Undefined\";\n        break;\n      case DeviceLostReason::Destroyed:\n        o << \"DeviceLostReason::Destroyed\";\n        break;\n          default:\n            o << \"DeviceLostReason::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<DeviceLostReason>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorFilter value) {\n      switch (value) {\n      case ErrorFilter::Validation:\n        o << \"ErrorFilter::Validation\";\n        break;\n      case ErrorFilter::OutOfMemory:\n        o << \"ErrorFilter::OutOfMemory\";\n        break;\n      case ErrorFilter::Internal:\n        o << \"ErrorFilter::Internal\";\n        break;\n          default:\n            o << \"ErrorFilter::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorFilter>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorType value) {\n      switch (value) {\n      case ErrorType::NoError:\n        o << \"ErrorType::NoError\";\n        break;\n      case ErrorType::Validation:\n        o << \"ErrorType::Validation\";\n        break;\n      case ErrorType::OutOfMemory:\n        o << \"ErrorType::OutOfMemory\";\n        break;\n      case ErrorType::Internal:\n        o << \"ErrorType::Internal\";\n        break;\n      case ErrorType::Unknown:\n        o << \"ErrorType::Unknown\";\n        break;\n      case ErrorType::DeviceLost:\n        o << \"ErrorType::DeviceLost\";\n        break;\n          default:\n            o << \"ErrorType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ExternalTextureRotation value) {\n      switch (value) {\n      case ExternalTextureRotation::Rotate0Degrees:\n        o << \"ExternalTextureRotation::Rotate0Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate90Degrees:\n        o << \"ExternalTextureRotation::Rotate90Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate180Degrees:\n        o << \"ExternalTextureRotation::Rotate180Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate270Degrees:\n        o << \"ExternalTextureRotation::Rotate270Degrees\";\n        break;\n          default:\n            o << \"ExternalTextureRotation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ExternalTextureRotation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FeatureName value) {\n      switch (value) {\n      case FeatureName::Undefined:\n        o << \"FeatureName::Undefined\";\n        break;\n      case FeatureName::DepthClipControl:\n        o << \"FeatureName::DepthClipControl\";\n        break;\n      case FeatureName::Depth32FloatStencil8:\n        o << \"FeatureName::Depth32FloatStencil8\";\n        break;\n      case FeatureName::TimestampQuery:\n        o << \"FeatureName::TimestampQuery\";\n        break;\n      case FeatureName::PipelineStatisticsQuery:\n        o << \"FeatureName::PipelineStatisticsQuery\";\n        break;\n      case FeatureName::TextureCompressionBC:\n        o << \"FeatureName::TextureCompressionBC\";\n        break;\n      case FeatureName::TextureCompressionETC2:\n        o << \"FeatureName::TextureCompressionETC2\";\n        break;\n      case FeatureName::TextureCompressionASTC:\n        o << \"FeatureName::TextureCompressionASTC\";\n        break;\n      case FeatureName::IndirectFirstInstance:\n        o << \"FeatureName::IndirectFirstInstance\";\n        break;\n      case FeatureName::ShaderF16:\n        o << \"FeatureName::ShaderF16\";\n        break;\n      case FeatureName::RG11B10UfloatRenderable:\n        o << \"FeatureName::RG11B10UfloatRenderable\";\n        break;\n      case FeatureName::BGRA8UnormStorage:\n        o << \"FeatureName::BGRA8UnormStorage\";\n        break;\n      case FeatureName::Float32Filterable:\n        o << \"FeatureName::Float32Filterable\";\n        break;\n      case FeatureName::DawnInternalUsages:\n        o << \"FeatureName::DawnInternalUsages\";\n        break;\n      case FeatureName::DawnMultiPlanarFormats:\n        o << \"FeatureName::DawnMultiPlanarFormats\";\n        break;\n      case FeatureName::DawnNative:\n        o << \"FeatureName::DawnNative\";\n        break;\n      case FeatureName::ChromiumExperimentalDp4a:\n        o << \"FeatureName::ChromiumExperimentalDp4a\";\n        break;\n      case FeatureName::TimestampQueryInsidePasses:\n        o << \"FeatureName::TimestampQueryInsidePasses\";\n        break;\n      case FeatureName::ImplicitDeviceSynchronization:\n        o << \"FeatureName::ImplicitDeviceSynchronization\";\n        break;\n      case FeatureName::SurfaceCapabilities:\n        o << \"FeatureName::SurfaceCapabilities\";\n        break;\n      case FeatureName::TransientAttachments:\n        o << \"FeatureName::TransientAttachments\";\n        break;\n      case FeatureName::MSAARenderToSingleSampled:\n        o << \"FeatureName::MSAARenderToSingleSampled\";\n        break;\n      case FeatureName::DualSourceBlending:\n        o << \"FeatureName::DualSourceBlending\";\n        break;\n      case FeatureName::D3D11MultithreadProtected:\n        o << \"FeatureName::D3D11MultithreadProtected\";\n        break;\n      case FeatureName::ANGLETextureSharing:\n        o << \"FeatureName::ANGLETextureSharing\";\n        break;\n      case FeatureName::SharedTextureMemoryVkDedicatedAllocation:\n        o << \"FeatureName::SharedTextureMemoryVkDedicatedAllocation\";\n        break;\n      case FeatureName::SharedTextureMemoryAHardwareBuffer:\n        o << \"FeatureName::SharedTextureMemoryAHardwareBuffer\";\n        break;\n      case FeatureName::SharedTextureMemoryDmaBuf:\n        o << \"FeatureName::SharedTextureMemoryDmaBuf\";\n        break;\n      case FeatureName::SharedTextureMemoryOpaqueFD:\n        o << \"FeatureName::SharedTextureMemoryOpaqueFD\";\n        break;\n      case FeatureName::SharedTextureMemoryZirconHandle:\n        o << \"FeatureName::SharedTextureMemoryZirconHandle\";\n        break;\n      case FeatureName::SharedTextureMemoryDXGISharedHandle:\n        o << \"FeatureName::SharedTextureMemoryDXGISharedHandle\";\n        break;\n      case FeatureName::SharedTextureMemoryD3D11Texture2D:\n        o << \"FeatureName::SharedTextureMemoryD3D11Texture2D\";\n        break;\n      case FeatureName::SharedTextureMemoryIOSurface:\n        o << \"FeatureName::SharedTextureMemoryIOSurface\";\n        break;\n      case FeatureName::SharedTextureMemoryEGLImage:\n        o << \"FeatureName::SharedTextureMemoryEGLImage\";\n        break;\n      case FeatureName::SharedFenceVkSemaphoreOpaqueFD:\n        o << \"FeatureName::SharedFenceVkSemaphoreOpaqueFD\";\n        break;\n      case FeatureName::SharedFenceVkSemaphoreSyncFD:\n        o << \"FeatureName::SharedFenceVkSemaphoreSyncFD\";\n        break;\n      case FeatureName::SharedFenceVkSemaphoreZirconHandle:\n        o << \"FeatureName::SharedFenceVkSemaphoreZirconHandle\";\n        break;\n      case FeatureName::SharedFenceDXGISharedHandle:\n        o << \"FeatureName::SharedFenceDXGISharedHandle\";\n        break;\n      case FeatureName::SharedFenceMTLSharedEvent:\n        o << \"FeatureName::SharedFenceMTLSharedEvent\";\n        break;\n          default:\n            o << \"FeatureName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FeatureName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FilterMode value) {\n      switch (value) {\n      case FilterMode::Nearest:\n        o << \"FilterMode::Nearest\";\n        break;\n      case FilterMode::Linear:\n        o << \"FilterMode::Linear\";\n        break;\n          default:\n            o << \"FilterMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FilterMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FrontFace value) {\n      switch (value) {\n      case FrontFace::CCW:\n        o << \"FrontFace::CCW\";\n        break;\n      case FrontFace::CW:\n        o << \"FrontFace::CW\";\n        break;\n          default:\n            o << \"FrontFace::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FrontFace>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, IndexFormat value) {\n      switch (value) {\n      case IndexFormat::Undefined:\n        o << \"IndexFormat::Undefined\";\n        break;\n      case IndexFormat::Uint16:\n        o << \"IndexFormat::Uint16\";\n        break;\n      case IndexFormat::Uint32:\n        o << \"IndexFormat::Uint32\";\n        break;\n          default:\n            o << \"IndexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<IndexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoadOp value) {\n      switch (value) {\n      case LoadOp::Undefined:\n        o << \"LoadOp::Undefined\";\n        break;\n      case LoadOp::Clear:\n        o << \"LoadOp::Clear\";\n        break;\n      case LoadOp::Load:\n        o << \"LoadOp::Load\";\n        break;\n          default:\n            o << \"LoadOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoadOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoggingType value) {\n      switch (value) {\n      case LoggingType::Verbose:\n        o << \"LoggingType::Verbose\";\n        break;\n      case LoggingType::Info:\n        o << \"LoggingType::Info\";\n        break;\n      case LoggingType::Warning:\n        o << \"LoggingType::Warning\";\n        break;\n      case LoggingType::Error:\n        o << \"LoggingType::Error\";\n        break;\n          default:\n            o << \"LoggingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoggingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MipmapFilterMode value) {\n      switch (value) {\n      case MipmapFilterMode::Nearest:\n        o << \"MipmapFilterMode::Nearest\";\n        break;\n      case MipmapFilterMode::Linear:\n        o << \"MipmapFilterMode::Linear\";\n        break;\n          default:\n            o << \"MipmapFilterMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MipmapFilterMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PipelineStatisticName value) {\n      switch (value) {\n      case PipelineStatisticName::VertexShaderInvocations:\n        o << \"PipelineStatisticName::VertexShaderInvocations\";\n        break;\n      case PipelineStatisticName::ClipperInvocations:\n        o << \"PipelineStatisticName::ClipperInvocations\";\n        break;\n      case PipelineStatisticName::ClipperPrimitivesOut:\n        o << \"PipelineStatisticName::ClipperPrimitivesOut\";\n        break;\n      case PipelineStatisticName::FragmentShaderInvocations:\n        o << \"PipelineStatisticName::FragmentShaderInvocations\";\n        break;\n      case PipelineStatisticName::ComputeShaderInvocations:\n        o << \"PipelineStatisticName::ComputeShaderInvocations\";\n        break;\n          default:\n            o << \"PipelineStatisticName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PipelineStatisticName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PowerPreference value) {\n      switch (value) {\n      case PowerPreference::Undefined:\n        o << \"PowerPreference::Undefined\";\n        break;\n      case PowerPreference::LowPower:\n        o << \"PowerPreference::LowPower\";\n        break;\n      case PowerPreference::HighPerformance:\n        o << \"PowerPreference::HighPerformance\";\n        break;\n          default:\n            o << \"PowerPreference::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PowerPreference>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PresentMode value) {\n      switch (value) {\n      case PresentMode::Immediate:\n        o << \"PresentMode::Immediate\";\n        break;\n      case PresentMode::Mailbox:\n        o << \"PresentMode::Mailbox\";\n        break;\n      case PresentMode::Fifo:\n        o << \"PresentMode::Fifo\";\n        break;\n          default:\n            o << \"PresentMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PresentMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PrimitiveTopology value) {\n      switch (value) {\n      case PrimitiveTopology::PointList:\n        o << \"PrimitiveTopology::PointList\";\n        break;\n      case PrimitiveTopology::LineList:\n        o << \"PrimitiveTopology::LineList\";\n        break;\n      case PrimitiveTopology::LineStrip:\n        o << \"PrimitiveTopology::LineStrip\";\n        break;\n      case PrimitiveTopology::TriangleList:\n        o << \"PrimitiveTopology::TriangleList\";\n        break;\n      case PrimitiveTopology::TriangleStrip:\n        o << \"PrimitiveTopology::TriangleStrip\";\n        break;\n          default:\n            o << \"PrimitiveTopology::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PrimitiveTopology>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueryType value) {\n      switch (value) {\n      case QueryType::Occlusion:\n        o << \"QueryType::Occlusion\";\n        break;\n      case QueryType::PipelineStatistics:\n        o << \"QueryType::PipelineStatistics\";\n        break;\n      case QueryType::Timestamp:\n        o << \"QueryType::Timestamp\";\n        break;\n          default:\n            o << \"QueryType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueryType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueueWorkDoneStatus value) {\n      switch (value) {\n      case QueueWorkDoneStatus::Success:\n        o << \"QueueWorkDoneStatus::Success\";\n        break;\n      case QueueWorkDoneStatus::Error:\n        o << \"QueueWorkDoneStatus::Error\";\n        break;\n      case QueueWorkDoneStatus::Unknown:\n        o << \"QueueWorkDoneStatus::Unknown\";\n        break;\n      case QueueWorkDoneStatus::DeviceLost:\n        o << \"QueueWorkDoneStatus::DeviceLost\";\n        break;\n          default:\n            o << \"QueueWorkDoneStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueueWorkDoneStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RenderPassTimestampLocation value) {\n      switch (value) {\n      case RenderPassTimestampLocation::Beginning:\n        o << \"RenderPassTimestampLocation::Beginning\";\n        break;\n      case RenderPassTimestampLocation::End:\n        o << \"RenderPassTimestampLocation::End\";\n        break;\n          default:\n            o << \"RenderPassTimestampLocation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RenderPassTimestampLocation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestAdapterStatus value) {\n      switch (value) {\n      case RequestAdapterStatus::Success:\n        o << \"RequestAdapterStatus::Success\";\n        break;\n      case RequestAdapterStatus::Unavailable:\n        o << \"RequestAdapterStatus::Unavailable\";\n        break;\n      case RequestAdapterStatus::Error:\n        o << \"RequestAdapterStatus::Error\";\n        break;\n      case RequestAdapterStatus::Unknown:\n        o << \"RequestAdapterStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestAdapterStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestAdapterStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestDeviceStatus value) {\n      switch (value) {\n      case RequestDeviceStatus::Success:\n        o << \"RequestDeviceStatus::Success\";\n        break;\n      case RequestDeviceStatus::Error:\n        o << \"RequestDeviceStatus::Error\";\n        break;\n      case RequestDeviceStatus::Unknown:\n        o << \"RequestDeviceStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestDeviceStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestDeviceStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SType value) {\n      switch (value) {\n      case SType::Invalid:\n        o << \"SType::Invalid\";\n        break;\n      case SType::SurfaceDescriptorFromMetalLayer:\n        o << \"SType::SurfaceDescriptorFromMetalLayer\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsHWND:\n        o << \"SType::SurfaceDescriptorFromWindowsHWND\";\n        break;\n      case SType::SurfaceDescriptorFromXlibWindow:\n        o << \"SType::SurfaceDescriptorFromXlibWindow\";\n        break;\n      case SType::SurfaceDescriptorFromCanvasHTMLSelector:\n        o << \"SType::SurfaceDescriptorFromCanvasHTMLSelector\";\n        break;\n      case SType::ShaderModuleSPIRVDescriptor:\n        o << \"SType::ShaderModuleSPIRVDescriptor\";\n        break;\n      case SType::ShaderModuleWGSLDescriptor:\n        o << \"SType::ShaderModuleWGSLDescriptor\";\n        break;\n      case SType::PrimitiveDepthClipControl:\n        o << \"SType::PrimitiveDepthClipControl\";\n        break;\n      case SType::SurfaceDescriptorFromWaylandSurface:\n        o << \"SType::SurfaceDescriptorFromWaylandSurface\";\n        break;\n      case SType::SurfaceDescriptorFromAndroidNativeWindow:\n        o << \"SType::SurfaceDescriptorFromAndroidNativeWindow\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsCoreWindow:\n        o << \"SType::SurfaceDescriptorFromWindowsCoreWindow\";\n        break;\n      case SType::ExternalTextureBindingEntry:\n        o << \"SType::ExternalTextureBindingEntry\";\n        break;\n      case SType::ExternalTextureBindingLayout:\n        o << \"SType::ExternalTextureBindingLayout\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n        o << \"SType::SurfaceDescriptorFromWindowsSwapChainPanel\";\n        break;\n      case SType::RenderPassDescriptorMaxDrawCount:\n        o << \"SType::RenderPassDescriptorMaxDrawCount\";\n        break;\n      case SType::DawnTextureInternalUsageDescriptor:\n        o << \"SType::DawnTextureInternalUsageDescriptor\";\n        break;\n      case SType::DawnEncoderInternalUsageDescriptor:\n        o << \"SType::DawnEncoderInternalUsageDescriptor\";\n        break;\n      case SType::DawnInstanceDescriptor:\n        o << \"SType::DawnInstanceDescriptor\";\n        break;\n      case SType::DawnCacheDeviceDescriptor:\n        o << \"SType::DawnCacheDeviceDescriptor\";\n        break;\n      case SType::DawnAdapterPropertiesPowerPreference:\n        o << \"SType::DawnAdapterPropertiesPowerPreference\";\n        break;\n      case SType::DawnBufferDescriptorErrorInfoFromWireClient:\n        o << \"SType::DawnBufferDescriptorErrorInfoFromWireClient\";\n        break;\n      case SType::DawnTogglesDescriptor:\n        o << \"SType::DawnTogglesDescriptor\";\n        break;\n      case SType::DawnShaderModuleSPIRVOptionsDescriptor:\n        o << \"SType::DawnShaderModuleSPIRVOptionsDescriptor\";\n        break;\n      case SType::RequestAdapterOptionsLUID:\n        o << \"SType::RequestAdapterOptionsLUID\";\n        break;\n      case SType::RequestAdapterOptionsGetGLProc:\n        o << \"SType::RequestAdapterOptionsGetGLProc\";\n        break;\n      case SType::DawnMultisampleStateRenderToSingleSampled:\n        o << \"SType::DawnMultisampleStateRenderToSingleSampled\";\n        break;\n      case SType::DawnRenderPassColorAttachmentRenderToSingleSampled:\n        o << \"SType::DawnRenderPassColorAttachmentRenderToSingleSampled\";\n        break;\n      case SType::SharedTextureMemoryVkImageDescriptor:\n        o << \"SType::SharedTextureMemoryVkImageDescriptor\";\n        break;\n      case SType::SharedTextureMemoryVkDedicatedAllocationDescriptor:\n        o << \"SType::SharedTextureMemoryVkDedicatedAllocationDescriptor\";\n        break;\n      case SType::SharedTextureMemoryAHardwareBufferDescriptor:\n        o << \"SType::SharedTextureMemoryAHardwareBufferDescriptor\";\n        break;\n      case SType::SharedTextureMemoryDmaBufDescriptor:\n        o << \"SType::SharedTextureMemoryDmaBufDescriptor\";\n        break;\n      case SType::SharedTextureMemoryOpaqueFDDescriptor:\n        o << \"SType::SharedTextureMemoryOpaqueFDDescriptor\";\n        break;\n      case SType::SharedTextureMemoryZirconHandleDescriptor:\n        o << \"SType::SharedTextureMemoryZirconHandleDescriptor\";\n        break;\n      case SType::SharedTextureMemoryDXGISharedHandleDescriptor:\n        o << \"SType::SharedTextureMemoryDXGISharedHandleDescriptor\";\n        break;\n      case SType::SharedTextureMemoryD3D11Texture2DDescriptor:\n        o << \"SType::SharedTextureMemoryD3D11Texture2DDescriptor\";\n        break;\n      case SType::SharedTextureMemoryIOSurfaceDescriptor:\n        o << \"SType::SharedTextureMemoryIOSurfaceDescriptor\";\n        break;\n      case SType::SharedTextureMemoryEGLImageDescriptor:\n        o << \"SType::SharedTextureMemoryEGLImageDescriptor\";\n        break;\n      case SType::SharedTextureMemoryInitializedBeginState:\n        o << \"SType::SharedTextureMemoryInitializedBeginState\";\n        break;\n      case SType::SharedTextureMemoryInitializedEndState:\n        o << \"SType::SharedTextureMemoryInitializedEndState\";\n        break;\n      case SType::SharedTextureMemoryVkImageLayoutBeginState:\n        o << \"SType::SharedTextureMemoryVkImageLayoutBeginState\";\n        break;\n      case SType::SharedTextureMemoryVkImageLayoutEndState:\n        o << \"SType::SharedTextureMemoryVkImageLayoutEndState\";\n        break;\n      case SType::SharedFenceVkSemaphoreOpaqueFDDescriptor:\n        o << \"SType::SharedFenceVkSemaphoreOpaqueFDDescriptor\";\n        break;\n      case SType::SharedFenceVkSemaphoreOpaqueFDExportInfo:\n        o << \"SType::SharedFenceVkSemaphoreOpaqueFDExportInfo\";\n        break;\n      case SType::SharedFenceVkSemaphoreSyncFDDescriptor:\n        o << \"SType::SharedFenceVkSemaphoreSyncFDDescriptor\";\n        break;\n      case SType::SharedFenceVkSemaphoreSyncFDExportInfo:\n        o << \"SType::SharedFenceVkSemaphoreSyncFDExportInfo\";\n        break;\n      case SType::SharedFenceVkSemaphoreZirconHandleDescriptor:\n        o << \"SType::SharedFenceVkSemaphoreZirconHandleDescriptor\";\n        break;\n      case SType::SharedFenceVkSemaphoreZirconHandleExportInfo:\n        o << \"SType::SharedFenceVkSemaphoreZirconHandleExportInfo\";\n        break;\n      case SType::SharedFenceDXGISharedHandleDescriptor:\n        o << \"SType::SharedFenceDXGISharedHandleDescriptor\";\n        break;\n      case SType::SharedFenceDXGISharedHandleExportInfo:\n        o << \"SType::SharedFenceDXGISharedHandleExportInfo\";\n        break;\n      case SType::SharedFenceMTLSharedEventDescriptor:\n        o << \"SType::SharedFenceMTLSharedEventDescriptor\";\n        break;\n      case SType::SharedFenceMTLSharedEventExportInfo:\n        o << \"SType::SharedFenceMTLSharedEventExportInfo\";\n        break;\n          default:\n            o << \"SType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SamplerBindingType value) {\n      switch (value) {\n      case SamplerBindingType::Undefined:\n        o << \"SamplerBindingType::Undefined\";\n        break;\n      case SamplerBindingType::Filtering:\n        o << \"SamplerBindingType::Filtering\";\n        break;\n      case SamplerBindingType::NonFiltering:\n        o << \"SamplerBindingType::NonFiltering\";\n        break;\n      case SamplerBindingType::Comparison:\n        o << \"SamplerBindingType::Comparison\";\n        break;\n          default:\n            o << \"SamplerBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SamplerBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SharedFenceType value) {\n      switch (value) {\n      case SharedFenceType::Undefined:\n        o << \"SharedFenceType::Undefined\";\n        break;\n      case SharedFenceType::VkSemaphoreOpaqueFD:\n        o << \"SharedFenceType::VkSemaphoreOpaqueFD\";\n        break;\n      case SharedFenceType::VkSemaphoreSyncFD:\n        o << \"SharedFenceType::VkSemaphoreSyncFD\";\n        break;\n      case SharedFenceType::VkSemaphoreZirconHandle:\n        o << \"SharedFenceType::VkSemaphoreZirconHandle\";\n        break;\n      case SharedFenceType::DXGISharedHandle:\n        o << \"SharedFenceType::DXGISharedHandle\";\n        break;\n      case SharedFenceType::MTLSharedEvent:\n        o << \"SharedFenceType::MTLSharedEvent\";\n        break;\n          default:\n            o << \"SharedFenceType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SharedFenceType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StencilOperation value) {\n      switch (value) {\n      case StencilOperation::Keep:\n        o << \"StencilOperation::Keep\";\n        break;\n      case StencilOperation::Zero:\n        o << \"StencilOperation::Zero\";\n        break;\n      case StencilOperation::Replace:\n        o << \"StencilOperation::Replace\";\n        break;\n      case StencilOperation::Invert:\n        o << \"StencilOperation::Invert\";\n        break;\n      case StencilOperation::IncrementClamp:\n        o << \"StencilOperation::IncrementClamp\";\n        break;\n      case StencilOperation::DecrementClamp:\n        o << \"StencilOperation::DecrementClamp\";\n        break;\n      case StencilOperation::IncrementWrap:\n        o << \"StencilOperation::IncrementWrap\";\n        break;\n      case StencilOperation::DecrementWrap:\n        o << \"StencilOperation::DecrementWrap\";\n        break;\n          default:\n            o << \"StencilOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StencilOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StorageTextureAccess value) {\n      switch (value) {\n      case StorageTextureAccess::Undefined:\n        o << \"StorageTextureAccess::Undefined\";\n        break;\n      case StorageTextureAccess::WriteOnly:\n        o << \"StorageTextureAccess::WriteOnly\";\n        break;\n          default:\n            o << \"StorageTextureAccess::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StorageTextureAccess>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StoreOp value) {\n      switch (value) {\n      case StoreOp::Undefined:\n        o << \"StoreOp::Undefined\";\n        break;\n      case StoreOp::Store:\n        o << \"StoreOp::Store\";\n        break;\n      case StoreOp::Discard:\n        o << \"StoreOp::Discard\";\n        break;\n          default:\n            o << \"StoreOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StoreOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureAspect value) {\n      switch (value) {\n      case TextureAspect::All:\n        o << \"TextureAspect::All\";\n        break;\n      case TextureAspect::StencilOnly:\n        o << \"TextureAspect::StencilOnly\";\n        break;\n      case TextureAspect::DepthOnly:\n        o << \"TextureAspect::DepthOnly\";\n        break;\n      case TextureAspect::Plane0Only:\n        o << \"TextureAspect::Plane0Only\";\n        break;\n      case TextureAspect::Plane1Only:\n        o << \"TextureAspect::Plane1Only\";\n        break;\n          default:\n            o << \"TextureAspect::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureAspect>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureDimension value) {\n      switch (value) {\n      case TextureDimension::e1D:\n        o << \"TextureDimension::e1D\";\n        break;\n      case TextureDimension::e2D:\n        o << \"TextureDimension::e2D\";\n        break;\n      case TextureDimension::e3D:\n        o << \"TextureDimension::e3D\";\n        break;\n          default:\n            o << \"TextureDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureFormat value) {\n      switch (value) {\n      case TextureFormat::Undefined:\n        o << \"TextureFormat::Undefined\";\n        break;\n      case TextureFormat::R8Unorm:\n        o << \"TextureFormat::R8Unorm\";\n        break;\n      case TextureFormat::R8Snorm:\n        o << \"TextureFormat::R8Snorm\";\n        break;\n      case TextureFormat::R8Uint:\n        o << \"TextureFormat::R8Uint\";\n        break;\n      case TextureFormat::R8Sint:\n        o << \"TextureFormat::R8Sint\";\n        break;\n      case TextureFormat::R16Uint:\n        o << \"TextureFormat::R16Uint\";\n        break;\n      case TextureFormat::R16Sint:\n        o << \"TextureFormat::R16Sint\";\n        break;\n      case TextureFormat::R16Float:\n        o << \"TextureFormat::R16Float\";\n        break;\n      case TextureFormat::RG8Unorm:\n        o << \"TextureFormat::RG8Unorm\";\n        break;\n      case TextureFormat::RG8Snorm:\n        o << \"TextureFormat::RG8Snorm\";\n        break;\n      case TextureFormat::RG8Uint:\n        o << \"TextureFormat::RG8Uint\";\n        break;\n      case TextureFormat::RG8Sint:\n        o << \"TextureFormat::RG8Sint\";\n        break;\n      case TextureFormat::R32Float:\n        o << \"TextureFormat::R32Float\";\n        break;\n      case TextureFormat::R32Uint:\n        o << \"TextureFormat::R32Uint\";\n        break;\n      case TextureFormat::R32Sint:\n        o << \"TextureFormat::R32Sint\";\n        break;\n      case TextureFormat::RG16Uint:\n        o << \"TextureFormat::RG16Uint\";\n        break;\n      case TextureFormat::RG16Sint:\n        o << \"TextureFormat::RG16Sint\";\n        break;\n      case TextureFormat::RG16Float:\n        o << \"TextureFormat::RG16Float\";\n        break;\n      case TextureFormat::RGBA8Unorm:\n        o << \"TextureFormat::RGBA8Unorm\";\n        break;\n      case TextureFormat::RGBA8UnormSrgb:\n        o << \"TextureFormat::RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::RGBA8Snorm:\n        o << \"TextureFormat::RGBA8Snorm\";\n        break;\n      case TextureFormat::RGBA8Uint:\n        o << \"TextureFormat::RGBA8Uint\";\n        break;\n      case TextureFormat::RGBA8Sint:\n        o << \"TextureFormat::RGBA8Sint\";\n        break;\n      case TextureFormat::BGRA8Unorm:\n        o << \"TextureFormat::BGRA8Unorm\";\n        break;\n      case TextureFormat::BGRA8UnormSrgb:\n        o << \"TextureFormat::BGRA8UnormSrgb\";\n        break;\n      case TextureFormat::RGB10A2Unorm:\n        o << \"TextureFormat::RGB10A2Unorm\";\n        break;\n      case TextureFormat::RG11B10Ufloat:\n        o << \"TextureFormat::RG11B10Ufloat\";\n        break;\n      case TextureFormat::RGB9E5Ufloat:\n        o << \"TextureFormat::RGB9E5Ufloat\";\n        break;\n      case TextureFormat::RG32Float:\n        o << \"TextureFormat::RG32Float\";\n        break;\n      case TextureFormat::RG32Uint:\n        o << \"TextureFormat::RG32Uint\";\n        break;\n      case TextureFormat::RG32Sint:\n        o << \"TextureFormat::RG32Sint\";\n        break;\n      case TextureFormat::RGBA16Uint:\n        o << \"TextureFormat::RGBA16Uint\";\n        break;\n      case TextureFormat::RGBA16Sint:\n        o << \"TextureFormat::RGBA16Sint\";\n        break;\n      case TextureFormat::RGBA16Float:\n        o << \"TextureFormat::RGBA16Float\";\n        break;\n      case TextureFormat::RGBA32Float:\n        o << \"TextureFormat::RGBA32Float\";\n        break;\n      case TextureFormat::RGBA32Uint:\n        o << \"TextureFormat::RGBA32Uint\";\n        break;\n      case TextureFormat::RGBA32Sint:\n        o << \"TextureFormat::RGBA32Sint\";\n        break;\n      case TextureFormat::Stencil8:\n        o << \"TextureFormat::Stencil8\";\n        break;\n      case TextureFormat::Depth16Unorm:\n        o << \"TextureFormat::Depth16Unorm\";\n        break;\n      case TextureFormat::Depth24Plus:\n        o << \"TextureFormat::Depth24Plus\";\n        break;\n      case TextureFormat::Depth24PlusStencil8:\n        o << \"TextureFormat::Depth24PlusStencil8\";\n        break;\n      case TextureFormat::Depth32Float:\n        o << \"TextureFormat::Depth32Float\";\n        break;\n      case TextureFormat::Depth32FloatStencil8:\n        o << \"TextureFormat::Depth32FloatStencil8\";\n        break;\n      case TextureFormat::BC1RGBAUnorm:\n        o << \"TextureFormat::BC1RGBAUnorm\";\n        break;\n      case TextureFormat::BC1RGBAUnormSrgb:\n        o << \"TextureFormat::BC1RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC2RGBAUnorm:\n        o << \"TextureFormat::BC2RGBAUnorm\";\n        break;\n      case TextureFormat::BC2RGBAUnormSrgb:\n        o << \"TextureFormat::BC2RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC3RGBAUnorm:\n        o << \"TextureFormat::BC3RGBAUnorm\";\n        break;\n      case TextureFormat::BC3RGBAUnormSrgb:\n        o << \"TextureFormat::BC3RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC4RUnorm:\n        o << \"TextureFormat::BC4RUnorm\";\n        break;\n      case TextureFormat::BC4RSnorm:\n        o << \"TextureFormat::BC4RSnorm\";\n        break;\n      case TextureFormat::BC5RGUnorm:\n        o << \"TextureFormat::BC5RGUnorm\";\n        break;\n      case TextureFormat::BC5RGSnorm:\n        o << \"TextureFormat::BC5RGSnorm\";\n        break;\n      case TextureFormat::BC6HRGBUfloat:\n        o << \"TextureFormat::BC6HRGBUfloat\";\n        break;\n      case TextureFormat::BC6HRGBFloat:\n        o << \"TextureFormat::BC6HRGBFloat\";\n        break;\n      case TextureFormat::BC7RGBAUnorm:\n        o << \"TextureFormat::BC7RGBAUnorm\";\n        break;\n      case TextureFormat::BC7RGBAUnormSrgb:\n        o << \"TextureFormat::BC7RGBAUnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8Unorm:\n        o << \"TextureFormat::ETC2RGB8Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8A1Unorm:\n        o << \"TextureFormat::ETC2RGB8A1Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8A1UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8A1UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGBA8Unorm:\n        o << \"TextureFormat::ETC2RGBA8Unorm\";\n        break;\n      case TextureFormat::ETC2RGBA8UnormSrgb:\n        o << \"TextureFormat::ETC2RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::EACR11Unorm:\n        o << \"TextureFormat::EACR11Unorm\";\n        break;\n      case TextureFormat::EACR11Snorm:\n        o << \"TextureFormat::EACR11Snorm\";\n        break;\n      case TextureFormat::EACRG11Unorm:\n        o << \"TextureFormat::EACRG11Unorm\";\n        break;\n      case TextureFormat::EACRG11Snorm:\n        o << \"TextureFormat::EACRG11Snorm\";\n        break;\n      case TextureFormat::ASTC4x4Unorm:\n        o << \"TextureFormat::ASTC4x4Unorm\";\n        break;\n      case TextureFormat::ASTC4x4UnormSrgb:\n        o << \"TextureFormat::ASTC4x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x4Unorm:\n        o << \"TextureFormat::ASTC5x4Unorm\";\n        break;\n      case TextureFormat::ASTC5x4UnormSrgb:\n        o << \"TextureFormat::ASTC5x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x5Unorm:\n        o << \"TextureFormat::ASTC5x5Unorm\";\n        break;\n      case TextureFormat::ASTC5x5UnormSrgb:\n        o << \"TextureFormat::ASTC5x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x5Unorm:\n        o << \"TextureFormat::ASTC6x5Unorm\";\n        break;\n      case TextureFormat::ASTC6x5UnormSrgb:\n        o << \"TextureFormat::ASTC6x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x6Unorm:\n        o << \"TextureFormat::ASTC6x6Unorm\";\n        break;\n      case TextureFormat::ASTC6x6UnormSrgb:\n        o << \"TextureFormat::ASTC6x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x5Unorm:\n        o << \"TextureFormat::ASTC8x5Unorm\";\n        break;\n      case TextureFormat::ASTC8x5UnormSrgb:\n        o << \"TextureFormat::ASTC8x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x6Unorm:\n        o << \"TextureFormat::ASTC8x6Unorm\";\n        break;\n      case TextureFormat::ASTC8x6UnormSrgb:\n        o << \"TextureFormat::ASTC8x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x8Unorm:\n        o << \"TextureFormat::ASTC8x8Unorm\";\n        break;\n      case TextureFormat::ASTC8x8UnormSrgb:\n        o << \"TextureFormat::ASTC8x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x5Unorm:\n        o << \"TextureFormat::ASTC10x5Unorm\";\n        break;\n      case TextureFormat::ASTC10x5UnormSrgb:\n        o << \"TextureFormat::ASTC10x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x6Unorm:\n        o << \"TextureFormat::ASTC10x6Unorm\";\n        break;\n      case TextureFormat::ASTC10x6UnormSrgb:\n        o << \"TextureFormat::ASTC10x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x8Unorm:\n        o << \"TextureFormat::ASTC10x8Unorm\";\n        break;\n      case TextureFormat::ASTC10x8UnormSrgb:\n        o << \"TextureFormat::ASTC10x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x10Unorm:\n        o << \"TextureFormat::ASTC10x10Unorm\";\n        break;\n      case TextureFormat::ASTC10x10UnormSrgb:\n        o << \"TextureFormat::ASTC10x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x10Unorm:\n        o << \"TextureFormat::ASTC12x10Unorm\";\n        break;\n      case TextureFormat::ASTC12x10UnormSrgb:\n        o << \"TextureFormat::ASTC12x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x12Unorm:\n        o << \"TextureFormat::ASTC12x12Unorm\";\n        break;\n      case TextureFormat::ASTC12x12UnormSrgb:\n        o << \"TextureFormat::ASTC12x12UnormSrgb\";\n        break;\n      case TextureFormat::R8BG8Biplanar420Unorm:\n        o << \"TextureFormat::R8BG8Biplanar420Unorm\";\n        break;\n          default:\n            o << \"TextureFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureSampleType value) {\n      switch (value) {\n      case TextureSampleType::Undefined:\n        o << \"TextureSampleType::Undefined\";\n        break;\n      case TextureSampleType::Float:\n        o << \"TextureSampleType::Float\";\n        break;\n      case TextureSampleType::UnfilterableFloat:\n        o << \"TextureSampleType::UnfilterableFloat\";\n        break;\n      case TextureSampleType::Depth:\n        o << \"TextureSampleType::Depth\";\n        break;\n      case TextureSampleType::Sint:\n        o << \"TextureSampleType::Sint\";\n        break;\n      case TextureSampleType::Uint:\n        o << \"TextureSampleType::Uint\";\n        break;\n          default:\n            o << \"TextureSampleType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureSampleType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureViewDimension value) {\n      switch (value) {\n      case TextureViewDimension::Undefined:\n        o << \"TextureViewDimension::Undefined\";\n        break;\n      case TextureViewDimension::e1D:\n        o << \"TextureViewDimension::e1D\";\n        break;\n      case TextureViewDimension::e2D:\n        o << \"TextureViewDimension::e2D\";\n        break;\n      case TextureViewDimension::e2DArray:\n        o << \"TextureViewDimension::e2DArray\";\n        break;\n      case TextureViewDimension::Cube:\n        o << \"TextureViewDimension::Cube\";\n        break;\n      case TextureViewDimension::CubeArray:\n        o << \"TextureViewDimension::CubeArray\";\n        break;\n      case TextureViewDimension::e3D:\n        o << \"TextureViewDimension::e3D\";\n        break;\n          default:\n            o << \"TextureViewDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureViewDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexFormat value) {\n      switch (value) {\n      case VertexFormat::Undefined:\n        o << \"VertexFormat::Undefined\";\n        break;\n      case VertexFormat::Uint8x2:\n        o << \"VertexFormat::Uint8x2\";\n        break;\n      case VertexFormat::Uint8x4:\n        o << \"VertexFormat::Uint8x4\";\n        break;\n      case VertexFormat::Sint8x2:\n        o << \"VertexFormat::Sint8x2\";\n        break;\n      case VertexFormat::Sint8x4:\n        o << \"VertexFormat::Sint8x4\";\n        break;\n      case VertexFormat::Unorm8x2:\n        o << \"VertexFormat::Unorm8x2\";\n        break;\n      case VertexFormat::Unorm8x4:\n        o << \"VertexFormat::Unorm8x4\";\n        break;\n      case VertexFormat::Snorm8x2:\n        o << \"VertexFormat::Snorm8x2\";\n        break;\n      case VertexFormat::Snorm8x4:\n        o << \"VertexFormat::Snorm8x4\";\n        break;\n      case VertexFormat::Uint16x2:\n        o << \"VertexFormat::Uint16x2\";\n        break;\n      case VertexFormat::Uint16x4:\n        o << \"VertexFormat::Uint16x4\";\n        break;\n      case VertexFormat::Sint16x2:\n        o << \"VertexFormat::Sint16x2\";\n        break;\n      case VertexFormat::Sint16x4:\n        o << \"VertexFormat::Sint16x4\";\n        break;\n      case VertexFormat::Unorm16x2:\n        o << \"VertexFormat::Unorm16x2\";\n        break;\n      case VertexFormat::Unorm16x4:\n        o << \"VertexFormat::Unorm16x4\";\n        break;\n      case VertexFormat::Snorm16x2:\n        o << \"VertexFormat::Snorm16x2\";\n        break;\n      case VertexFormat::Snorm16x4:\n        o << \"VertexFormat::Snorm16x4\";\n        break;\n      case VertexFormat::Float16x2:\n        o << \"VertexFormat::Float16x2\";\n        break;\n      case VertexFormat::Float16x4:\n        o << \"VertexFormat::Float16x4\";\n        break;\n      case VertexFormat::Float32:\n        o << \"VertexFormat::Float32\";\n        break;\n      case VertexFormat::Float32x2:\n        o << \"VertexFormat::Float32x2\";\n        break;\n      case VertexFormat::Float32x3:\n        o << \"VertexFormat::Float32x3\";\n        break;\n      case VertexFormat::Float32x4:\n        o << \"VertexFormat::Float32x4\";\n        break;\n      case VertexFormat::Uint32:\n        o << \"VertexFormat::Uint32\";\n        break;\n      case VertexFormat::Uint32x2:\n        o << \"VertexFormat::Uint32x2\";\n        break;\n      case VertexFormat::Uint32x3:\n        o << \"VertexFormat::Uint32x3\";\n        break;\n      case VertexFormat::Uint32x4:\n        o << \"VertexFormat::Uint32x4\";\n        break;\n      case VertexFormat::Sint32:\n        o << \"VertexFormat::Sint32\";\n        break;\n      case VertexFormat::Sint32x2:\n        o << \"VertexFormat::Sint32x2\";\n        break;\n      case VertexFormat::Sint32x3:\n        o << \"VertexFormat::Sint32x3\";\n        break;\n      case VertexFormat::Sint32x4:\n        o << \"VertexFormat::Sint32x4\";\n        break;\n          default:\n            o << \"VertexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexStepMode value) {\n      switch (value) {\n      case VertexStepMode::Vertex:\n        o << \"VertexStepMode::Vertex\";\n        break;\n      case VertexStepMode::Instance:\n        o << \"VertexStepMode::Instance\";\n        break;\n      case VertexStepMode::VertexBufferNotUsed:\n        o << \"VertexStepMode::VertexBufferNotUsed\";\n        break;\n          default:\n            o << \"VertexStepMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexStepMode>::type>(value);\n      }\n      return o;\n  }\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferUsage value) {\n    o << \"BufferUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & BufferUsage::MapRead) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapRead\";\n    value &= ~BufferUsage::MapRead;\n  }\n  if (value & BufferUsage::MapWrite) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapWrite\";\n    value &= ~BufferUsage::MapWrite;\n  }\n  if (value & BufferUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~BufferUsage::CopySrc;\n  }\n  if (value & BufferUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~BufferUsage::CopyDst;\n  }\n  if (value & BufferUsage::Index) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Index\";\n    value &= ~BufferUsage::Index;\n  }\n  if (value & BufferUsage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~BufferUsage::Vertex;\n  }\n  if (value & BufferUsage::Uniform) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Uniform\";\n    value &= ~BufferUsage::Uniform;\n  }\n  if (value & BufferUsage::Storage) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Storage\";\n    value &= ~BufferUsage::Storage;\n  }\n  if (value & BufferUsage::Indirect) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Indirect\";\n    value &= ~BufferUsage::Indirect;\n  }\n  if (value & BufferUsage::QueryResolve) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"QueryResolve\";\n    value &= ~BufferUsage::QueryResolve;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ColorWriteMask value) {\n    o << \"ColorWriteMask::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ColorWriteMask::Red) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Red\";\n    value &= ~ColorWriteMask::Red;\n  }\n  if (value & ColorWriteMask::Green) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Green\";\n    value &= ~ColorWriteMask::Green;\n  }\n  if (value & ColorWriteMask::Blue) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Blue\";\n    value &= ~ColorWriteMask::Blue;\n  }\n  if (value & ColorWriteMask::Alpha) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Alpha\";\n    value &= ~ColorWriteMask::Alpha;\n  }\n  if (value & ColorWriteMask::All) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"All\";\n    value &= ~ColorWriteMask::All;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ColorWriteMask>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MapMode value) {\n    o << \"MapMode::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & MapMode::Read) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Read\";\n    value &= ~MapMode::Read;\n  }\n  if (value & MapMode::Write) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Write\";\n    value &= ~MapMode::Write;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MapMode>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ShaderStage value) {\n    o << \"ShaderStage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ShaderStage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~ShaderStage::Vertex;\n  }\n  if (value & ShaderStage::Fragment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Fragment\";\n    value &= ~ShaderStage::Fragment;\n  }\n  if (value & ShaderStage::Compute) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Compute\";\n    value &= ~ShaderStage::Compute;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ShaderStage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureUsage value) {\n    o << \"TextureUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & TextureUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~TextureUsage::CopySrc;\n  }\n  if (value & TextureUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~TextureUsage::CopyDst;\n  }\n  if (value & TextureUsage::TextureBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"TextureBinding\";\n    value &= ~TextureUsage::TextureBinding;\n  }\n  if (value & TextureUsage::StorageBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"StorageBinding\";\n    value &= ~TextureUsage::StorageBinding;\n  }\n  if (value & TextureUsage::RenderAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"RenderAttachment\";\n    value &= ~TextureUsage::RenderAttachment;\n  }\n  if (value & TextureUsage::TransientAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"TransientAttachment\";\n    value &= ~TextureUsage::TransientAttachment;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n\n}  // namespace wgpu\n\n#endif // WEBGPU_CPP_PRINT_H_\n", "./include/dawn/EnumClassBitmasks.h": "// Copyright 2017 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_ENUMCLASSBITMASKS_H_\n#define INCLUDE_DAWN_ENUMCLASSBITMASKS_H_\n\n#include <type_traits>\n\n// The operators in dawn:: namespace need be introduced into other namespaces with\n// using-declarations for C++ Argument Dependent Lookup to work.\n#define DAWN_IMPORT_BITMASK_OPERATORS \\\n    using dawn::operator|;            \\\n    using dawn::operator&;            \\\n    using dawn::operator^;            \\\n    using dawn::operator~;            \\\n    using dawn::operator&=;           \\\n    using dawn::operator|=;           \\\n    using dawn::operator^=;           \\\n    using dawn::HasZeroOrOneBits;\n\nnamespace dawn {\n\ntemplate <typename T>\nstruct IsDawnBitmask {\n    static constexpr bool enable = false;\n};\n\ntemplate <typename T, typename Enable = void>\nstruct LowerBitmask {\n    static constexpr bool enable = false;\n};\n\ntemplate <typename T>\nstruct LowerBitmask<T, typename std::enable_if<IsDawnBitmask<T>::enable>::type> {\n    static constexpr bool enable = true;\n    using type = T;\n    constexpr static T Lower(T t) { return t; }\n};\n\ntemplate <typename T>\nstruct BoolConvertible {\n    using Integral = typename std::underlying_type<T>::type;\n\n    // NOLINTNEXTLINE(runtime/explicit)\n    explicit constexpr BoolConvertible(Integral value) : value(value) {}\n    constexpr operator bool() const { return value != 0; }\n    constexpr operator T() const { return static_cast<T>(value); }\n\n    Integral value;\n};\n\ntemplate <typename T>\nstruct LowerBitmask<BoolConvertible<T>> {\n    static constexpr bool enable = true;\n    using type = T;\n    static constexpr type Lower(BoolConvertible<T> t) { return t; }\n};\n\ntemplate <\n    typename T1,\n    typename T2,\n    typename = typename std::enable_if<LowerBitmask<T1>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator|(T1 left, T2 right) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return BoolConvertible<T>(static_cast<Integral>(LowerBitmask<T1>::Lower(left)) |\n                              static_cast<Integral>(LowerBitmask<T2>::Lower(right)));\n}\n\ntemplate <\n    typename T1,\n    typename T2,\n    typename = typename std::enable_if<LowerBitmask<T1>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator&(T1 left, T2 right) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return BoolConvertible<T>(static_cast<Integral>(LowerBitmask<T1>::Lower(left)) &\n                              static_cast<Integral>(LowerBitmask<T2>::Lower(right)));\n}\n\ntemplate <\n    typename T1,\n    typename T2,\n    typename = typename std::enable_if<LowerBitmask<T1>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator^(T1 left, T2 right) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return BoolConvertible<T>(static_cast<Integral>(LowerBitmask<T1>::Lower(left)) ^\n                              static_cast<Integral>(LowerBitmask<T2>::Lower(right)));\n}\n\ntemplate <typename T1>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator~(T1 t) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return BoolConvertible<T>(~static_cast<Integral>(LowerBitmask<T1>::Lower(t)));\n}\n\ntemplate <\n    typename T,\n    typename T2,\n    typename = typename std::enable_if<IsDawnBitmask<T>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr T& operator&=(T& l, T2 right) {\n    T r = LowerBitmask<T2>::Lower(right);\n    l = l & r;\n    return l;\n}\n\ntemplate <\n    typename T,\n    typename T2,\n    typename = typename std::enable_if<IsDawnBitmask<T>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr T& operator|=(T& l, T2 right) {\n    T r = LowerBitmask<T2>::Lower(right);\n    l = l | r;\n    return l;\n}\n\ntemplate <\n    typename T,\n    typename T2,\n    typename = typename std::enable_if<IsDawnBitmask<T>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr T& operator^=(T& l, T2 right) {\n    T r = LowerBitmask<T2>::Lower(right);\n    l = l ^ r;\n    return l;\n}\n\ntemplate <typename T>\nconstexpr bool HasZeroOrOneBits(T value) {\n    using Integral = typename std::underlying_type<T>::type;\n    return (static_cast<Integral>(value) & (static_cast<Integral>(value) - 1)) == 0;\n}\n\n}  // namespace dawn\n\n#endif  // INCLUDE_DAWN_ENUMCLASSBITMASKS_H_\n", "./include/dawn/webgpu.h": "// BSD 3-Clause License\n//\n// Copyright (c) 2019, \"WebGPU native\" developers\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n#ifndef WEBGPU_H_\n#define WEBGPU_H_\n\n#if defined(WGPU_SHARED_LIBRARY)\n#    if defined(_WIN32)\n#        if defined(WGPU_IMPLEMENTATION)\n#            define WGPU_EXPORT __declspec(dllexport)\n#        else\n#            define WGPU_EXPORT __declspec(dllimport)\n#        endif\n#    else  // defined(_WIN32)\n#        if defined(WGPU_IMPLEMENTATION)\n#            define WGPU_EXPORT __attribute__((visibility(\"default\")))\n#        else\n#            define WGPU_EXPORT\n#        endif\n#    endif  // defined(_WIN32)\n#else       // defined(WGPU_SHARED_LIBRARY)\n#    define WGPU_EXPORT\n#endif  // defined(WGPU_SHARED_LIBRARY)\n\n#if !defined(WGPU_OBJECT_ATTRIBUTE)\n#define WGPU_OBJECT_ATTRIBUTE\n#endif\n#if !defined(WGPU_ENUM_ATTRIBUTE)\n#define WGPU_ENUM_ATTRIBUTE\n#endif\n#if !defined(WGPU_STRUCTURE_ATTRIBUTE)\n#define WGPU_STRUCTURE_ATTRIBUTE\n#endif\n#if !defined(WGPU_FUNCTION_ATTRIBUTE)\n#define WGPU_FUNCTION_ATTRIBUTE\n#endif\n#if !defined(WGPU_NULLABLE)\n#define WGPU_NULLABLE\n#endif\n\n#include <stdint.h>\n#include <stddef.h>\n\n#define WGPU_ARRAY_LAYER_COUNT_UNDEFINED (0xffffffffUL)\n#define WGPU_COPY_STRIDE_UNDEFINED (0xffffffffUL)\n#define WGPU_LIMIT_U32_UNDEFINED (0xffffffffUL)\n#define WGPU_LIMIT_U64_UNDEFINED (0xffffffffffffffffULL)\n#define WGPU_MIP_LEVEL_COUNT_UNDEFINED (0xffffffffUL)\n#define WGPU_WHOLE_MAP_SIZE SIZE_MAX\n#define WGPU_WHOLE_SIZE (0xffffffffffffffffULL)\n\ntypedef uint32_t WGPUFlags;\ntypedef uint32_t WGPUBool;\n\ntypedef struct WGPUAdapterImpl* WGPUAdapter WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUBindGroupImpl* WGPUBindGroup WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUBindGroupLayoutImpl* WGPUBindGroupLayout WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUBufferImpl* WGPUBuffer WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUCommandBufferImpl* WGPUCommandBuffer WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUCommandEncoderImpl* WGPUCommandEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUComputePassEncoderImpl* WGPUComputePassEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUComputePipelineImpl* WGPUComputePipeline WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUDeviceImpl* WGPUDevice WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUExternalTextureImpl* WGPUExternalTexture WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUInstanceImpl* WGPUInstance WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUPipelineLayoutImpl* WGPUPipelineLayout WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUQuerySetImpl* WGPUQuerySet WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUQueueImpl* WGPUQueue WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderBundleImpl* WGPURenderBundle WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderBundleEncoderImpl* WGPURenderBundleEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderPassEncoderImpl* WGPURenderPassEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderPipelineImpl* WGPURenderPipeline WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSamplerImpl* WGPUSampler WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUShaderModuleImpl* WGPUShaderModule WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSharedFenceImpl* WGPUSharedFence WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSharedTextureMemoryImpl* WGPUSharedTextureMemory WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSurfaceImpl* WGPUSurface WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSwapChainImpl* WGPUSwapChain WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUTextureImpl* WGPUTexture WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUTextureViewImpl* WGPUTextureView WGPU_OBJECT_ATTRIBUTE;\n\n// Structure forward declarations\nstruct WGPUAdapterProperties;\nstruct WGPUBindGroupEntry;\nstruct WGPUBlendComponent;\nstruct WGPUBufferBindingLayout;\nstruct WGPUBufferDescriptor;\nstruct WGPUColor;\nstruct WGPUCommandBufferDescriptor;\nstruct WGPUCommandEncoderDescriptor;\nstruct WGPUCompilationMessage;\nstruct WGPUComputePassTimestampWrite;\nstruct WGPUConstantEntry;\nstruct WGPUCopyTextureForBrowserOptions;\nstruct WGPUDawnAdapterPropertiesPowerPreference;\nstruct WGPUDawnBufferDescriptorErrorInfoFromWireClient;\nstruct WGPUDawnCacheDeviceDescriptor;\nstruct WGPUDawnEncoderInternalUsageDescriptor;\nstruct WGPUDawnMultisampleStateRenderToSingleSampled;\nstruct WGPUDawnRenderPassColorAttachmentRenderToSingleSampled;\nstruct WGPUDawnShaderModuleSPIRVOptionsDescriptor;\nstruct WGPUDawnTextureInternalUsageDescriptor;\nstruct WGPUDawnTogglesDescriptor;\nstruct WGPUExtent2D;\nstruct WGPUExtent3D;\nstruct WGPUExternalTextureBindingEntry;\nstruct WGPUExternalTextureBindingLayout;\nstruct WGPUInstanceDescriptor;\nstruct WGPULimits;\nstruct WGPUMultisampleState;\nstruct WGPUOrigin2D;\nstruct WGPUOrigin3D;\nstruct WGPUPipelineLayoutDescriptor;\nstruct WGPUPrimitiveDepthClipControl;\nstruct WGPUPrimitiveState;\nstruct WGPUQuerySetDescriptor;\nstruct WGPUQueueDescriptor;\nstruct WGPURenderBundleDescriptor;\nstruct WGPURenderBundleEncoderDescriptor;\nstruct WGPURenderPassDepthStencilAttachment;\nstruct WGPURenderPassDescriptorMaxDrawCount;\nstruct WGPURenderPassTimestampWrite;\nstruct WGPURequestAdapterOptions;\nstruct WGPUSamplerBindingLayout;\nstruct WGPUSamplerDescriptor;\nstruct WGPUShaderModuleDescriptor;\nstruct WGPUShaderModuleSPIRVDescriptor;\nstruct WGPUShaderModuleWGSLDescriptor;\nstruct WGPUSharedFenceDescriptor;\nstruct WGPUSharedFenceDXGISharedHandleDescriptor;\nstruct WGPUSharedFenceDXGISharedHandleExportInfo;\nstruct WGPUSharedFenceExportInfo;\nstruct WGPUSharedFenceMTLSharedEventDescriptor;\nstruct WGPUSharedFenceMTLSharedEventExportInfo;\nstruct WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor;\nstruct WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo;\nstruct WGPUSharedFenceVkSemaphoreSyncFDDescriptor;\nstruct WGPUSharedFenceVkSemaphoreSyncFDExportInfo;\nstruct WGPUSharedFenceVkSemaphoreZirconHandleDescriptor;\nstruct WGPUSharedFenceVkSemaphoreZirconHandleExportInfo;\nstruct WGPUSharedTextureMemoryAHardwareBufferDescriptor;\nstruct WGPUSharedTextureMemoryBeginAccessDescriptor;\nstruct WGPUSharedTextureMemoryDescriptor;\nstruct WGPUSharedTextureMemoryDmaBufDescriptor;\nstruct WGPUSharedTextureMemoryDXGISharedHandleDescriptor;\nstruct WGPUSharedTextureMemoryEGLImageDescriptor;\nstruct WGPUSharedTextureMemoryEndAccessState;\nstruct WGPUSharedTextureMemoryIOSurfaceDescriptor;\nstruct WGPUSharedTextureMemoryOpaqueFDDescriptor;\nstruct WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor;\nstruct WGPUSharedTextureMemoryVkImageLayoutBeginState;\nstruct WGPUSharedTextureMemoryVkImageLayoutEndState;\nstruct WGPUSharedTextureMemoryZirconHandleDescriptor;\nstruct WGPUStencilFaceState;\nstruct WGPUStorageTextureBindingLayout;\nstruct WGPUSurfaceDescriptor;\nstruct WGPUSurfaceDescriptorFromAndroidNativeWindow;\nstruct WGPUSurfaceDescriptorFromCanvasHTMLSelector;\nstruct WGPUSurfaceDescriptorFromMetalLayer;\nstruct WGPUSurfaceDescriptorFromWaylandSurface;\nstruct WGPUSurfaceDescriptorFromWindowsCoreWindow;\nstruct WGPUSurfaceDescriptorFromWindowsHWND;\nstruct WGPUSurfaceDescriptorFromWindowsSwapChainPanel;\nstruct WGPUSurfaceDescriptorFromXlibWindow;\nstruct WGPUSwapChainDescriptor;\nstruct WGPUTextureBindingLayout;\nstruct WGPUTextureDataLayout;\nstruct WGPUTextureViewDescriptor;\nstruct WGPUVertexAttribute;\nstruct WGPUBindGroupDescriptor;\nstruct WGPUBindGroupLayoutEntry;\nstruct WGPUBlendState;\nstruct WGPUCompilationInfo;\nstruct WGPUComputePassDescriptor;\nstruct WGPUDepthStencilState;\nstruct WGPUExternalTextureDescriptor;\nstruct WGPUImageCopyBuffer;\nstruct WGPUImageCopyExternalTexture;\nstruct WGPUImageCopyTexture;\nstruct WGPUProgrammableStageDescriptor;\nstruct WGPURenderPassColorAttachment;\nstruct WGPURequiredLimits;\nstruct WGPUSharedTextureMemoryProperties;\nstruct WGPUSharedTextureMemoryVkImageDescriptor;\nstruct WGPUSupportedLimits;\nstruct WGPUTextureDescriptor;\nstruct WGPUVertexBufferLayout;\nstruct WGPUBindGroupLayoutDescriptor;\nstruct WGPUColorTargetState;\nstruct WGPUComputePipelineDescriptor;\nstruct WGPUDeviceDescriptor;\nstruct WGPURenderPassDescriptor;\nstruct WGPUVertexState;\nstruct WGPUFragmentState;\nstruct WGPURenderPipelineDescriptor;\n\ntypedef enum WGPUAdapterType {\n    WGPUAdapterType_DiscreteGPU = 0x00000000,\n    WGPUAdapterType_IntegratedGPU = 0x00000001,\n    WGPUAdapterType_CPU = 0x00000002,\n    WGPUAdapterType_Unknown = 0x00000003,\n    WGPUAdapterType_Force32 = 0x7FFFFFFF\n} WGPUAdapterType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUAddressMode {\n    WGPUAddressMode_Repeat = 0x00000000,\n    WGPUAddressMode_MirrorRepeat = 0x00000001,\n    WGPUAddressMode_ClampToEdge = 0x00000002,\n    WGPUAddressMode_Force32 = 0x7FFFFFFF\n} WGPUAddressMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUAlphaMode {\n    WGPUAlphaMode_Premultiplied = 0x00000000,\n    WGPUAlphaMode_Unpremultiplied = 0x00000001,\n    WGPUAlphaMode_Opaque = 0x00000002,\n    WGPUAlphaMode_Force32 = 0x7FFFFFFF\n} WGPUAlphaMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBackendType {\n    WGPUBackendType_Undefined = 0x00000000,\n    WGPUBackendType_Null = 0x00000001,\n    WGPUBackendType_WebGPU = 0x00000002,\n    WGPUBackendType_D3D11 = 0x00000003,\n    WGPUBackendType_D3D12 = 0x00000004,\n    WGPUBackendType_Metal = 0x00000005,\n    WGPUBackendType_Vulkan = 0x00000006,\n    WGPUBackendType_OpenGL = 0x00000007,\n    WGPUBackendType_OpenGLES = 0x00000008,\n    WGPUBackendType_Force32 = 0x7FFFFFFF\n} WGPUBackendType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBlendFactor {\n    WGPUBlendFactor_Zero = 0x00000000,\n    WGPUBlendFactor_One = 0x00000001,\n    WGPUBlendFactor_Src = 0x00000002,\n    WGPUBlendFactor_OneMinusSrc = 0x00000003,\n    WGPUBlendFactor_SrcAlpha = 0x00000004,\n    WGPUBlendFactor_OneMinusSrcAlpha = 0x00000005,\n    WGPUBlendFactor_Dst = 0x00000006,\n    WGPUBlendFactor_OneMinusDst = 0x00000007,\n    WGPUBlendFactor_DstAlpha = 0x00000008,\n    WGPUBlendFactor_OneMinusDstAlpha = 0x00000009,\n    WGPUBlendFactor_SrcAlphaSaturated = 0x0000000A,\n    WGPUBlendFactor_Constant = 0x0000000B,\n    WGPUBlendFactor_OneMinusConstant = 0x0000000C,\n    WGPUBlendFactor_Src1 = 0x0000000D,\n    WGPUBlendFactor_OneMinusSrc1 = 0x0000000E,\n    WGPUBlendFactor_Src1Alpha = 0x0000000F,\n    WGPUBlendFactor_OneMinusSrc1Alpha = 0x00000010,\n    WGPUBlendFactor_Force32 = 0x7FFFFFFF\n} WGPUBlendFactor WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBlendOperation {\n    WGPUBlendOperation_Add = 0x00000000,\n    WGPUBlendOperation_Subtract = 0x00000001,\n    WGPUBlendOperation_ReverseSubtract = 0x00000002,\n    WGPUBlendOperation_Min = 0x00000003,\n    WGPUBlendOperation_Max = 0x00000004,\n    WGPUBlendOperation_Force32 = 0x7FFFFFFF\n} WGPUBlendOperation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferBindingType {\n    WGPUBufferBindingType_Undefined = 0x00000000,\n    WGPUBufferBindingType_Uniform = 0x00000001,\n    WGPUBufferBindingType_Storage = 0x00000002,\n    WGPUBufferBindingType_ReadOnlyStorage = 0x00000003,\n    WGPUBufferBindingType_Force32 = 0x7FFFFFFF\n} WGPUBufferBindingType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferMapAsyncStatus {\n    WGPUBufferMapAsyncStatus_Success = 0x00000000,\n    WGPUBufferMapAsyncStatus_ValidationError = 0x00000001,\n    WGPUBufferMapAsyncStatus_Unknown = 0x00000002,\n    WGPUBufferMapAsyncStatus_DeviceLost = 0x00000003,\n    WGPUBufferMapAsyncStatus_DestroyedBeforeCallback = 0x00000004,\n    WGPUBufferMapAsyncStatus_UnmappedBeforeCallback = 0x00000005,\n    WGPUBufferMapAsyncStatus_MappingAlreadyPending = 0x00000006,\n    WGPUBufferMapAsyncStatus_OffsetOutOfRange = 0x00000007,\n    WGPUBufferMapAsyncStatus_SizeOutOfRange = 0x00000008,\n    WGPUBufferMapAsyncStatus_Force32 = 0x7FFFFFFF\n} WGPUBufferMapAsyncStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferMapState {\n    WGPUBufferMapState_Unmapped = 0x00000000,\n    WGPUBufferMapState_Pending = 0x00000001,\n    WGPUBufferMapState_Mapped = 0x00000002,\n    WGPUBufferMapState_Force32 = 0x7FFFFFFF\n} WGPUBufferMapState WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCompareFunction {\n    WGPUCompareFunction_Undefined = 0x00000000,\n    WGPUCompareFunction_Never = 0x00000001,\n    WGPUCompareFunction_Less = 0x00000002,\n    WGPUCompareFunction_LessEqual = 0x00000003,\n    WGPUCompareFunction_Greater = 0x00000004,\n    WGPUCompareFunction_GreaterEqual = 0x00000005,\n    WGPUCompareFunction_Equal = 0x00000006,\n    WGPUCompareFunction_NotEqual = 0x00000007,\n    WGPUCompareFunction_Always = 0x00000008,\n    WGPUCompareFunction_Force32 = 0x7FFFFFFF\n} WGPUCompareFunction WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCompilationInfoRequestStatus {\n    WGPUCompilationInfoRequestStatus_Success = 0x00000000,\n    WGPUCompilationInfoRequestStatus_Error = 0x00000001,\n    WGPUCompilationInfoRequestStatus_DeviceLost = 0x00000002,\n    WGPUCompilationInfoRequestStatus_Unknown = 0x00000003,\n    WGPUCompilationInfoRequestStatus_Force32 = 0x7FFFFFFF\n} WGPUCompilationInfoRequestStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCompilationMessageType {\n    WGPUCompilationMessageType_Error = 0x00000000,\n    WGPUCompilationMessageType_Warning = 0x00000001,\n    WGPUCompilationMessageType_Info = 0x00000002,\n    WGPUCompilationMessageType_Force32 = 0x7FFFFFFF\n} WGPUCompilationMessageType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUComputePassTimestampLocation {\n    WGPUComputePassTimestampLocation_Beginning = 0x00000000,\n    WGPUComputePassTimestampLocation_End = 0x00000001,\n    WGPUComputePassTimestampLocation_Force32 = 0x7FFFFFFF\n} WGPUComputePassTimestampLocation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCreatePipelineAsyncStatus {\n    WGPUCreatePipelineAsyncStatus_Success = 0x00000000,\n    WGPUCreatePipelineAsyncStatus_ValidationError = 0x00000001,\n    WGPUCreatePipelineAsyncStatus_InternalError = 0x00000002,\n    WGPUCreatePipelineAsyncStatus_DeviceLost = 0x00000003,\n    WGPUCreatePipelineAsyncStatus_DeviceDestroyed = 0x00000004,\n    WGPUCreatePipelineAsyncStatus_Unknown = 0x00000005,\n    WGPUCreatePipelineAsyncStatus_Force32 = 0x7FFFFFFF\n} WGPUCreatePipelineAsyncStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCullMode {\n    WGPUCullMode_None = 0x00000000,\n    WGPUCullMode_Front = 0x00000001,\n    WGPUCullMode_Back = 0x00000002,\n    WGPUCullMode_Force32 = 0x7FFFFFFF\n} WGPUCullMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUDeviceLostReason {\n    WGPUDeviceLostReason_Undefined = 0x00000000,\n    WGPUDeviceLostReason_Destroyed = 0x00000001,\n    WGPUDeviceLostReason_Force32 = 0x7FFFFFFF\n} WGPUDeviceLostReason WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUErrorFilter {\n    WGPUErrorFilter_Validation = 0x00000000,\n    WGPUErrorFilter_OutOfMemory = 0x00000001,\n    WGPUErrorFilter_Internal = 0x00000002,\n    WGPUErrorFilter_Force32 = 0x7FFFFFFF\n} WGPUErrorFilter WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUErrorType {\n    WGPUErrorType_NoError = 0x00000000,\n    WGPUErrorType_Validation = 0x00000001,\n    WGPUErrorType_OutOfMemory = 0x00000002,\n    WGPUErrorType_Internal = 0x00000003,\n    WGPUErrorType_Unknown = 0x00000004,\n    WGPUErrorType_DeviceLost = 0x00000005,\n    WGPUErrorType_Force32 = 0x7FFFFFFF\n} WGPUErrorType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUExternalTextureRotation {\n    WGPUExternalTextureRotation_Rotate0Degrees = 0x00000000,\n    WGPUExternalTextureRotation_Rotate90Degrees = 0x00000001,\n    WGPUExternalTextureRotation_Rotate180Degrees = 0x00000002,\n    WGPUExternalTextureRotation_Rotate270Degrees = 0x00000003,\n    WGPUExternalTextureRotation_Force32 = 0x7FFFFFFF\n} WGPUExternalTextureRotation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUFeatureName {\n    WGPUFeatureName_Undefined = 0x00000000,\n    WGPUFeatureName_DepthClipControl = 0x00000001,\n    WGPUFeatureName_Depth32FloatStencil8 = 0x00000002,\n    WGPUFeatureName_TimestampQuery = 0x00000003,\n    WGPUFeatureName_PipelineStatisticsQuery = 0x00000004,\n    WGPUFeatureName_TextureCompressionBC = 0x00000005,\n    WGPUFeatureName_TextureCompressionETC2 = 0x00000006,\n    WGPUFeatureName_TextureCompressionASTC = 0x00000007,\n    WGPUFeatureName_IndirectFirstInstance = 0x00000008,\n    WGPUFeatureName_ShaderF16 = 0x00000009,\n    WGPUFeatureName_RG11B10UfloatRenderable = 0x0000000A,\n    WGPUFeatureName_BGRA8UnormStorage = 0x0000000B,\n    WGPUFeatureName_Float32Filterable = 0x0000000C,\n    WGPUFeatureName_DawnInternalUsages = 0x000003EA,\n    WGPUFeatureName_DawnMultiPlanarFormats = 0x000003EB,\n    WGPUFeatureName_DawnNative = 0x000003EC,\n    WGPUFeatureName_ChromiumExperimentalDp4a = 0x000003ED,\n    WGPUFeatureName_TimestampQueryInsidePasses = 0x000003EE,\n    WGPUFeatureName_ImplicitDeviceSynchronization = 0x000003EF,\n    WGPUFeatureName_SurfaceCapabilities = 0x000003F0,\n    WGPUFeatureName_TransientAttachments = 0x000003F1,\n    WGPUFeatureName_MSAARenderToSingleSampled = 0x000003F2,\n    WGPUFeatureName_DualSourceBlending = 0x000003F3,\n    WGPUFeatureName_D3D11MultithreadProtected = 0x000003F4,\n    WGPUFeatureName_ANGLETextureSharing = 0x000003F5,\n    WGPUFeatureName_SharedTextureMemoryVkDedicatedAllocation = 0x0000044C,\n    WGPUFeatureName_SharedTextureMemoryAHardwareBuffer = 0x0000044D,\n    WGPUFeatureName_SharedTextureMemoryDmaBuf = 0x0000044E,\n    WGPUFeatureName_SharedTextureMemoryOpaqueFD = 0x0000044F,\n    WGPUFeatureName_SharedTextureMemoryZirconHandle = 0x00000450,\n    WGPUFeatureName_SharedTextureMemoryDXGISharedHandle = 0x00000451,\n    WGPUFeatureName_SharedTextureMemoryD3D11Texture2D = 0x00000452,\n    WGPUFeatureName_SharedTextureMemoryIOSurface = 0x00000453,\n    WGPUFeatureName_SharedTextureMemoryEGLImage = 0x00000454,\n    WGPUFeatureName_SharedFenceVkSemaphoreOpaqueFD = 0x000004B0,\n    WGPUFeatureName_SharedFenceVkSemaphoreSyncFD = 0x000004B1,\n    WGPUFeatureName_SharedFenceVkSemaphoreZirconHandle = 0x000004B2,\n    WGPUFeatureName_SharedFenceDXGISharedHandle = 0x000004B3,\n    WGPUFeatureName_SharedFenceMTLSharedEvent = 0x000004B4,\n    WGPUFeatureName_Force32 = 0x7FFFFFFF\n} WGPUFeatureName WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUFilterMode {\n    WGPUFilterMode_Nearest = 0x00000000,\n    WGPUFilterMode_Linear = 0x00000001,\n    WGPUFilterMode_Force32 = 0x7FFFFFFF\n} WGPUFilterMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUFrontFace {\n    WGPUFrontFace_CCW = 0x00000000,\n    WGPUFrontFace_CW = 0x00000001,\n    WGPUFrontFace_Force32 = 0x7FFFFFFF\n} WGPUFrontFace WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUIndexFormat {\n    WGPUIndexFormat_Undefined = 0x00000000,\n    WGPUIndexFormat_Uint16 = 0x00000001,\n    WGPUIndexFormat_Uint32 = 0x00000002,\n    WGPUIndexFormat_Force32 = 0x7FFFFFFF\n} WGPUIndexFormat WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPULoadOp {\n    WGPULoadOp_Undefined = 0x00000000,\n    WGPULoadOp_Clear = 0x00000001,\n    WGPULoadOp_Load = 0x00000002,\n    WGPULoadOp_Force32 = 0x7FFFFFFF\n} WGPULoadOp WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPULoggingType {\n    WGPULoggingType_Verbose = 0x00000000,\n    WGPULoggingType_Info = 0x00000001,\n    WGPULoggingType_Warning = 0x00000002,\n    WGPULoggingType_Error = 0x00000003,\n    WGPULoggingType_Force32 = 0x7FFFFFFF\n} WGPULoggingType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUMipmapFilterMode {\n    WGPUMipmapFilterMode_Nearest = 0x00000000,\n    WGPUMipmapFilterMode_Linear = 0x00000001,\n    WGPUMipmapFilterMode_Force32 = 0x7FFFFFFF\n} WGPUMipmapFilterMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPipelineStatisticName {\n    WGPUPipelineStatisticName_VertexShaderInvocations = 0x00000000,\n    WGPUPipelineStatisticName_ClipperInvocations = 0x00000001,\n    WGPUPipelineStatisticName_ClipperPrimitivesOut = 0x00000002,\n    WGPUPipelineStatisticName_FragmentShaderInvocations = 0x00000003,\n    WGPUPipelineStatisticName_ComputeShaderInvocations = 0x00000004,\n    WGPUPipelineStatisticName_Force32 = 0x7FFFFFFF\n} WGPUPipelineStatisticName WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPowerPreference {\n    WGPUPowerPreference_Undefined = 0x00000000,\n    WGPUPowerPreference_LowPower = 0x00000001,\n    WGPUPowerPreference_HighPerformance = 0x00000002,\n    WGPUPowerPreference_Force32 = 0x7FFFFFFF\n} WGPUPowerPreference WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPresentMode {\n    WGPUPresentMode_Immediate = 0x00000000,\n    WGPUPresentMode_Mailbox = 0x00000001,\n    WGPUPresentMode_Fifo = 0x00000002,\n    WGPUPresentMode_Force32 = 0x7FFFFFFF\n} WGPUPresentMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPrimitiveTopology {\n    WGPUPrimitiveTopology_PointList = 0x00000000,\n    WGPUPrimitiveTopology_LineList = 0x00000001,\n    WGPUPrimitiveTopology_LineStrip = 0x00000002,\n    WGPUPrimitiveTopology_TriangleList = 0x00000003,\n    WGPUPrimitiveTopology_TriangleStrip = 0x00000004,\n    WGPUPrimitiveTopology_Force32 = 0x7FFFFFFF\n} WGPUPrimitiveTopology WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUQueryType {\n    WGPUQueryType_Occlusion = 0x00000000,\n    WGPUQueryType_PipelineStatistics = 0x00000001,\n    WGPUQueryType_Timestamp = 0x00000002,\n    WGPUQueryType_Force32 = 0x7FFFFFFF\n} WGPUQueryType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUQueueWorkDoneStatus {\n    WGPUQueueWorkDoneStatus_Success = 0x00000000,\n    WGPUQueueWorkDoneStatus_Error = 0x00000001,\n    WGPUQueueWorkDoneStatus_Unknown = 0x00000002,\n    WGPUQueueWorkDoneStatus_DeviceLost = 0x00000003,\n    WGPUQueueWorkDoneStatus_Force32 = 0x7FFFFFFF\n} WGPUQueueWorkDoneStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPURenderPassTimestampLocation {\n    WGPURenderPassTimestampLocation_Beginning = 0x00000000,\n    WGPURenderPassTimestampLocation_End = 0x00000001,\n    WGPURenderPassTimestampLocation_Force32 = 0x7FFFFFFF\n} WGPURenderPassTimestampLocation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPURequestAdapterStatus {\n    WGPURequestAdapterStatus_Success = 0x00000000,\n    WGPURequestAdapterStatus_Unavailable = 0x00000001,\n    WGPURequestAdapterStatus_Error = 0x00000002,\n    WGPURequestAdapterStatus_Unknown = 0x00000003,\n    WGPURequestAdapterStatus_Force32 = 0x7FFFFFFF\n} WGPURequestAdapterStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPURequestDeviceStatus {\n    WGPURequestDeviceStatus_Success = 0x00000000,\n    WGPURequestDeviceStatus_Error = 0x00000001,\n    WGPURequestDeviceStatus_Unknown = 0x00000002,\n    WGPURequestDeviceStatus_Force32 = 0x7FFFFFFF\n} WGPURequestDeviceStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUSType {\n    WGPUSType_Invalid = 0x00000000,\n    WGPUSType_SurfaceDescriptorFromMetalLayer = 0x00000001,\n    WGPUSType_SurfaceDescriptorFromWindowsHWND = 0x00000002,\n    WGPUSType_SurfaceDescriptorFromXlibWindow = 0x00000003,\n    WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n    WGPUSType_ShaderModuleSPIRVDescriptor = 0x00000005,\n    WGPUSType_ShaderModuleWGSLDescriptor = 0x00000006,\n    WGPUSType_PrimitiveDepthClipControl = 0x00000007,\n    WGPUSType_SurfaceDescriptorFromWaylandSurface = 0x00000008,\n    WGPUSType_SurfaceDescriptorFromAndroidNativeWindow = 0x00000009,\n    WGPUSType_SurfaceDescriptorFromWindowsCoreWindow = 0x0000000B,\n    WGPUSType_ExternalTextureBindingEntry = 0x0000000C,\n    WGPUSType_ExternalTextureBindingLayout = 0x0000000D,\n    WGPUSType_SurfaceDescriptorFromWindowsSwapChainPanel = 0x0000000E,\n    WGPUSType_RenderPassDescriptorMaxDrawCount = 0x0000000F,\n    WGPUSType_DawnTextureInternalUsageDescriptor = 0x000003E8,\n    WGPUSType_DawnEncoderInternalUsageDescriptor = 0x000003EB,\n    WGPUSType_DawnInstanceDescriptor = 0x000003EC,\n    WGPUSType_DawnCacheDeviceDescriptor = 0x000003ED,\n    WGPUSType_DawnAdapterPropertiesPowerPreference = 0x000003EE,\n    WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient = 0x000003EF,\n    WGPUSType_DawnTogglesDescriptor = 0x000003F0,\n    WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor = 0x000003F1,\n    WGPUSType_RequestAdapterOptionsLUID = 0x000003F2,\n    WGPUSType_RequestAdapterOptionsGetGLProc = 0x000003F3,\n    WGPUSType_DawnMultisampleStateRenderToSingleSampled = 0x000003F4,\n    WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled = 0x000003F5,\n    WGPUSType_SharedTextureMemoryVkImageDescriptor = 0x0000044C,\n    WGPUSType_SharedTextureMemoryVkDedicatedAllocationDescriptor = 0x0000044D,\n    WGPUSType_SharedTextureMemoryAHardwareBufferDescriptor = 0x0000044E,\n    WGPUSType_SharedTextureMemoryDmaBufDescriptor = 0x0000044F,\n    WGPUSType_SharedTextureMemoryOpaqueFDDescriptor = 0x00000450,\n    WGPUSType_SharedTextureMemoryZirconHandleDescriptor = 0x00000451,\n    WGPUSType_SharedTextureMemoryDXGISharedHandleDescriptor = 0x00000452,\n    WGPUSType_SharedTextureMemoryD3D11Texture2DDescriptor = 0x00000453,\n    WGPUSType_SharedTextureMemoryIOSurfaceDescriptor = 0x00000454,\n    WGPUSType_SharedTextureMemoryEGLImageDescriptor = 0x00000455,\n    WGPUSType_SharedTextureMemoryInitializedBeginState = 0x000004B0,\n    WGPUSType_SharedTextureMemoryInitializedEndState = 0x000004B1,\n    WGPUSType_SharedTextureMemoryVkImageLayoutBeginState = 0x000004B2,\n    WGPUSType_SharedTextureMemoryVkImageLayoutEndState = 0x000004B3,\n    WGPUSType_SharedFenceVkSemaphoreOpaqueFDDescriptor = 0x000004B4,\n    WGPUSType_SharedFenceVkSemaphoreOpaqueFDExportInfo = 0x000004B5,\n    WGPUSType_SharedFenceVkSemaphoreSyncFDDescriptor = 0x000004B6,\n    WGPUSType_SharedFenceVkSemaphoreSyncFDExportInfo = 0x000004B7,\n    WGPUSType_SharedFenceVkSemaphoreZirconHandleDescriptor = 0x000004B8,\n    WGPUSType_SharedFenceVkSemaphoreZirconHandleExportInfo = 0x000004B9,\n    WGPUSType_SharedFenceDXGISharedHandleDescriptor = 0x000004BA,\n    WGPUSType_SharedFenceDXGISharedHandleExportInfo = 0x000004BB,\n    WGPUSType_SharedFenceMTLSharedEventDescriptor = 0x000004BC,\n    WGPUSType_SharedFenceMTLSharedEventExportInfo = 0x000004BD,\n    WGPUSType_Force32 = 0x7FFFFFFF\n} WGPUSType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUSamplerBindingType {\n    WGPUSamplerBindingType_Undefined = 0x00000000,\n    WGPUSamplerBindingType_Filtering = 0x00000001,\n    WGPUSamplerBindingType_NonFiltering = 0x00000002,\n    WGPUSamplerBindingType_Comparison = 0x00000003,\n    WGPUSamplerBindingType_Force32 = 0x7FFFFFFF\n} WGPUSamplerBindingType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUSharedFenceType {\n    WGPUSharedFenceType_Undefined = 0x00000000,\n    WGPUSharedFenceType_VkSemaphoreOpaqueFD = 0x00000001,\n    WGPUSharedFenceType_VkSemaphoreSyncFD = 0x00000002,\n    WGPUSharedFenceType_VkSemaphoreZirconHandle = 0x00000003,\n    WGPUSharedFenceType_DXGISharedHandle = 0x00000004,\n    WGPUSharedFenceType_MTLSharedEvent = 0x00000005,\n    WGPUSharedFenceType_Force32 = 0x7FFFFFFF\n} WGPUSharedFenceType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUStencilOperation {\n    WGPUStencilOperation_Keep = 0x00000000,\n    WGPUStencilOperation_Zero = 0x00000001,\n    WGPUStencilOperation_Replace = 0x00000002,\n    WGPUStencilOperation_Invert = 0x00000003,\n    WGPUStencilOperation_IncrementClamp = 0x00000004,\n    WGPUStencilOperation_DecrementClamp = 0x00000005,\n    WGPUStencilOperation_IncrementWrap = 0x00000006,\n    WGPUStencilOperation_DecrementWrap = 0x00000007,\n    WGPUStencilOperation_Force32 = 0x7FFFFFFF\n} WGPUStencilOperation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUStorageTextureAccess {\n    WGPUStorageTextureAccess_Undefined = 0x00000000,\n    WGPUStorageTextureAccess_WriteOnly = 0x00000001,\n    WGPUStorageTextureAccess_Force32 = 0x7FFFFFFF\n} WGPUStorageTextureAccess WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUStoreOp {\n    WGPUStoreOp_Undefined = 0x00000000,\n    WGPUStoreOp_Store = 0x00000001,\n    WGPUStoreOp_Discard = 0x00000002,\n    WGPUStoreOp_Force32 = 0x7FFFFFFF\n} WGPUStoreOp WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureAspect {\n    WGPUTextureAspect_All = 0x00000000,\n    WGPUTextureAspect_StencilOnly = 0x00000001,\n    WGPUTextureAspect_DepthOnly = 0x00000002,\n    WGPUTextureAspect_Plane0Only = 0x00000003,\n    WGPUTextureAspect_Plane1Only = 0x00000004,\n    WGPUTextureAspect_Force32 = 0x7FFFFFFF\n} WGPUTextureAspect WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureDimension {\n    WGPUTextureDimension_1D = 0x00000000,\n    WGPUTextureDimension_2D = 0x00000001,\n    WGPUTextureDimension_3D = 0x00000002,\n    WGPUTextureDimension_Force32 = 0x7FFFFFFF\n} WGPUTextureDimension WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureFormat {\n    WGPUTextureFormat_Undefined = 0x00000000,\n    WGPUTextureFormat_R8Unorm = 0x00000001,\n    WGPUTextureFormat_R8Snorm = 0x00000002,\n    WGPUTextureFormat_R8Uint = 0x00000003,\n    WGPUTextureFormat_R8Sint = 0x00000004,\n    WGPUTextureFormat_R16Uint = 0x00000005,\n    WGPUTextureFormat_R16Sint = 0x00000006,\n    WGPUTextureFormat_R16Float = 0x00000007,\n    WGPUTextureFormat_RG8Unorm = 0x00000008,\n    WGPUTextureFormat_RG8Snorm = 0x00000009,\n    WGPUTextureFormat_RG8Uint = 0x0000000A,\n    WGPUTextureFormat_RG8Sint = 0x0000000B,\n    WGPUTextureFormat_R32Float = 0x0000000C,\n    WGPUTextureFormat_R32Uint = 0x0000000D,\n    WGPUTextureFormat_R32Sint = 0x0000000E,\n    WGPUTextureFormat_RG16Uint = 0x0000000F,\n    WGPUTextureFormat_RG16Sint = 0x00000010,\n    WGPUTextureFormat_RG16Float = 0x00000011,\n    WGPUTextureFormat_RGBA8Unorm = 0x00000012,\n    WGPUTextureFormat_RGBA8UnormSrgb = 0x00000013,\n    WGPUTextureFormat_RGBA8Snorm = 0x00000014,\n    WGPUTextureFormat_RGBA8Uint = 0x00000015,\n    WGPUTextureFormat_RGBA8Sint = 0x00000016,\n    WGPUTextureFormat_BGRA8Unorm = 0x00000017,\n    WGPUTextureFormat_BGRA8UnormSrgb = 0x00000018,\n    WGPUTextureFormat_RGB10A2Unorm = 0x00000019,\n    WGPUTextureFormat_RG11B10Ufloat = 0x0000001A,\n    WGPUTextureFormat_RGB9E5Ufloat = 0x0000001B,\n    WGPUTextureFormat_RG32Float = 0x0000001C,\n    WGPUTextureFormat_RG32Uint = 0x0000001D,\n    WGPUTextureFormat_RG32Sint = 0x0000001E,\n    WGPUTextureFormat_RGBA16Uint = 0x0000001F,\n    WGPUTextureFormat_RGBA16Sint = 0x00000020,\n    WGPUTextureFormat_RGBA16Float = 0x00000021,\n    WGPUTextureFormat_RGBA32Float = 0x00000022,\n    WGPUTextureFormat_RGBA32Uint = 0x00000023,\n    WGPUTextureFormat_RGBA32Sint = 0x00000024,\n    WGPUTextureFormat_Stencil8 = 0x00000025,\n    WGPUTextureFormat_Depth16Unorm = 0x00000026,\n    WGPUTextureFormat_Depth24Plus = 0x00000027,\n    WGPUTextureFormat_Depth24PlusStencil8 = 0x00000028,\n    WGPUTextureFormat_Depth32Float = 0x00000029,\n    WGPUTextureFormat_Depth32FloatStencil8 = 0x0000002A,\n    WGPUTextureFormat_BC1RGBAUnorm = 0x0000002B,\n    WGPUTextureFormat_BC1RGBAUnormSrgb = 0x0000002C,\n    WGPUTextureFormat_BC2RGBAUnorm = 0x0000002D,\n    WGPUTextureFormat_BC2RGBAUnormSrgb = 0x0000002E,\n    WGPUTextureFormat_BC3RGBAUnorm = 0x0000002F,\n    WGPUTextureFormat_BC3RGBAUnormSrgb = 0x00000030,\n    WGPUTextureFormat_BC4RUnorm = 0x00000031,\n    WGPUTextureFormat_BC4RSnorm = 0x00000032,\n    WGPUTextureFormat_BC5RGUnorm = 0x00000033,\n    WGPUTextureFormat_BC5RGSnorm = 0x00000034,\n    WGPUTextureFormat_BC6HRGBUfloat = 0x00000035,\n    WGPUTextureFormat_BC6HRGBFloat = 0x00000036,\n    WGPUTextureFormat_BC7RGBAUnorm = 0x00000037,\n    WGPUTextureFormat_BC7RGBAUnormSrgb = 0x00000038,\n    WGPUTextureFormat_ETC2RGB8Unorm = 0x00000039,\n    WGPUTextureFormat_ETC2RGB8UnormSrgb = 0x0000003A,\n    WGPUTextureFormat_ETC2RGB8A1Unorm = 0x0000003B,\n    WGPUTextureFormat_ETC2RGB8A1UnormSrgb = 0x0000003C,\n    WGPUTextureFormat_ETC2RGBA8Unorm = 0x0000003D,\n    WGPUTextureFormat_ETC2RGBA8UnormSrgb = 0x0000003E,\n    WGPUTextureFormat_EACR11Unorm = 0x0000003F,\n    WGPUTextureFormat_EACR11Snorm = 0x00000040,\n    WGPUTextureFormat_EACRG11Unorm = 0x00000041,\n    WGPUTextureFormat_EACRG11Snorm = 0x00000042,\n    WGPUTextureFormat_ASTC4x4Unorm = 0x00000043,\n    WGPUTextureFormat_ASTC4x4UnormSrgb = 0x00000044,\n    WGPUTextureFormat_ASTC5x4Unorm = 0x00000045,\n    WGPUTextureFormat_ASTC5x4UnormSrgb = 0x00000046,\n    WGPUTextureFormat_ASTC5x5Unorm = 0x00000047,\n    WGPUTextureFormat_ASTC5x5UnormSrgb = 0x00000048,\n    WGPUTextureFormat_ASTC6x5Unorm = 0x00000049,\n    WGPUTextureFormat_ASTC6x5UnormSrgb = 0x0000004A,\n    WGPUTextureFormat_ASTC6x6Unorm = 0x0000004B,\n    WGPUTextureFormat_ASTC6x6UnormSrgb = 0x0000004C,\n    WGPUTextureFormat_ASTC8x5Unorm = 0x0000004D,\n    WGPUTextureFormat_ASTC8x5UnormSrgb = 0x0000004E,\n    WGPUTextureFormat_ASTC8x6Unorm = 0x0000004F,\n    WGPUTextureFormat_ASTC8x6UnormSrgb = 0x00000050,\n    WGPUTextureFormat_ASTC8x8Unorm = 0x00000051,\n    WGPUTextureFormat_ASTC8x8UnormSrgb = 0x00000052,\n    WGPUTextureFormat_ASTC10x5Unorm = 0x00000053,\n    WGPUTextureFormat_ASTC10x5UnormSrgb = 0x00000054,\n    WGPUTextureFormat_ASTC10x6Unorm = 0x00000055,\n    WGPUTextureFormat_ASTC10x6UnormSrgb = 0x00000056,\n    WGPUTextureFormat_ASTC10x8Unorm = 0x00000057,\n    WGPUTextureFormat_ASTC10x8UnormSrgb = 0x00000058,\n    WGPUTextureFormat_ASTC10x10Unorm = 0x00000059,\n    WGPUTextureFormat_ASTC10x10UnormSrgb = 0x0000005A,\n    WGPUTextureFormat_ASTC12x10Unorm = 0x0000005B,\n    WGPUTextureFormat_ASTC12x10UnormSrgb = 0x0000005C,\n    WGPUTextureFormat_ASTC12x12Unorm = 0x0000005D,\n    WGPUTextureFormat_ASTC12x12UnormSrgb = 0x0000005E,\n    WGPUTextureFormat_R8BG8Biplanar420Unorm = 0x0000005F,\n    WGPUTextureFormat_Force32 = 0x7FFFFFFF\n} WGPUTextureFormat WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureSampleType {\n    WGPUTextureSampleType_Undefined = 0x00000000,\n    WGPUTextureSampleType_Float = 0x00000001,\n    WGPUTextureSampleType_UnfilterableFloat = 0x00000002,\n    WGPUTextureSampleType_Depth = 0x00000003,\n    WGPUTextureSampleType_Sint = 0x00000004,\n    WGPUTextureSampleType_Uint = 0x00000005,\n    WGPUTextureSampleType_Force32 = 0x7FFFFFFF\n} WGPUTextureSampleType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureViewDimension {\n    WGPUTextureViewDimension_Undefined = 0x00000000,\n    WGPUTextureViewDimension_1D = 0x00000001,\n    WGPUTextureViewDimension_2D = 0x00000002,\n    WGPUTextureViewDimension_2DArray = 0x00000003,\n    WGPUTextureViewDimension_Cube = 0x00000004,\n    WGPUTextureViewDimension_CubeArray = 0x00000005,\n    WGPUTextureViewDimension_3D = 0x00000006,\n    WGPUTextureViewDimension_Force32 = 0x7FFFFFFF\n} WGPUTextureViewDimension WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUVertexFormat {\n    WGPUVertexFormat_Undefined = 0x00000000,\n    WGPUVertexFormat_Uint8x2 = 0x00000001,\n    WGPUVertexFormat_Uint8x4 = 0x00000002,\n    WGPUVertexFormat_Sint8x2 = 0x00000003,\n    WGPUVertexFormat_Sint8x4 = 0x00000004,\n    WGPUVertexFormat_Unorm8x2 = 0x00000005,\n    WGPUVertexFormat_Unorm8x4 = 0x00000006,\n    WGPUVertexFormat_Snorm8x2 = 0x00000007,\n    WGPUVertexFormat_Snorm8x4 = 0x00000008,\n    WGPUVertexFormat_Uint16x2 = 0x00000009,\n    WGPUVertexFormat_Uint16x4 = 0x0000000A,\n    WGPUVertexFormat_Sint16x2 = 0x0000000B,\n    WGPUVertexFormat_Sint16x4 = 0x0000000C,\n    WGPUVertexFormat_Unorm16x2 = 0x0000000D,\n    WGPUVertexFormat_Unorm16x4 = 0x0000000E,\n    WGPUVertexFormat_Snorm16x2 = 0x0000000F,\n    WGPUVertexFormat_Snorm16x4 = 0x00000010,\n    WGPUVertexFormat_Float16x2 = 0x00000011,\n    WGPUVertexFormat_Float16x4 = 0x00000012,\n    WGPUVertexFormat_Float32 = 0x00000013,\n    WGPUVertexFormat_Float32x2 = 0x00000014,\n    WGPUVertexFormat_Float32x3 = 0x00000015,\n    WGPUVertexFormat_Float32x4 = 0x00000016,\n    WGPUVertexFormat_Uint32 = 0x00000017,\n    WGPUVertexFormat_Uint32x2 = 0x00000018,\n    WGPUVertexFormat_Uint32x3 = 0x00000019,\n    WGPUVertexFormat_Uint32x4 = 0x0000001A,\n    WGPUVertexFormat_Sint32 = 0x0000001B,\n    WGPUVertexFormat_Sint32x2 = 0x0000001C,\n    WGPUVertexFormat_Sint32x3 = 0x0000001D,\n    WGPUVertexFormat_Sint32x4 = 0x0000001E,\n    WGPUVertexFormat_Force32 = 0x7FFFFFFF\n} WGPUVertexFormat WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUVertexStepMode {\n    WGPUVertexStepMode_Vertex = 0x00000000,\n    WGPUVertexStepMode_Instance = 0x00000001,\n    WGPUVertexStepMode_VertexBufferNotUsed = 0x00000002,\n    WGPUVertexStepMode_Force32 = 0x7FFFFFFF\n} WGPUVertexStepMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferUsage {\n    WGPUBufferUsage_None = 0x00000000,\n    WGPUBufferUsage_MapRead = 0x00000001,\n    WGPUBufferUsage_MapWrite = 0x00000002,\n    WGPUBufferUsage_CopySrc = 0x00000004,\n    WGPUBufferUsage_CopyDst = 0x00000008,\n    WGPUBufferUsage_Index = 0x00000010,\n    WGPUBufferUsage_Vertex = 0x00000020,\n    WGPUBufferUsage_Uniform = 0x00000040,\n    WGPUBufferUsage_Storage = 0x00000080,\n    WGPUBufferUsage_Indirect = 0x00000100,\n    WGPUBufferUsage_QueryResolve = 0x00000200,\n    WGPUBufferUsage_Force32 = 0x7FFFFFFF\n} WGPUBufferUsage WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUBufferUsageFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUColorWriteMask {\n    WGPUColorWriteMask_None = 0x00000000,\n    WGPUColorWriteMask_Red = 0x00000001,\n    WGPUColorWriteMask_Green = 0x00000002,\n    WGPUColorWriteMask_Blue = 0x00000004,\n    WGPUColorWriteMask_Alpha = 0x00000008,\n    WGPUColorWriteMask_All = 0x0000000F,\n    WGPUColorWriteMask_Force32 = 0x7FFFFFFF\n} WGPUColorWriteMask WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUColorWriteMaskFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUMapMode {\n    WGPUMapMode_None = 0x00000000,\n    WGPUMapMode_Read = 0x00000001,\n    WGPUMapMode_Write = 0x00000002,\n    WGPUMapMode_Force32 = 0x7FFFFFFF\n} WGPUMapMode WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUMapModeFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUShaderStage {\n    WGPUShaderStage_None = 0x00000000,\n    WGPUShaderStage_Vertex = 0x00000001,\n    WGPUShaderStage_Fragment = 0x00000002,\n    WGPUShaderStage_Compute = 0x00000004,\n    WGPUShaderStage_Force32 = 0x7FFFFFFF\n} WGPUShaderStage WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUShaderStageFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureUsage {\n    WGPUTextureUsage_None = 0x00000000,\n    WGPUTextureUsage_CopySrc = 0x00000001,\n    WGPUTextureUsage_CopyDst = 0x00000002,\n    WGPUTextureUsage_TextureBinding = 0x00000004,\n    WGPUTextureUsage_StorageBinding = 0x00000008,\n    WGPUTextureUsage_RenderAttachment = 0x00000010,\n    WGPUTextureUsage_TransientAttachment = 0x00000020,\n    WGPUTextureUsage_Force32 = 0x7FFFFFFF\n} WGPUTextureUsage WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUTextureUsageFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef void (*WGPUBufferMapCallback)(WGPUBufferMapAsyncStatus status, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUCompilationInfoCallback)(WGPUCompilationInfoRequestStatus status, struct WGPUCompilationInfo const * compilationInfo, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUCreateComputePipelineAsyncCallback)(WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUCreateRenderPipelineAsyncCallback)(WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUDeviceLostCallback)(WGPUDeviceLostReason reason, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUErrorCallback)(WGPUErrorType type, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPULoggingCallback)(WGPULoggingType type, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProc)(void) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUQueueWorkDoneCallback)(WGPUQueueWorkDoneStatus status, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPURequestAdapterCallback)(WGPURequestAdapterStatus status, WGPUAdapter adapter, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPURequestDeviceCallback)(WGPURequestDeviceStatus status, WGPUDevice device, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\n\ntypedef struct WGPUChainedStruct {\n    struct WGPUChainedStruct const * next;\n    WGPUSType sType;\n} WGPUChainedStruct WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUChainedStructOut {\n    struct WGPUChainedStructOut * next;\n    WGPUSType sType;\n} WGPUChainedStructOut WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUAdapterProperties {\n    WGPUChainedStructOut * nextInChain;\n    uint32_t vendorID;\n    char const * vendorName;\n    char const * architecture;\n    uint32_t deviceID;\n    char const * name;\n    char const * driverDescription;\n    WGPUAdapterType adapterType;\n    WGPUBackendType backendType;\n    WGPUBool compatibilityMode;\n} WGPUAdapterProperties WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupEntry {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t binding;\n    WGPU_NULLABLE WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n    WGPU_NULLABLE WGPUSampler sampler;\n    WGPU_NULLABLE WGPUTextureView textureView;\n} WGPUBindGroupEntry WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBlendComponent {\n    WGPUBlendOperation operation;\n    WGPUBlendFactor srcFactor;\n    WGPUBlendFactor dstFactor;\n} WGPUBlendComponent WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBufferBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUBufferBindingType type;\n    WGPUBool hasDynamicOffset;\n    uint64_t minBindingSize;\n} WGPUBufferBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBufferDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUBufferUsageFlags usage;\n    uint64_t size;\n    WGPUBool mappedAtCreation;\n} WGPUBufferDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUColor {\n    double r;\n    double g;\n    double b;\n    double a;\n} WGPUColor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCommandBufferDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUCommandBufferDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCommandEncoderDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUCommandEncoderDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCompilationMessage {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * message;\n    WGPUCompilationMessageType type;\n    uint64_t lineNum;\n    uint64_t linePos;\n    uint64_t offset;\n    uint64_t length;\n    uint64_t utf16LinePos;\n    uint64_t utf16Offset;\n    uint64_t utf16Length;\n} WGPUCompilationMessage WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUComputePassTimestampWrite {\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n    WGPUComputePassTimestampLocation location;\n} WGPUComputePassTimestampWrite WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUConstantEntry {\n    WGPUChainedStruct const * nextInChain;\n    char const * key;\n    double value;\n} WGPUConstantEntry WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCopyTextureForBrowserOptions {\n    WGPUChainedStruct const * nextInChain;\n    WGPUBool flipY;\n    WGPUBool needsColorSpaceConversion;\n    WGPUAlphaMode srcAlphaMode;\n    WGPU_NULLABLE float const * srcTransferFunctionParameters;\n    WGPU_NULLABLE float const * conversionMatrix;\n    WGPU_NULLABLE float const * dstTransferFunctionParameters;\n    WGPUAlphaMode dstAlphaMode;\n    WGPUBool internalUsage;\n} WGPUCopyTextureForBrowserOptions WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUAdapterProperties\ntypedef struct WGPUDawnAdapterPropertiesPowerPreference {\n    WGPUChainedStructOut chain;\n    WGPUPowerPreference powerPreference;\n} WGPUDawnAdapterPropertiesPowerPreference WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUBufferDescriptor\ntypedef struct WGPUDawnBufferDescriptorErrorInfoFromWireClient {\n    WGPUChainedStruct chain;\n    WGPUBool outOfMemory;\n} WGPUDawnBufferDescriptorErrorInfoFromWireClient WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUDeviceDescriptor\ntypedef struct WGPUDawnCacheDeviceDescriptor {\n    WGPUChainedStruct chain;\n    char const * isolationKey;\n} WGPUDawnCacheDeviceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUCommandEncoderDescriptor\ntypedef struct WGPUDawnEncoderInternalUsageDescriptor {\n    WGPUChainedStruct chain;\n    WGPUBool useInternalUsages;\n} WGPUDawnEncoderInternalUsageDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUMultisampleState\ntypedef struct WGPUDawnMultisampleStateRenderToSingleSampled {\n    WGPUChainedStruct chain;\n    WGPUBool enabled;\n} WGPUDawnMultisampleStateRenderToSingleSampled WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPURenderPassColorAttachment\ntypedef struct WGPUDawnRenderPassColorAttachmentRenderToSingleSampled {\n    WGPUChainedStruct chain;\n    uint32_t implicitSampleCount;\n} WGPUDawnRenderPassColorAttachmentRenderToSingleSampled WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUDawnShaderModuleSPIRVOptionsDescriptor {\n    WGPUChainedStruct chain;\n    WGPUBool allowNonUniformDerivatives;\n} WGPUDawnShaderModuleSPIRVOptionsDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUTextureDescriptor\ntypedef struct WGPUDawnTextureInternalUsageDescriptor {\n    WGPUChainedStruct chain;\n    WGPUTextureUsageFlags internalUsage;\n} WGPUDawnTextureInternalUsageDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUInstanceDescriptor\n// Can be chained in WGPURequestAdapterOptions\n// Can be chained in WGPUDeviceDescriptor\ntypedef struct WGPUDawnTogglesDescriptor {\n    WGPUChainedStruct chain;\n    size_t enabledTogglesCount;\n    const char* const * enabledToggles;\n    size_t disabledTogglesCount;\n    const char* const * disabledToggles;\n} WGPUDawnTogglesDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUExtent2D {\n    uint32_t width;\n    uint32_t height;\n} WGPUExtent2D WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUExtent3D {\n    uint32_t width;\n    uint32_t height;\n    uint32_t depthOrArrayLayers;\n} WGPUExtent3D WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUBindGroupEntry\ntypedef struct WGPUExternalTextureBindingEntry {\n    WGPUChainedStruct chain;\n    WGPUExternalTexture externalTexture;\n} WGPUExternalTextureBindingEntry WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUBindGroupLayoutEntry\ntypedef struct WGPUExternalTextureBindingLayout {\n    WGPUChainedStruct chain;\n} WGPUExternalTextureBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUInstanceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n} WGPUInstanceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPULimits {\n    uint32_t maxTextureDimension1D;\n    uint32_t maxTextureDimension2D;\n    uint32_t maxTextureDimension3D;\n    uint32_t maxTextureArrayLayers;\n    uint32_t maxBindGroups;\n    uint32_t maxBindGroupsPlusVertexBuffers;\n    uint32_t maxBindingsPerBindGroup;\n    uint32_t maxDynamicUniformBuffersPerPipelineLayout;\n    uint32_t maxDynamicStorageBuffersPerPipelineLayout;\n    uint32_t maxSampledTexturesPerShaderStage;\n    uint32_t maxSamplersPerShaderStage;\n    uint32_t maxStorageBuffersPerShaderStage;\n    uint32_t maxStorageTexturesPerShaderStage;\n    uint32_t maxUniformBuffersPerShaderStage;\n    uint64_t maxUniformBufferBindingSize;\n    uint64_t maxStorageBufferBindingSize;\n    uint32_t minUniformBufferOffsetAlignment;\n    uint32_t minStorageBufferOffsetAlignment;\n    uint32_t maxVertexBuffers;\n    uint64_t maxBufferSize;\n    uint32_t maxVertexAttributes;\n    uint32_t maxVertexBufferArrayStride;\n    uint32_t maxInterStageShaderComponents;\n    uint32_t maxInterStageShaderVariables;\n    uint32_t maxColorAttachments;\n    uint32_t maxColorAttachmentBytesPerSample;\n    uint32_t maxComputeWorkgroupStorageSize;\n    uint32_t maxComputeInvocationsPerWorkgroup;\n    uint32_t maxComputeWorkgroupSizeX;\n    uint32_t maxComputeWorkgroupSizeY;\n    uint32_t maxComputeWorkgroupSizeZ;\n    uint32_t maxComputeWorkgroupsPerDimension;\n} WGPULimits WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUMultisampleState {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t count;\n    uint32_t mask;\n    WGPUBool alphaToCoverageEnabled;\n} WGPUMultisampleState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUOrigin2D {\n    uint32_t x;\n    uint32_t y;\n} WGPUOrigin2D WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUOrigin3D {\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n} WGPUOrigin3D WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUPipelineLayoutDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t bindGroupLayoutCount;\n    WGPUBindGroupLayout const * bindGroupLayouts;\n} WGPUPipelineLayoutDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUPrimitiveState\ntypedef struct WGPUPrimitiveDepthClipControl {\n    WGPUChainedStruct chain;\n    WGPUBool unclippedDepth;\n} WGPUPrimitiveDepthClipControl WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUPrimitiveState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUPrimitiveTopology topology;\n    WGPUIndexFormat stripIndexFormat;\n    WGPUFrontFace frontFace;\n    WGPUCullMode cullMode;\n} WGPUPrimitiveState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUQuerySetDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUQueryType type;\n    uint32_t count;\n    WGPUPipelineStatisticName const * pipelineStatistics;\n    size_t pipelineStatisticsCount;\n} WGPUQuerySetDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUQueueDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUQueueDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderBundleDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPURenderBundleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderBundleEncoderDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t colorFormatsCount;\n    WGPUTextureFormat const * colorFormats;\n    WGPUTextureFormat depthStencilFormat;\n    uint32_t sampleCount;\n    WGPUBool depthReadOnly;\n    WGPUBool stencilReadOnly;\n} WGPURenderBundleEncoderDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassDepthStencilAttachment {\n    WGPUTextureView view;\n    WGPULoadOp depthLoadOp;\n    WGPUStoreOp depthStoreOp;\n    float depthClearValue;\n    WGPUBool depthReadOnly;\n    WGPULoadOp stencilLoadOp;\n    WGPUStoreOp stencilStoreOp;\n    uint32_t stencilClearValue;\n    WGPUBool stencilReadOnly;\n} WGPURenderPassDepthStencilAttachment WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPURenderPassDescriptor\ntypedef struct WGPURenderPassDescriptorMaxDrawCount {\n    WGPUChainedStruct chain;\n    uint64_t maxDrawCount;\n} WGPURenderPassDescriptorMaxDrawCount WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassTimestampWrite {\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n    WGPURenderPassTimestampLocation location;\n} WGPURenderPassTimestampWrite WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURequestAdapterOptions {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE WGPUSurface compatibleSurface;\n    WGPUPowerPreference powerPreference;\n    WGPUBackendType backendType;\n    WGPUBool forceFallbackAdapter;\n    WGPUBool compatibilityMode;\n} WGPURequestAdapterOptions WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSamplerBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUSamplerBindingType type;\n} WGPUSamplerBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSamplerDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUAddressMode addressModeU;\n    WGPUAddressMode addressModeV;\n    WGPUAddressMode addressModeW;\n    WGPUFilterMode magFilter;\n    WGPUFilterMode minFilter;\n    WGPUMipmapFilterMode mipmapFilter;\n    float lodMinClamp;\n    float lodMaxClamp;\n    WGPUCompareFunction compare;\n    uint16_t maxAnisotropy;\n} WGPUSamplerDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUShaderModuleDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUShaderModuleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUShaderModuleSPIRVDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t codeSize;\n    uint32_t const * code;\n} WGPUShaderModuleSPIRVDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUShaderModuleWGSLDescriptor {\n    WGPUChainedStruct chain;\n    char const * code;\n} WGPUShaderModuleWGSLDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSharedFenceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUSharedFenceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceDescriptor\ntypedef struct WGPUSharedFenceDXGISharedHandleDescriptor {\n    WGPUChainedStruct chain;\n    void * handle;\n} WGPUSharedFenceDXGISharedHandleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceExportInfo\ntypedef struct WGPUSharedFenceDXGISharedHandleExportInfo {\n    WGPUChainedStructOut chain;\n    void * handle;\n} WGPUSharedFenceDXGISharedHandleExportInfo WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSharedFenceExportInfo {\n    WGPUChainedStructOut * nextInChain;\n    WGPUSharedFenceType type;\n} WGPUSharedFenceExportInfo WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceDescriptor\ntypedef struct WGPUSharedFenceMTLSharedEventDescriptor {\n    WGPUChainedStruct chain;\n    void * sharedEvent;\n} WGPUSharedFenceMTLSharedEventDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceExportInfo\ntypedef struct WGPUSharedFenceMTLSharedEventExportInfo {\n    WGPUChainedStructOut chain;\n    void * sharedEvent;\n} WGPUSharedFenceMTLSharedEventExportInfo WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceDescriptor\ntypedef struct WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor {\n    WGPUChainedStruct chain;\n    int handle;\n} WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceExportInfo\ntypedef struct WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo {\n    WGPUChainedStructOut chain;\n    int handle;\n} WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceDescriptor\ntypedef struct WGPUSharedFenceVkSemaphoreSyncFDDescriptor {\n    WGPUChainedStruct chain;\n    int handle;\n} WGPUSharedFenceVkSemaphoreSyncFDDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceExportInfo\ntypedef struct WGPUSharedFenceVkSemaphoreSyncFDExportInfo {\n    WGPUChainedStructOut chain;\n    int handle;\n} WGPUSharedFenceVkSemaphoreSyncFDExportInfo WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceDescriptor\ntypedef struct WGPUSharedFenceVkSemaphoreZirconHandleDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t handle;\n} WGPUSharedFenceVkSemaphoreZirconHandleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedFenceExportInfo\ntypedef struct WGPUSharedFenceVkSemaphoreZirconHandleExportInfo {\n    WGPUChainedStructOut chain;\n    uint32_t handle;\n} WGPUSharedFenceVkSemaphoreZirconHandleExportInfo WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryAHardwareBufferDescriptor {\n    WGPUChainedStruct chain;\n    void * handle;\n} WGPUSharedTextureMemoryAHardwareBufferDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSharedTextureMemoryBeginAccessDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPUBool initialized;\n    size_t fenceCount;\n    WGPUSharedFence const * fences;\n    uint64_t const * signaledValues;\n} WGPUSharedTextureMemoryBeginAccessDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSharedTextureMemoryDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUSharedTextureMemoryDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryDmaBufDescriptor {\n    WGPUChainedStruct chain;\n    int memoryFD;\n    uint64_t allocationSize;\n    uint64_t drmModifier;\n    size_t planeCount;\n    uint64_t const * planeOffsets;\n    uint32_t const * planeStrides;\n} WGPUSharedTextureMemoryDmaBufDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryDXGISharedHandleDescriptor {\n    WGPUChainedStruct chain;\n    void * handle;\n} WGPUSharedTextureMemoryDXGISharedHandleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryEGLImageDescriptor {\n    WGPUChainedStruct chain;\n    void * image;\n} WGPUSharedTextureMemoryEGLImageDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSharedTextureMemoryEndAccessState {\n    WGPUChainedStructOut * nextInChain;\n    WGPUBool initialized;\n    size_t fenceCount;\n    WGPUSharedFence const * fences;\n    uint64_t const * signaledValues;\n} WGPUSharedTextureMemoryEndAccessState WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryIOSurfaceDescriptor {\n    WGPUChainedStruct chain;\n    void * ioSurface;\n} WGPUSharedTextureMemoryIOSurfaceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryOpaqueFDDescriptor {\n    WGPUChainedStruct chain;\n    int memoryFD;\n    uint64_t allocationSize;\n} WGPUSharedTextureMemoryOpaqueFDDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor {\n    WGPUChainedStruct chain;\n    WGPUBool dedicatedAllocation;\n} WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryBeginAccessDescriptor\ntypedef struct WGPUSharedTextureMemoryVkImageLayoutBeginState {\n    WGPUChainedStruct chain;\n    int32_t oldLayout;\n    int32_t newLayout;\n} WGPUSharedTextureMemoryVkImageLayoutBeginState WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryEndAccessState\ntypedef struct WGPUSharedTextureMemoryVkImageLayoutEndState {\n    WGPUChainedStructOut chain;\n    int32_t oldLayout;\n    int32_t newLayout;\n} WGPUSharedTextureMemoryVkImageLayoutEndState WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryZirconHandleDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t memoryFD;\n    uint64_t allocationSize;\n} WGPUSharedTextureMemoryZirconHandleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUStencilFaceState {\n    WGPUCompareFunction compare;\n    WGPUStencilOperation failOp;\n    WGPUStencilOperation depthFailOp;\n    WGPUStencilOperation passOp;\n} WGPUStencilFaceState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUStorageTextureBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUStorageTextureAccess access;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension viewDimension;\n} WGPUStorageTextureBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSurfaceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUSurfaceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromAndroidNativeWindow {\n    WGPUChainedStruct chain;\n    void * window;\n} WGPUSurfaceDescriptorFromAndroidNativeWindow WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromCanvasHTMLSelector {\n    WGPUChainedStruct chain;\n    char const * selector;\n} WGPUSurfaceDescriptorFromCanvasHTMLSelector WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromMetalLayer {\n    WGPUChainedStruct chain;\n    void * layer;\n} WGPUSurfaceDescriptorFromMetalLayer WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWaylandSurface {\n    WGPUChainedStruct chain;\n    void * display;\n    void * surface;\n} WGPUSurfaceDescriptorFromWaylandSurface WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWindowsCoreWindow {\n    WGPUChainedStruct chain;\n    void * coreWindow;\n} WGPUSurfaceDescriptorFromWindowsCoreWindow WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWindowsHWND {\n    WGPUChainedStruct chain;\n    void * hinstance;\n    void * hwnd;\n} WGPUSurfaceDescriptorFromWindowsHWND WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWindowsSwapChainPanel {\n    WGPUChainedStruct chain;\n    void * swapChainPanel;\n} WGPUSurfaceDescriptorFromWindowsSwapChainPanel WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromXlibWindow {\n    WGPUChainedStruct chain;\n    void * display;\n    uint32_t window;\n} WGPUSurfaceDescriptorFromXlibWindow WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSwapChainDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureUsageFlags usage;\n    WGPUTextureFormat format;\n    uint32_t width;\n    uint32_t height;\n    WGPUPresentMode presentMode;\n} WGPUSwapChainDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureSampleType sampleType;\n    WGPUTextureViewDimension viewDimension;\n    WGPUBool multisampled;\n} WGPUTextureBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureDataLayout {\n    WGPUChainedStruct const * nextInChain;\n    uint64_t offset;\n    uint32_t bytesPerRow;\n    uint32_t rowsPerImage;\n} WGPUTextureDataLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureViewDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension dimension;\n    uint32_t baseMipLevel;\n    uint32_t mipLevelCount;\n    uint32_t baseArrayLayer;\n    uint32_t arrayLayerCount;\n    WGPUTextureAspect aspect;\n} WGPUTextureViewDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUVertexAttribute {\n    WGPUVertexFormat format;\n    uint64_t offset;\n    uint32_t shaderLocation;\n} WGPUVertexAttribute WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUBindGroupLayout layout;\n    size_t entryCount;\n    WGPUBindGroupEntry const * entries;\n} WGPUBindGroupDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupLayoutEntry {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t binding;\n    WGPUShaderStageFlags visibility;\n    WGPUBufferBindingLayout buffer;\n    WGPUSamplerBindingLayout sampler;\n    WGPUTextureBindingLayout texture;\n    WGPUStorageTextureBindingLayout storageTexture;\n} WGPUBindGroupLayoutEntry WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBlendState {\n    WGPUBlendComponent color;\n    WGPUBlendComponent alpha;\n} WGPUBlendState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCompilationInfo {\n    WGPUChainedStruct const * nextInChain;\n    size_t messageCount;\n    WGPUCompilationMessage const * messages;\n} WGPUCompilationInfo WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUComputePassDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t timestampWriteCount;\n    WGPUComputePassTimestampWrite const * timestampWrites;\n} WGPUComputePassDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUDepthStencilState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureFormat format;\n    WGPUBool depthWriteEnabled;\n    WGPUCompareFunction depthCompare;\n    WGPUStencilFaceState stencilFront;\n    WGPUStencilFaceState stencilBack;\n    uint32_t stencilReadMask;\n    uint32_t stencilWriteMask;\n    int32_t depthBias;\n    float depthBiasSlopeScale;\n    float depthBiasClamp;\n} WGPUDepthStencilState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUExternalTextureDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureView plane0;\n    WGPU_NULLABLE WGPUTextureView plane1;\n    WGPUOrigin2D visibleOrigin;\n    WGPUExtent2D visibleSize;\n    WGPUBool doYuvToRgbConversionOnly;\n    WGPU_NULLABLE float const * yuvToRgbConversionMatrix;\n    float const * srcTransferFunctionParameters;\n    float const * dstTransferFunctionParameters;\n    float const * gamutConversionMatrix;\n    WGPUBool flipY;\n    WGPUExternalTextureRotation rotation;\n} WGPUExternalTextureDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUImageCopyBuffer {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureDataLayout layout;\n    WGPUBuffer buffer;\n} WGPUImageCopyBuffer WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUImageCopyExternalTexture {\n    WGPUChainedStruct const * nextInChain;\n    WGPUExternalTexture externalTexture;\n    WGPUOrigin3D origin;\n    WGPUExtent2D naturalSize;\n} WGPUImageCopyExternalTexture WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUImageCopyTexture {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTexture texture;\n    uint32_t mipLevel;\n    WGPUOrigin3D origin;\n    WGPUTextureAspect aspect;\n} WGPUImageCopyTexture WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUProgrammableStageDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    size_t constantCount;\n    WGPUConstantEntry const * constants;\n} WGPUProgrammableStageDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassColorAttachment {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE WGPUTextureView view;\n    WGPU_NULLABLE WGPUTextureView resolveTarget;\n    WGPULoadOp loadOp;\n    WGPUStoreOp storeOp;\n    WGPUColor clearValue;\n} WGPURenderPassColorAttachment WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURequiredLimits {\n    WGPUChainedStruct const * nextInChain;\n    WGPULimits limits;\n} WGPURequiredLimits WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSharedTextureMemoryProperties {\n    WGPUChainedStructOut * nextInChain;\n    WGPUTextureUsageFlags usage;\n    WGPUExtent3D size;\n    WGPUTextureFormat format;\n} WGPUSharedTextureMemoryProperties WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSharedTextureMemoryDescriptor\ntypedef struct WGPUSharedTextureMemoryVkImageDescriptor {\n    WGPUChainedStruct chain;\n    int32_t vkFormat;\n    int32_t vkUsageFlags;\n    WGPUExtent3D vkExtent3D;\n} WGPUSharedTextureMemoryVkImageDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSupportedLimits {\n    WGPUChainedStructOut * nextInChain;\n    WGPULimits limits;\n} WGPUSupportedLimits WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureUsageFlags usage;\n    WGPUTextureDimension dimension;\n    WGPUExtent3D size;\n    WGPUTextureFormat format;\n    uint32_t mipLevelCount;\n    uint32_t sampleCount;\n    size_t viewFormatCount;\n    WGPUTextureFormat const * viewFormats;\n} WGPUTextureDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUVertexBufferLayout {\n    uint64_t arrayStride;\n    WGPUVertexStepMode stepMode;\n    size_t attributeCount;\n    WGPUVertexAttribute const * attributes;\n} WGPUVertexBufferLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupLayoutDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t entryCount;\n    WGPUBindGroupLayoutEntry const * entries;\n} WGPUBindGroupLayoutDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUColorTargetState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureFormat format;\n    WGPU_NULLABLE WGPUBlendState const * blend;\n    WGPUColorWriteMaskFlags writeMask;\n} WGPUColorTargetState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUComputePipelineDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPU_NULLABLE WGPUPipelineLayout layout;\n    WGPUProgrammableStageDescriptor compute;\n} WGPUComputePipelineDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUDeviceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t requiredFeaturesCount;\n    WGPUFeatureName const * requiredFeatures;\n    WGPU_NULLABLE WGPURequiredLimits const * requiredLimits;\n    WGPUQueueDescriptor defaultQueue;\n    WGPUDeviceLostCallback deviceLostCallback;\n    void * deviceLostUserdata;\n} WGPUDeviceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t colorAttachmentCount;\n    WGPURenderPassColorAttachment const * colorAttachments;\n    WGPU_NULLABLE WGPURenderPassDepthStencilAttachment const * depthStencilAttachment;\n    WGPU_NULLABLE WGPUQuerySet occlusionQuerySet;\n    size_t timestampWriteCount;\n    WGPURenderPassTimestampWrite const * timestampWrites;\n} WGPURenderPassDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUVertexState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    size_t constantCount;\n    WGPUConstantEntry const * constants;\n    size_t bufferCount;\n    WGPUVertexBufferLayout const * buffers;\n} WGPUVertexState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUFragmentState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    size_t constantCount;\n    WGPUConstantEntry const * constants;\n    size_t targetCount;\n    WGPUColorTargetState const * targets;\n} WGPUFragmentState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPipelineDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPU_NULLABLE WGPUPipelineLayout layout;\n    WGPUVertexState vertex;\n    WGPUPrimitiveState primitive;\n    WGPU_NULLABLE WGPUDepthStencilState const * depthStencil;\n    WGPUMultisampleState multisample;\n    WGPU_NULLABLE WGPUFragmentState const * fragment;\n} WGPURenderPipelineDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if !defined(WGPU_SKIP_PROCS)\n\ntypedef void (*WGPUProcAdapterPropertiesFreeMembers)(WGPUAdapterProperties value) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUInstance (*WGPUProcCreateInstance)(WGPUInstanceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUProc (*WGPUProcGetProcAddress)(WGPUDevice device, char const * procName) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedTextureMemoryEndAccessStateFreeMembers)(WGPUSharedTextureMemoryEndAccessState value) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Adapter\ntypedef WGPUDevice (*WGPUProcAdapterCreateDevice)(WGPUAdapter adapter, WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef size_t (*WGPUProcAdapterEnumerateFeatures)(WGPUAdapter adapter, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUInstance (*WGPUProcAdapterGetInstance)(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBool (*WGPUProcAdapterGetLimits)(WGPUAdapter adapter, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterGetProperties)(WGPUAdapter adapter, WGPUAdapterProperties * properties) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBool (*WGPUProcAdapterHasFeature)(WGPUAdapter adapter, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterRequestDevice)(WGPUAdapter adapter, WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterReference)(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterRelease)(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of BindGroup\ntypedef void (*WGPUProcBindGroupSetLabel)(WGPUBindGroup bindGroup, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupReference)(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupRelease)(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of BindGroupLayout\ntypedef void (*WGPUProcBindGroupLayoutSetLabel)(WGPUBindGroupLayout bindGroupLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupLayoutReference)(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupLayoutRelease)(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Buffer\ntypedef void (*WGPUProcBufferDestroy)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void const * (*WGPUProcBufferGetConstMappedRange)(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBufferMapState (*WGPUProcBufferGetMapState)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void * (*WGPUProcBufferGetMappedRange)(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint64_t (*WGPUProcBufferGetSize)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBufferUsageFlags (*WGPUProcBufferGetUsage)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferMapAsync)(WGPUBuffer buffer, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferSetLabel)(WGPUBuffer buffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferUnmap)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferReference)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferRelease)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of CommandBuffer\ntypedef void (*WGPUProcCommandBufferSetLabel)(WGPUCommandBuffer commandBuffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandBufferReference)(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandBufferRelease)(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of CommandEncoder\ntypedef WGPUComputePassEncoder (*WGPUProcCommandEncoderBeginComputePass)(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUComputePassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderPassEncoder (*WGPUProcCommandEncoderBeginRenderPass)(WGPUCommandEncoder commandEncoder, WGPURenderPassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderClearBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyBufferToBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyBufferToTexture)(WGPUCommandEncoder commandEncoder, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyTextureToBuffer)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyTextureToTexture)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUCommandBuffer (*WGPUProcCommandEncoderFinish)(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUCommandBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderInjectValidationError)(WGPUCommandEncoder commandEncoder, char const * message) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderInsertDebugMarker)(WGPUCommandEncoder commandEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderPopDebugGroup)(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderPushDebugGroup)(WGPUCommandEncoder commandEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderResolveQuerySet)(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderSetLabel)(WGPUCommandEncoder commandEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderWriteBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderWriteTimestamp)(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderReference)(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderRelease)(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ComputePassEncoder\ntypedef void (*WGPUProcComputePassEncoderDispatchWorkgroups)(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderDispatchWorkgroupsIndirect)(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderEnd)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderInsertDebugMarker)(WGPUComputePassEncoder computePassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderPopDebugGroup)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderPushDebugGroup)(WGPUComputePassEncoder computePassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderSetBindGroup)(WGPUComputePassEncoder computePassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderSetLabel)(WGPUComputePassEncoder computePassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderSetPipeline)(WGPUComputePassEncoder computePassEncoder, WGPUComputePipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderWriteTimestamp)(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderReference)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderRelease)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ComputePipeline\ntypedef WGPUBindGroupLayout (*WGPUProcComputePipelineGetBindGroupLayout)(WGPUComputePipeline computePipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePipelineSetLabel)(WGPUComputePipeline computePipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePipelineReference)(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePipelineRelease)(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Device\ntypedef WGPUBindGroup (*WGPUProcDeviceCreateBindGroup)(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBindGroupLayout (*WGPUProcDeviceCreateBindGroupLayout)(WGPUDevice device, WGPUBindGroupLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBuffer (*WGPUProcDeviceCreateBuffer)(WGPUDevice device, WGPUBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUCommandEncoder (*WGPUProcDeviceCreateCommandEncoder)(WGPUDevice device, WGPU_NULLABLE WGPUCommandEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUComputePipeline (*WGPUProcDeviceCreateComputePipeline)(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceCreateComputePipelineAsync)(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBuffer (*WGPUProcDeviceCreateErrorBuffer)(WGPUDevice device, WGPUBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUExternalTexture (*WGPUProcDeviceCreateErrorExternalTexture)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUShaderModule (*WGPUProcDeviceCreateErrorShaderModule)(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor, char const * errorMessage) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTexture (*WGPUProcDeviceCreateErrorTexture)(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUExternalTexture (*WGPUProcDeviceCreateExternalTexture)(WGPUDevice device, WGPUExternalTextureDescriptor const * externalTextureDescriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUPipelineLayout (*WGPUProcDeviceCreatePipelineLayout)(WGPUDevice device, WGPUPipelineLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUQuerySet (*WGPUProcDeviceCreateQuerySet)(WGPUDevice device, WGPUQuerySetDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderBundleEncoder (*WGPUProcDeviceCreateRenderBundleEncoder)(WGPUDevice device, WGPURenderBundleEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderPipeline (*WGPUProcDeviceCreateRenderPipeline)(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceCreateRenderPipelineAsync)(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUSampler (*WGPUProcDeviceCreateSampler)(WGPUDevice device, WGPU_NULLABLE WGPUSamplerDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUShaderModule (*WGPUProcDeviceCreateShaderModule)(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUSwapChain (*WGPUProcDeviceCreateSwapChain)(WGPUDevice device, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTexture (*WGPUProcDeviceCreateTexture)(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceDestroy)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef size_t (*WGPUProcDeviceEnumerateFeatures)(WGPUDevice device, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceForceLoss)(WGPUDevice device, WGPUDeviceLostReason type, char const * message) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUAdapter (*WGPUProcDeviceGetAdapter)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBool (*WGPUProcDeviceGetLimits)(WGPUDevice device, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUQueue (*WGPUProcDeviceGetQueue)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureUsageFlags (*WGPUProcDeviceGetSupportedSurfaceUsage)(WGPUDevice device, WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBool (*WGPUProcDeviceHasFeature)(WGPUDevice device, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUSharedFence (*WGPUProcDeviceImportSharedFence)(WGPUDevice device, WGPUSharedFenceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUSharedTextureMemory (*WGPUProcDeviceImportSharedTextureMemory)(WGPUDevice device, WGPUSharedTextureMemoryDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceInjectError)(WGPUDevice device, WGPUErrorType type, char const * message) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDevicePopErrorScope)(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDevicePushErrorScope)(WGPUDevice device, WGPUErrorFilter filter) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceSetDeviceLostCallback)(WGPUDevice device, WGPUDeviceLostCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceSetLabel)(WGPUDevice device, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceSetLoggingCallback)(WGPUDevice device, WGPULoggingCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceSetUncapturedErrorCallback)(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceTick)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceValidateTextureDescriptor)(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceReference)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceRelease)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ExternalTexture\ntypedef void (*WGPUProcExternalTextureDestroy)(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcExternalTextureExpire)(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcExternalTextureRefresh)(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcExternalTextureSetLabel)(WGPUExternalTexture externalTexture, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcExternalTextureReference)(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcExternalTextureRelease)(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Instance\ntypedef WGPUSurface (*WGPUProcInstanceCreateSurface)(WGPUInstance instance, WGPUSurfaceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceProcessEvents)(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceRequestAdapter)(WGPUInstance instance, WGPU_NULLABLE WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceReference)(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceRelease)(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of PipelineLayout\ntypedef void (*WGPUProcPipelineLayoutSetLabel)(WGPUPipelineLayout pipelineLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcPipelineLayoutReference)(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcPipelineLayoutRelease)(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of QuerySet\ntypedef void (*WGPUProcQuerySetDestroy)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcQuerySetGetCount)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUQueryType (*WGPUProcQuerySetGetType)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQuerySetSetLabel)(WGPUQuerySet querySet, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQuerySetReference)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQuerySetRelease)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Queue\ntypedef void (*WGPUProcQueueCopyExternalTextureForBrowser)(WGPUQueue queue, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueCopyTextureForBrowser)(WGPUQueue queue, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueOnSubmittedWorkDone)(WGPUQueue queue, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueSetLabel)(WGPUQueue queue, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueSubmit)(WGPUQueue queue, size_t commandCount, WGPUCommandBuffer const * commands) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueWriteBuffer)(WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueWriteTexture)(WGPUQueue queue, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueReference)(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueRelease)(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderBundle\ntypedef void (*WGPUProcRenderBundleSetLabel)(WGPURenderBundle renderBundle, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleReference)(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleRelease)(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderBundleEncoder\ntypedef void (*WGPUProcRenderBundleEncoderDraw)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndexed)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndexedIndirect)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndirect)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderBundle (*WGPUProcRenderBundleEncoderFinish)(WGPURenderBundleEncoder renderBundleEncoder, WGPU_NULLABLE WGPURenderBundleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderInsertDebugMarker)(WGPURenderBundleEncoder renderBundleEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderPopDebugGroup)(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderPushDebugGroup)(WGPURenderBundleEncoder renderBundleEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetBindGroup)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetIndexBuffer)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetLabel)(WGPURenderBundleEncoder renderBundleEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetPipeline)(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetVertexBuffer)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderReference)(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderRelease)(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderPassEncoder\ntypedef void (*WGPUProcRenderPassEncoderBeginOcclusionQuery)(WGPURenderPassEncoder renderPassEncoder, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDraw)(WGPURenderPassEncoder renderPassEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDrawIndexed)(WGPURenderPassEncoder renderPassEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDrawIndexedIndirect)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDrawIndirect)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderEnd)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderEndOcclusionQuery)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderExecuteBundles)(WGPURenderPassEncoder renderPassEncoder, size_t bundleCount, WGPURenderBundle const * bundles) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderInsertDebugMarker)(WGPURenderPassEncoder renderPassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderPopDebugGroup)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderPushDebugGroup)(WGPURenderPassEncoder renderPassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetBindGroup)(WGPURenderPassEncoder renderPassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetBlendConstant)(WGPURenderPassEncoder renderPassEncoder, WGPUColor const * color) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetIndexBuffer)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetLabel)(WGPURenderPassEncoder renderPassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetPipeline)(WGPURenderPassEncoder renderPassEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetScissorRect)(WGPURenderPassEncoder renderPassEncoder, uint32_t x, uint32_t y, uint32_t width, uint32_t height) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetStencilReference)(WGPURenderPassEncoder renderPassEncoder, uint32_t reference) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetVertexBuffer)(WGPURenderPassEncoder renderPassEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetViewport)(WGPURenderPassEncoder renderPassEncoder, float x, float y, float width, float height, float minDepth, float maxDepth) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderWriteTimestamp)(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderReference)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderRelease)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderPipeline\ntypedef WGPUBindGroupLayout (*WGPUProcRenderPipelineGetBindGroupLayout)(WGPURenderPipeline renderPipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPipelineSetLabel)(WGPURenderPipeline renderPipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPipelineReference)(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPipelineRelease)(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Sampler\ntypedef void (*WGPUProcSamplerSetLabel)(WGPUSampler sampler, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSamplerReference)(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSamplerRelease)(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ShaderModule\ntypedef void (*WGPUProcShaderModuleGetCompilationInfo)(WGPUShaderModule shaderModule, WGPUCompilationInfoCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcShaderModuleSetLabel)(WGPUShaderModule shaderModule, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcShaderModuleReference)(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcShaderModuleRelease)(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of SharedFence\ntypedef void (*WGPUProcSharedFenceExportInfo)(WGPUSharedFence sharedFence, WGPUSharedFenceExportInfo * info) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedFenceReference)(WGPUSharedFence sharedFence) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedFenceRelease)(WGPUSharedFence sharedFence) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of SharedTextureMemory\ntypedef void (*WGPUProcSharedTextureMemoryBeginAccess)(WGPUSharedTextureMemory sharedTextureMemory, WGPUTexture texture, WGPUSharedTextureMemoryBeginAccessDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTexture (*WGPUProcSharedTextureMemoryCreateTexture)(WGPUSharedTextureMemory sharedTextureMemory, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedTextureMemoryEndAccess)(WGPUSharedTextureMemory sharedTextureMemory, WGPUTexture texture, WGPUSharedTextureMemoryEndAccessState * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedTextureMemoryGetProperties)(WGPUSharedTextureMemory sharedTextureMemory, WGPUSharedTextureMemoryProperties * properties) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedTextureMemorySetLabel)(WGPUSharedTextureMemory sharedTextureMemory, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedTextureMemoryReference)(WGPUSharedTextureMemory sharedTextureMemory) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSharedTextureMemoryRelease)(WGPUSharedTextureMemory sharedTextureMemory) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Surface\ntypedef void (*WGPUProcSurfaceReference)(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSurfaceRelease)(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of SwapChain\ntypedef WGPUTexture (*WGPUProcSwapChainGetCurrentTexture)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureView (*WGPUProcSwapChainGetCurrentTextureView)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSwapChainPresent)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSwapChainReference)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSwapChainRelease)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Texture\ntypedef WGPUTextureView (*WGPUProcTextureCreateView)(WGPUTexture texture, WGPU_NULLABLE WGPUTextureViewDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureDestroy)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetDepthOrArrayLayers)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureDimension (*WGPUProcTextureGetDimension)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureFormat (*WGPUProcTextureGetFormat)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetHeight)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetMipLevelCount)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetSampleCount)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureUsageFlags (*WGPUProcTextureGetUsage)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetWidth)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureSetLabel)(WGPUTexture texture, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureReference)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureRelease)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of TextureView\ntypedef void (*WGPUProcTextureViewSetLabel)(WGPUTextureView textureView, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureViewReference)(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureViewRelease)(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\n\n\n#endif  // !defined(WGPU_SKIP_PROCS)\n\n#if !defined(WGPU_SKIP_DECLARATIONS)\n\nWGPU_EXPORT void wgpuAdapterPropertiesFreeMembers(WGPUAdapterProperties value) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUInstance wgpuCreateInstance(WGPUInstanceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUProc wgpuGetProcAddress(WGPUDevice device, char const * procName) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedTextureMemoryEndAccessStateFreeMembers(WGPUSharedTextureMemoryEndAccessState value) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Adapter\nWGPU_EXPORT WGPUDevice wgpuAdapterCreateDevice(WGPUAdapter adapter, WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT size_t wgpuAdapterEnumerateFeatures(WGPUAdapter adapter, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUInstance wgpuAdapterGetInstance(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBool wgpuAdapterGetLimits(WGPUAdapter adapter, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterGetProperties(WGPUAdapter adapter, WGPUAdapterProperties * properties) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBool wgpuAdapterHasFeature(WGPUAdapter adapter, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterRequestDevice(WGPUAdapter adapter, WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterReference(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterRelease(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of BindGroup\nWGPU_EXPORT void wgpuBindGroupSetLabel(WGPUBindGroup bindGroup, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupReference(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupRelease(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of BindGroupLayout\nWGPU_EXPORT void wgpuBindGroupLayoutSetLabel(WGPUBindGroupLayout bindGroupLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupLayoutReference(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupLayoutRelease(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Buffer\nWGPU_EXPORT void wgpuBufferDestroy(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void const * wgpuBufferGetConstMappedRange(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBufferMapState wgpuBufferGetMapState(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void * wgpuBufferGetMappedRange(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint64_t wgpuBufferGetSize(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBufferUsageFlags wgpuBufferGetUsage(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferMapAsync(WGPUBuffer buffer, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferSetLabel(WGPUBuffer buffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferUnmap(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferReference(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferRelease(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of CommandBuffer\nWGPU_EXPORT void wgpuCommandBufferSetLabel(WGPUCommandBuffer commandBuffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandBufferReference(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandBufferRelease(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of CommandEncoder\nWGPU_EXPORT WGPUComputePassEncoder wgpuCommandEncoderBeginComputePass(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUComputePassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderPassEncoder wgpuCommandEncoderBeginRenderPass(WGPUCommandEncoder commandEncoder, WGPURenderPassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderClearBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyBufferToTexture(WGPUCommandEncoder commandEncoder, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToTexture(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUCommandBuffer wgpuCommandEncoderFinish(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUCommandBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderInjectValidationError(WGPUCommandEncoder commandEncoder, char const * message) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderInsertDebugMarker(WGPUCommandEncoder commandEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderPopDebugGroup(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderPushDebugGroup(WGPUCommandEncoder commandEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderResolveQuerySet(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderSetLabel(WGPUCommandEncoder commandEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderWriteBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderWriteTimestamp(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderReference(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderRelease(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ComputePassEncoder\nWGPU_EXPORT void wgpuComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderEnd(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder computePassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderPopDebugGroup(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderPushDebugGroup(WGPUComputePassEncoder computePassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderSetBindGroup(WGPUComputePassEncoder computePassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderSetLabel(WGPUComputePassEncoder computePassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderSetPipeline(WGPUComputePassEncoder computePassEncoder, WGPUComputePipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderWriteTimestamp(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderReference(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderRelease(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ComputePipeline\nWGPU_EXPORT WGPUBindGroupLayout wgpuComputePipelineGetBindGroupLayout(WGPUComputePipeline computePipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePipelineSetLabel(WGPUComputePipeline computePipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePipelineReference(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePipelineRelease(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Device\nWGPU_EXPORT WGPUBindGroup wgpuDeviceCreateBindGroup(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBindGroupLayout wgpuDeviceCreateBindGroupLayout(WGPUDevice device, WGPUBindGroupLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBuffer wgpuDeviceCreateBuffer(WGPUDevice device, WGPUBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUCommandEncoder wgpuDeviceCreateCommandEncoder(WGPUDevice device, WGPU_NULLABLE WGPUCommandEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUComputePipeline wgpuDeviceCreateComputePipeline(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceCreateComputePipelineAsync(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBuffer wgpuDeviceCreateErrorBuffer(WGPUDevice device, WGPUBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUExternalTexture wgpuDeviceCreateErrorExternalTexture(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUShaderModule wgpuDeviceCreateErrorShaderModule(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor, char const * errorMessage) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTexture wgpuDeviceCreateErrorTexture(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUExternalTexture wgpuDeviceCreateExternalTexture(WGPUDevice device, WGPUExternalTextureDescriptor const * externalTextureDescriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUPipelineLayout wgpuDeviceCreatePipelineLayout(WGPUDevice device, WGPUPipelineLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUQuerySet wgpuDeviceCreateQuerySet(WGPUDevice device, WGPUQuerySetDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderBundleEncoder wgpuDeviceCreateRenderBundleEncoder(WGPUDevice device, WGPURenderBundleEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderPipeline wgpuDeviceCreateRenderPipeline(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceCreateRenderPipelineAsync(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUSampler wgpuDeviceCreateSampler(WGPUDevice device, WGPU_NULLABLE WGPUSamplerDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUShaderModule wgpuDeviceCreateShaderModule(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUSwapChain wgpuDeviceCreateSwapChain(WGPUDevice device, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTexture wgpuDeviceCreateTexture(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceDestroy(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT size_t wgpuDeviceEnumerateFeatures(WGPUDevice device, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceForceLoss(WGPUDevice device, WGPUDeviceLostReason type, char const * message) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUAdapter wgpuDeviceGetAdapter(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBool wgpuDeviceGetLimits(WGPUDevice device, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUQueue wgpuDeviceGetQueue(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureUsageFlags wgpuDeviceGetSupportedSurfaceUsage(WGPUDevice device, WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBool wgpuDeviceHasFeature(WGPUDevice device, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUSharedFence wgpuDeviceImportSharedFence(WGPUDevice device, WGPUSharedFenceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUSharedTextureMemory wgpuDeviceImportSharedTextureMemory(WGPUDevice device, WGPUSharedTextureMemoryDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceInjectError(WGPUDevice device, WGPUErrorType type, char const * message) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDevicePopErrorScope(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDevicePushErrorScope(WGPUDevice device, WGPUErrorFilter filter) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceSetDeviceLostCallback(WGPUDevice device, WGPUDeviceLostCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceSetLabel(WGPUDevice device, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceSetLoggingCallback(WGPUDevice device, WGPULoggingCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceSetUncapturedErrorCallback(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceTick(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceValidateTextureDescriptor(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceReference(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceRelease(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ExternalTexture\nWGPU_EXPORT void wgpuExternalTextureDestroy(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuExternalTextureExpire(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuExternalTextureRefresh(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuExternalTextureSetLabel(WGPUExternalTexture externalTexture, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuExternalTextureReference(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuExternalTextureRelease(WGPUExternalTexture externalTexture) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Instance\nWGPU_EXPORT WGPUSurface wgpuInstanceCreateSurface(WGPUInstance instance, WGPUSurfaceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceProcessEvents(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceRequestAdapter(WGPUInstance instance, WGPU_NULLABLE WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceReference(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceRelease(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of PipelineLayout\nWGPU_EXPORT void wgpuPipelineLayoutSetLabel(WGPUPipelineLayout pipelineLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuPipelineLayoutReference(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuPipelineLayoutRelease(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of QuerySet\nWGPU_EXPORT void wgpuQuerySetDestroy(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuQuerySetGetCount(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUQueryType wgpuQuerySetGetType(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQuerySetSetLabel(WGPUQuerySet querySet, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQuerySetReference(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQuerySetRelease(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Queue\nWGPU_EXPORT void wgpuQueueCopyExternalTextureForBrowser(WGPUQueue queue, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueCopyTextureForBrowser(WGPUQueue queue, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueOnSubmittedWorkDone(WGPUQueue queue, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueSetLabel(WGPUQueue queue, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueSubmit(WGPUQueue queue, size_t commandCount, WGPUCommandBuffer const * commands) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueWriteBuffer(WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueWriteTexture(WGPUQueue queue, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueReference(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueRelease(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderBundle\nWGPU_EXPORT void wgpuRenderBundleSetLabel(WGPURenderBundle renderBundle, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleReference(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleRelease(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderBundleEncoder\nWGPU_EXPORT void wgpuRenderBundleEncoderDraw(WGPURenderBundleEncoder renderBundleEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder renderBundleEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderBundle wgpuRenderBundleEncoderFinish(WGPURenderBundleEncoder renderBundleEncoder, WGPU_NULLABLE WGPURenderBundleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder renderBundleEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder renderBundleEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder renderBundleEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetLabel(WGPURenderBundleEncoder renderBundleEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder renderBundleEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderReference(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderRelease(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderPassEncoder\nWGPU_EXPORT void wgpuRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder renderPassEncoder, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDraw(WGPURenderPassEncoder renderPassEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndexed(WGPURenderPassEncoder renderPassEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndirect(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderEnd(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderExecuteBundles(WGPURenderPassEncoder renderPassEncoder, size_t bundleCount, WGPURenderBundle const * bundles) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder renderPassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder renderPassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetBindGroup(WGPURenderPassEncoder renderPassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder renderPassEncoder, WGPUColor const * color) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetLabel(WGPURenderPassEncoder renderPassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetPipeline(WGPURenderPassEncoder renderPassEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetScissorRect(WGPURenderPassEncoder renderPassEncoder, uint32_t x, uint32_t y, uint32_t width, uint32_t height) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetStencilReference(WGPURenderPassEncoder renderPassEncoder, uint32_t reference) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder renderPassEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetViewport(WGPURenderPassEncoder renderPassEncoder, float x, float y, float width, float height, float minDepth, float maxDepth) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderReference(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderRelease(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderPipeline\nWGPU_EXPORT WGPUBindGroupLayout wgpuRenderPipelineGetBindGroupLayout(WGPURenderPipeline renderPipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPipelineSetLabel(WGPURenderPipeline renderPipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPipelineReference(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPipelineRelease(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Sampler\nWGPU_EXPORT void wgpuSamplerSetLabel(WGPUSampler sampler, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSamplerReference(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSamplerRelease(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ShaderModule\nWGPU_EXPORT void wgpuShaderModuleGetCompilationInfo(WGPUShaderModule shaderModule, WGPUCompilationInfoCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuShaderModuleSetLabel(WGPUShaderModule shaderModule, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuShaderModuleReference(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuShaderModuleRelease(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of SharedFence\nWGPU_EXPORT void wgpuSharedFenceExportInfo(WGPUSharedFence sharedFence, WGPUSharedFenceExportInfo * info) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedFenceReference(WGPUSharedFence sharedFence) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedFenceRelease(WGPUSharedFence sharedFence) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of SharedTextureMemory\nWGPU_EXPORT void wgpuSharedTextureMemoryBeginAccess(WGPUSharedTextureMemory sharedTextureMemory, WGPUTexture texture, WGPUSharedTextureMemoryBeginAccessDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTexture wgpuSharedTextureMemoryCreateTexture(WGPUSharedTextureMemory sharedTextureMemory, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedTextureMemoryEndAccess(WGPUSharedTextureMemory sharedTextureMemory, WGPUTexture texture, WGPUSharedTextureMemoryEndAccessState * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedTextureMemoryGetProperties(WGPUSharedTextureMemory sharedTextureMemory, WGPUSharedTextureMemoryProperties * properties) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedTextureMemorySetLabel(WGPUSharedTextureMemory sharedTextureMemory, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedTextureMemoryReference(WGPUSharedTextureMemory sharedTextureMemory) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSharedTextureMemoryRelease(WGPUSharedTextureMemory sharedTextureMemory) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Surface\nWGPU_EXPORT void wgpuSurfaceReference(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSurfaceRelease(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of SwapChain\nWGPU_EXPORT WGPUTexture wgpuSwapChainGetCurrentTexture(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureView wgpuSwapChainGetCurrentTextureView(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSwapChainPresent(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSwapChainReference(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSwapChainRelease(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Texture\nWGPU_EXPORT WGPUTextureView wgpuTextureCreateView(WGPUTexture texture, WGPU_NULLABLE WGPUTextureViewDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureDestroy(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetDepthOrArrayLayers(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureDimension wgpuTextureGetDimension(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureFormat wgpuTextureGetFormat(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetHeight(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetMipLevelCount(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetSampleCount(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureUsageFlags wgpuTextureGetUsage(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetWidth(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureSetLabel(WGPUTexture texture, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureReference(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureRelease(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of TextureView\nWGPU_EXPORT void wgpuTextureViewSetLabel(WGPUTextureView textureView, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureViewReference(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureViewRelease(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\n\n\n#endif  // !defined(WGPU_SKIP_DECLARATIONS)\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif // WEBGPU_H_\n", "./include/dawn/wire/Wire.h": "// Copyright 2017 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_WIRE_H_\n#define INCLUDE_DAWN_WIRE_WIRE_H_\n\n#include <cstdint>\n#include <limits>\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/wire/dawn_wire_export.h\"\n\nnamespace dawn::wire {\n\nclass DAWN_WIRE_EXPORT CommandSerializer {\n  public:\n    CommandSerializer();\n    virtual ~CommandSerializer();\n    CommandSerializer(const CommandSerializer& rhs) = delete;\n    CommandSerializer& operator=(const CommandSerializer& rhs) = delete;\n\n    // Get space for serializing commands.\n    // GetCmdSpace will never be called with a value larger than\n    // what GetMaximumAllocationSize returns. Return nullptr to indicate\n    // a fatal error.\n    virtual void* GetCmdSpace(size_t size) = 0;\n    virtual bool Flush() = 0;\n    virtual size_t GetMaximumAllocationSize() const = 0;\n    virtual void OnSerializeError();\n};\n\nclass DAWN_WIRE_EXPORT CommandHandler {\n  public:\n    CommandHandler();\n    virtual ~CommandHandler();\n    CommandHandler(const CommandHandler& rhs) = delete;\n    CommandHandler& operator=(const CommandHandler& rhs) = delete;\n\n    virtual const volatile char* HandleCommands(const volatile char* commands, size_t size) = 0;\n};\n\n}  // namespace dawn::wire\n\n#endif  // INCLUDE_DAWN_WIRE_WIRE_H_\n", "./include/dawn/wire/WireServer.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_WIRESERVER_H_\n#define INCLUDE_DAWN_WIRE_WIRESERVER_H_\n\n#include <memory>\n\n#include \"dawn/wire/Wire.h\"\n\nstruct DawnProcTable;\n\nnamespace dawn::wire {\n\nnamespace server {\nclass Server;\nclass MemoryTransferService;\n}  // namespace server\n\nstruct DAWN_WIRE_EXPORT WireServerDescriptor {\n    const DawnProcTable* procs;\n    CommandSerializer* serializer;\n    server::MemoryTransferService* memoryTransferService = nullptr;\n};\n\nclass DAWN_WIRE_EXPORT WireServer : public CommandHandler {\n  public:\n    explicit WireServer(const WireServerDescriptor& descriptor);\n    ~WireServer() override;\n\n    const volatile char* HandleCommands(const volatile char* commands, size_t size) override;\n\n    bool InjectTexture(WGPUTexture texture,\n                       uint32_t id,\n                       uint32_t generation,\n                       uint32_t deviceId,\n                       uint32_t deviceGeneration);\n    bool InjectSwapChain(WGPUSwapChain swapchain,\n                         uint32_t id,\n                         uint32_t generation,\n                         uint32_t deviceId,\n                         uint32_t deviceGeneration);\n\n    bool InjectDevice(WGPUDevice device, uint32_t id, uint32_t generation);\n\n    bool InjectInstance(WGPUInstance instance, uint32_t id, uint32_t generation);\n\n    // Look up a device by (id, generation) pair. Returns nullptr if the generation\n    // has expired or the id is not found.\n    // The Wire does not have destroy hooks to allow an embedder to observe when an object\n    // has been destroyed, but in Chrome, we need to know the list of live devices so we\n    // can call device.Tick() on all of them periodically to ensure progress on asynchronous\n    // work is made. Getting this list can be done by tracking the (id, generation) of\n    // previously injected devices, and observing if GetDevice(id, generation) returns non-null.\n    WGPUDevice GetDevice(uint32_t id, uint32_t generation);\n\n    // Check if a device handle is known by the wire.\n    // In Chrome, we need to know the list of live devices so we can call device.Tick() on all of\n    // them periodically to ensure progress on asynchronous work is made.\n    bool IsDeviceKnown(WGPUDevice device) const;\n\n  private:\n    std::unique_ptr<server::Server> mImpl;\n};\n\nnamespace server {\nclass DAWN_WIRE_EXPORT MemoryTransferService {\n  public:\n    MemoryTransferService();\n    virtual ~MemoryTransferService();\n\n    class ReadHandle;\n    class WriteHandle;\n\n    // Deserialize data to create Read/Write handles. These handles are for the client\n    // to Read/Write data.\n    virtual bool DeserializeReadHandle(const void* deserializePointer,\n                                       size_t deserializeSize,\n                                       ReadHandle** readHandle) = 0;\n    virtual bool DeserializeWriteHandle(const void* deserializePointer,\n                                        size_t deserializeSize,\n                                        WriteHandle** writeHandle) = 0;\n\n    class DAWN_WIRE_EXPORT ReadHandle {\n      public:\n        ReadHandle();\n        virtual ~ReadHandle();\n\n        // Return the size of the command serialized if\n        // SerializeDataUpdate is called with the same offset/size args\n        virtual size_t SizeOfSerializeDataUpdate(size_t offset, size_t size) = 0;\n\n        // Gets called when a MapReadCallback resolves.\n        // Serialize the data update for the range (offset, offset + size) into\n        // |serializePointer| to the client There could be nothing to be serialized (if\n        // using shared memory)\n        virtual void SerializeDataUpdate(const void* data,\n                                         size_t offset,\n                                         size_t size,\n                                         void* serializePointer) = 0;\n\n      private:\n        ReadHandle(const ReadHandle&) = delete;\n        ReadHandle& operator=(const ReadHandle&) = delete;\n    };\n\n    class DAWN_WIRE_EXPORT WriteHandle {\n      public:\n        WriteHandle();\n        virtual ~WriteHandle();\n\n        // Set the target for writes from the client. DeserializeFlush should copy data\n        // into the target.\n        void SetTarget(void* data);\n        // Set Staging data length for OOB check\n        void SetDataLength(size_t dataLength);\n\n        // This function takes in the serialized result of\n        // client::MemoryTransferService::WriteHandle::SerializeDataUpdate.\n        // Needs to check potential offset/size OOB and overflow\n        virtual bool DeserializeDataUpdate(const void* deserializePointer,\n                                           size_t deserializeSize,\n                                           size_t offset,\n                                           size_t size) = 0;\n\n      protected:\n        void* mTargetData = nullptr;\n        size_t mDataLength = 0;\n\n      private:\n        WriteHandle(const WriteHandle&) = delete;\n        WriteHandle& operator=(const WriteHandle&) = delete;\n    };\n\n  private:\n    MemoryTransferService(const MemoryTransferService&) = delete;\n    MemoryTransferService& operator=(const MemoryTransferService&) = delete;\n};\n}  // namespace server\n\n}  // namespace dawn::wire\n\n#endif  // INCLUDE_DAWN_WIRE_WIRESERVER_H_\n", "./include/dawn/wire/dawn_wire_export.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_DAWN_WIRE_EXPORT_H_\n#define INCLUDE_DAWN_WIRE_DAWN_WIRE_EXPORT_H_\n\n#if defined(DAWN_WIRE_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(DAWN_WIRE_IMPLEMENTATION)\n#define DAWN_WIRE_EXPORT __declspec(dllexport)\n#else\n#define DAWN_WIRE_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(DAWN_WIRE_IMPLEMENTATION)\n#define DAWN_WIRE_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define DAWN_WIRE_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(DAWN_WIRE_SHARED_LIBRARY)\n#define DAWN_WIRE_EXPORT\n#endif  // defined(DAWN_WIRE_SHARED_LIBRARY)\n\n#endif  // INCLUDE_DAWN_WIRE_DAWN_WIRE_EXPORT_H_\n", "./include/dawn/wire/WireClient.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_WIRECLIENT_H_\n#define INCLUDE_DAWN_WIRE_WIRECLIENT_H_\n\n#include <memory>\n#include <vector>\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/wire/Wire.h\"\n\nnamespace dawn::wire {\n\nnamespace client {\nclass Client;\nclass MemoryTransferService;\n\nDAWN_WIRE_EXPORT const DawnProcTable& GetProcs();\n}  // namespace client\n\nstruct ReservedTexture {\n    WGPUTexture texture;\n    uint32_t id;\n    uint32_t generation;\n    uint32_t deviceId;\n    uint32_t deviceGeneration;\n};\n\nstruct ReservedSwapChain {\n    WGPUSwapChain swapchain;\n    uint32_t id;\n    uint32_t generation;\n    uint32_t deviceId;\n    uint32_t deviceGeneration;\n};\n\nstruct ReservedDevice {\n    WGPUDevice device;\n    uint32_t id;\n    uint32_t generation;\n};\n\nstruct ReservedInstance {\n    WGPUInstance instance;\n    uint32_t id;\n    uint32_t generation;\n};\n\nstruct DAWN_WIRE_EXPORT WireClientDescriptor {\n    CommandSerializer* serializer;\n    client::MemoryTransferService* memoryTransferService = nullptr;\n};\n\nclass DAWN_WIRE_EXPORT WireClient : public CommandHandler {\n  public:\n    explicit WireClient(const WireClientDescriptor& descriptor);\n    ~WireClient() override;\n\n    const volatile char* HandleCommands(const volatile char* commands, size_t size) override;\n\n    ReservedTexture ReserveTexture(WGPUDevice device, const WGPUTextureDescriptor* descriptor);\n    ReservedSwapChain ReserveSwapChain(WGPUDevice device,\n                                       const WGPUSwapChainDescriptor* descriptor);\n    ReservedDevice ReserveDevice();\n    ReservedInstance ReserveInstance();\n\n    void ReclaimTextureReservation(const ReservedTexture& reservation);\n    void ReclaimSwapChainReservation(const ReservedSwapChain& reservation);\n    void ReclaimDeviceReservation(const ReservedDevice& reservation);\n    void ReclaimInstanceReservation(const ReservedInstance& reservation);\n\n    // Disconnects the client.\n    // Commands allocated after this point will not be sent.\n    void Disconnect();\n\n  private:\n    std::unique_ptr<client::Client> mImpl;\n};\n\nnamespace client {\nclass DAWN_WIRE_EXPORT MemoryTransferService {\n  public:\n    MemoryTransferService();\n    virtual ~MemoryTransferService();\n\n    class ReadHandle;\n    class WriteHandle;\n\n    // Create a handle for reading server data.\n    // This may fail and return nullptr.\n    virtual ReadHandle* CreateReadHandle(size_t) = 0;\n\n    // Create a handle for writing server data.\n    // This may fail and return nullptr.\n    virtual WriteHandle* CreateWriteHandle(size_t) = 0;\n\n    class DAWN_WIRE_EXPORT ReadHandle {\n      public:\n        ReadHandle();\n        virtual ~ReadHandle();\n\n        // Get the required serialization size for SerializeCreate\n        virtual size_t SerializeCreateSize() = 0;\n\n        // Serialize the handle into |serializePointer| so it can be received by the server.\n        virtual void SerializeCreate(void* serializePointer) = 0;\n\n        // Simply return the base address of the allocation (without applying any offset)\n        // Returns nullptr if the allocation failed.\n        // The data must live at least until the ReadHandle is destructued\n        virtual const void* GetData() = 0;\n\n        // Gets called when a MapReadCallback resolves.\n        // deserialize the data update and apply\n        // it to the range (offset, offset + size) of allocation\n        // There could be nothing to be deserialized (if using shared memory)\n        // Needs to check potential offset/size OOB and overflow\n        virtual bool DeserializeDataUpdate(const void* deserializePointer,\n                                           size_t deserializeSize,\n                                           size_t offset,\n                                           size_t size) = 0;\n\n      private:\n        ReadHandle(const ReadHandle&) = delete;\n        ReadHandle& operator=(const ReadHandle&) = delete;\n    };\n\n    class DAWN_WIRE_EXPORT WriteHandle {\n      public:\n        WriteHandle();\n        virtual ~WriteHandle();\n\n        // Get the required serialization size for SerializeCreate\n        virtual size_t SerializeCreateSize() = 0;\n\n        // Serialize the handle into |serializePointer| so it can be received by the server.\n        virtual void SerializeCreate(void* serializePointer) = 0;\n\n        // Simply return the base address of the allocation (without applying any offset)\n        // The data returned should be zero-initialized.\n        // The data returned must live at least until the WriteHandle is destructed.\n        // On failure, the pointer returned should be null.\n        virtual void* GetData() = 0;\n\n        // Get the required serialization size for SerializeDataUpdate\n        virtual size_t SizeOfSerializeDataUpdate(size_t offset, size_t size) = 0;\n\n        // Serialize a command to send the modified contents of\n        // the subrange (offset, offset + size) of the allocation at buffer unmap\n        // This subrange is always the whole mapped region for now\n        // There could be nothing to be serialized (if using shared memory)\n        virtual void SerializeDataUpdate(void* serializePointer, size_t offset, size_t size) = 0;\n\n      private:\n        WriteHandle(const WriteHandle&) = delete;\n        WriteHandle& operator=(const WriteHandle&) = delete;\n    };\n\n  private:\n    MemoryTransferService(const MemoryTransferService&) = delete;\n    MemoryTransferService& operator=(const MemoryTransferService&) = delete;\n};\n\n// Backdoor to get the order of the ProcMap for testing\nDAWN_WIRE_EXPORT std::vector<const char*> GetProcMapNamesForTesting();\n}  // namespace client\n}  // namespace dawn::wire\n\n#endif  // INCLUDE_DAWN_WIRE_WIRECLIENT_H_\n", "./include/dawn/native/VulkanBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_VULKANBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_VULKANBACKEND_H_\n\n#include <vulkan/vulkan.h>\n\n#include <array>\n#include <vector>\n\n#include \"dawn/native/DawnNative.h\"\n\nnamespace dawn::native::vulkan {\n\nDAWN_NATIVE_EXPORT VkInstance GetInstance(WGPUDevice device);\n\nDAWN_NATIVE_EXPORT PFN_vkVoidFunction GetInstanceProcAddr(WGPUDevice device, const char* pName);\n\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptions\n    : public PhysicalDeviceDiscoveryOptionsBase {\n    PhysicalDeviceDiscoveryOptions();\n\n    bool forceSwiftShader = false;\n};\n\n// TODO(dawn:1774): Deprecated.\nusing AdapterDiscoveryOptions = PhysicalDeviceDiscoveryOptions;\n\nenum class NeedsDedicatedAllocation {\n    Yes,\n    No,\n    // Use Vulkan reflection to detect whether a dedicated allocation is needed.\n    Detect,\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorVk : ExternalImageDescriptor {\n  public:\n    // The following members may be ignored if |ExternalImageDescriptor::isInitialized| is false\n    // since the import does not need to preserve texture contents.\n\n    // See https://www.khronos.org/registry/vulkan/specs/1.1/html/chap7.html. The acquire\n    // operation old/new layouts must match exactly the layouts in the release operation. So\n    // we may need to issue two barriers releasedOldLayout -> releasedNewLayout ->\n    // cTextureDescriptor.usage if the new layout is not compatible with the desired usage.\n    // The first barrier is the queue transfer, the second is the layout transition to our\n    // desired usage.\n    VkImageLayout releasedOldLayout = VK_IMAGE_LAYOUT_GENERAL;\n    VkImageLayout releasedNewLayout = VK_IMAGE_LAYOUT_GENERAL;\n\n    // Try to detect the need to use a dedicated allocation for imported images by default but let\n    // the application override this as drivers have bugs and forget to require a dedicated\n    // allocation.\n    NeedsDedicatedAllocation dedicatedAllocation = NeedsDedicatedAllocation::Detect;\n\n  protected:\n    using ExternalImageDescriptor::ExternalImageDescriptor;\n};\n\nstruct ExternalImageExportInfoVk : ExternalImageExportInfo {\n  public:\n    // See comments in |ExternalImageDescriptorVk|\n    // Contains the old/new layouts used in the queue release operation.\n    VkImageLayout releasedOldLayout;\n    VkImageLayout releasedNewLayout;\n\n  protected:\n    using ExternalImageExportInfo::ExternalImageExportInfo;\n};\n\n// Can't use DAWN_PLATFORM_IS(LINUX) since header included in both Dawn and Chrome\n#ifdef __linux__\n\n// Common properties of external images represented by FDs. On successful import the file\n// descriptor's ownership is transferred to the Dawn implementation and they shouldn't be\n// used outside of Dawn again. TODO(enga): Also transfer ownership in the error case so the\n// caller can assume the FD is always consumed.\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorFD : ExternalImageDescriptorVk {\n  public:\n    int memoryFD;              // A file descriptor from an export of the memory of the image\n    std::vector<int> waitFDs;  // File descriptors of semaphores which will be waited on\n\n  protected:\n    using ExternalImageDescriptorVk::ExternalImageDescriptorVk;\n};\n\n// Descriptor for opaque file descriptor image import\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorOpaqueFD : ExternalImageDescriptorFD {\n    ExternalImageDescriptorOpaqueFD();\n\n    VkDeviceSize allocationSize;  // Must match VkMemoryAllocateInfo from image creation\n    uint32_t memoryTypeIndex;     // Must match VkMemoryAllocateInfo from image creation\n};\n\n// The plane-wise offset and stride.\nstruct DAWN_NATIVE_EXPORT PlaneLayout {\n    uint64_t offset;\n    uint32_t stride;\n};\n\n// Descriptor for dma-buf file descriptor image import\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorDmaBuf : ExternalImageDescriptorFD {\n    ExternalImageDescriptorDmaBuf();\n\n    static constexpr uint32_t kMaxPlanes = 3;\n    std::array<PlaneLayout, kMaxPlanes> planeLayouts;\n    uint64_t drmModifier;  // DRM modifier of the buffer\n};\n\n// Info struct that is written to in |ExportVulkanImage|.\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoFD : ExternalImageExportInfoVk {\n  public:\n    // Contains the exported semaphore handles.\n    std::vector<int> semaphoreHandles;\n\n  protected:\n    using ExternalImageExportInfoVk::ExternalImageExportInfoVk;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoOpaqueFD : ExternalImageExportInfoFD {\n    ExternalImageExportInfoOpaqueFD();\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoDmaBuf : ExternalImageExportInfoFD {\n    ExternalImageExportInfoDmaBuf();\n};\n\n#ifdef __ANDROID__\n\n// Descriptor for AHardwareBuffer image import\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorAHardwareBuffer : ExternalImageDescriptorVk {\n  public:\n    ExternalImageDescriptorAHardwareBuffer();\n\n    struct AHardwareBuffer* handle;  // The AHardwareBuffer which contains the memory of the image\n    std::vector<int> waitFDs;        // File descriptors of semaphores which will be waited on\n\n  protected:\n    using ExternalImageDescriptorVk::ExternalImageDescriptorVk;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoAHardwareBuffer : ExternalImageExportInfoFD {\n    ExternalImageExportInfoAHardwareBuffer();\n};\n\n#endif  // __ANDROID__\n\n#endif  // __linux__\n\n// Imports external memory into a Vulkan image. Internally, this uses external memory /\n// semaphore extensions to import the image and wait on the provided synchronizaton\n// primitives before the texture can be used.\n// On failure, returns a nullptr.\nDAWN_NATIVE_EXPORT WGPUTexture WrapVulkanImage(WGPUDevice device,\n                                               const ExternalImageDescriptorVk* descriptor);\n\n// Exports external memory from a Vulkan image. This must be called on wrapped textures\n// before they are destroyed. It writes the semaphore to wait on and the old/new image\n// layouts to |info|. Pass VK_IMAGE_LAYOUT_UNDEFINED as |desiredLayout| if you don't want to\n// perform a layout transition.\nDAWN_NATIVE_EXPORT bool ExportVulkanImage(WGPUTexture texture,\n                                          VkImageLayout desiredLayout,\n                                          ExternalImageExportInfoVk* info);\n// |ExportVulkanImage| with default desiredLayout of VK_IMAGE_LAYOUT_UNDEFINED.\nDAWN_NATIVE_EXPORT bool ExportVulkanImage(WGPUTexture texture, ExternalImageExportInfoVk* info);\n\n}  // namespace dawn::native::vulkan\n\n#endif  // INCLUDE_DAWN_NATIVE_VULKANBACKEND_H_\n", "./include/dawn/native/NullBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_NULLBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_NULLBACKEND_H_\n\n#include \"dawn/native/DawnNative.h\"\n\nnamespace dawn::native::null {\n\n// Nothing for now \\o/\n\n}  // namespace dawn::native::null\n\n#endif  // INCLUDE_DAWN_NATIVE_NULLBACKEND_H_\n", "./include/dawn/native/dawn_native_export.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_DAWN_NATIVE_EXPORT_H_\n#define INCLUDE_DAWN_NATIVE_DAWN_NATIVE_EXPORT_H_\n\n#if defined(DAWN_NATIVE_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(DAWN_NATIVE_IMPLEMENTATION)\n#define DAWN_NATIVE_EXPORT __declspec(dllexport)\n#else\n#define DAWN_NATIVE_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(DAWN_NATIVE_IMPLEMENTATION)\n#define DAWN_NATIVE_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define DAWN_NATIVE_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(DAWN_NATIVE_SHARED_LIBRARY)\n#define DAWN_NATIVE_EXPORT\n#endif  // defined(DAWN_NATIVE_SHARED_LIBRARY)\n\n#endif  // INCLUDE_DAWN_NATIVE_DAWN_NATIVE_EXPORT_H_\n", "./include/dawn/native/D3D12Backend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_D3D12BACKEND_H_\n#define INCLUDE_DAWN_NATIVE_D3D12BACKEND_H_\n\n#include <DXGI1_4.h>\n#include <d3d12.h>\n#include <windows.h>\n#include <wrl/client.h>\n\n#include \"dawn/native/D3DBackend.h\"\n\nstruct ID3D12Device;\nstruct ID3D12Resource;\n\nnamespace dawn::native::d3d12 {\n\nclass Device;\n\nenum MemorySegment {\n    Local,\n    NonLocal,\n};\n\nDAWN_NATIVE_EXPORT uint64_t SetExternalMemoryReservation(WGPUDevice device,\n                                                         uint64_t requestedReservationSize,\n                                                         MemorySegment memorySegment);\n\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptions\n    : public d3d::PhysicalDeviceDiscoveryOptions {\n    PhysicalDeviceDiscoveryOptions();\n    explicit PhysicalDeviceDiscoveryOptions(Microsoft::WRL::ComPtr<IDXGIAdapter> adapter);\n};\n\n// TODO(dawn:1774): Deprecated.\nusing AdapterDiscoveryOptions = PhysicalDeviceDiscoveryOptions;\n\n}  // namespace dawn::native::d3d12\n\n#endif  // INCLUDE_DAWN_NATIVE_D3D12BACKEND_H_\n", "./include/dawn/native/D3DBackend.h": "// Copyright 2023 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_D3DBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_D3DBACKEND_H_\n\n#include <dxgi1_4.h>\n#include <windows.h>\n#include <wrl/client.h>\n\n#include <memory>\n#include <vector>\n\n#include \"dawn/native/DawnNative.h\"\n#include \"dawn/webgpu_cpp_chained_struct.h\"\n\nnamespace dawn::native::d3d {\n\nclass ExternalImageDXGIImpl;\n\nDAWN_NATIVE_EXPORT Microsoft::WRL::ComPtr<IDXGIAdapter> GetDXGIAdapter(WGPUAdapter adapter);\n\n// Can be chained in WGPURequestAdapterOptions\nstruct DAWN_NATIVE_EXPORT RequestAdapterOptionsLUID : wgpu::ChainedStruct {\n    RequestAdapterOptionsLUID();\n\n    ::LUID adapterLUID;\n};\n\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptions\n    : public PhysicalDeviceDiscoveryOptionsBase {\n    PhysicalDeviceDiscoveryOptions(WGPUBackendType type,\n                                   Microsoft::WRL::ComPtr<IDXGIAdapter> adapter);\n    Microsoft::WRL::ComPtr<IDXGIAdapter> dxgiAdapter;\n};\n\n// TODO(dawn:1774): Deprecated.\nusing AdapterDiscoveryOptions = PhysicalDeviceDiscoveryOptions;\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorDXGISharedHandle : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorDXGISharedHandle();\n\n    // Note: SharedHandle must be a handle to a texture object.\n    HANDLE sharedHandle = nullptr;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorD3D11Texture : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorD3D11Texture();\n\n    // Texture is used for creating ExternalImageDXGI with d3d11 backend. It must be an\n    // ID3D11Texture2D object and created from the same ID3D11Device used in the WGPUDevice.\n    Microsoft::WRL::ComPtr<IUnknown> texture;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDXGIFenceDescriptor {\n    // Shared handle for the fence. This never passes ownership to the callee (when used as an input\n    // parameter) or to the caller (when used as a return value or output parameter).\n    HANDLE fenceHandle = nullptr;\n\n    // The value that was previously signaled on this fence and should be waited on.\n    uint64_t fenceValue = 0;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDXGIBeginAccessDescriptor {\n    bool isInitialized = false;  // Whether the texture is initialized on import\n    WGPUTextureUsageFlags usage = WGPUTextureUsage_None;\n\n    // A list of fences to wait on before accessing the texture.\n    std::vector<ExternalImageDXGIFenceDescriptor> waitFences;\n\n    // Whether the texture is for a WebGPU swap chain.\n    bool isSwapChainTexture = false;\n};\n\nclass DAWN_NATIVE_EXPORT ExternalImageDXGI {\n  public:\n    ~ExternalImageDXGI();\n\n    static std::unique_ptr<ExternalImageDXGI> Create(WGPUDevice device,\n                                                     const ExternalImageDescriptor* descriptor);\n\n    // Returns true if the external image resources are still valid, otherwise BeginAccess() is\n    // guaranteed to fail e.g. after device destruction.\n    bool IsValid() const;\n\n    // Creates WGPUTexture wrapping the DXGI shared handle. The provided wait fences will be\n    // synchronized before using the texture in any command lists. Empty fences (nullptr handle) are\n    // ignored for convenience (EndAccess can return such fences).\n    WGPUTexture BeginAccess(const ExternalImageDXGIBeginAccessDescriptor* descriptor);\n\n    // Returns the signalFence that the client must wait on for correct synchronization. Can return\n    // an empty fence (nullptr handle) if the texture wasn't accessed by Dawn.\n    // Note that merely calling Destroy() on the WGPUTexture does not ensure synchronization.\n    void EndAccess(WGPUTexture texture, ExternalImageDXGIFenceDescriptor* signalFence);\n\n  private:\n    explicit ExternalImageDXGI(std::unique_ptr<ExternalImageDXGIImpl> impl);\n\n    std::unique_ptr<ExternalImageDXGIImpl> mImpl;\n};\n\n// May be chained on SharedTextureMemoryDescriptor\nstruct DAWN_NATIVE_EXPORT SharedTextureMemoryID3D11Texture2DDescriptor : wgpu::ChainedStruct {\n    SharedTextureMemoryID3D11Texture2DDescriptor() {\n        sType = static_cast<wgpu::SType>(WGPUSType_SharedTextureMemoryD3D11Texture2DDescriptor);\n    }\n\n    // This ID3D11Texture2D object must be created from the same ID3D11Device used in the\n    // WGPUDevice.\n    Microsoft::WRL::ComPtr<IUnknown> texture;\n};\n\n}  // namespace dawn::native::d3d\n\n#endif  // INCLUDE_DAWN_NATIVE_D3DBACKEND_H_\n", "./include/dawn/native/MetalBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_METALBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_METALBACKEND_H_\n\n#include <vector>\n\n#include \"dawn/native/DawnNative.h\"\n\n// The specifics of the Metal backend expose types in function signatures that might not be\n// available in dependent's minimum supported SDK version. Suppress all availability errors using\n// clang's pragmas. Dependents using the types without guarded availability will still get errors\n// when using the types.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunguarded-availability\"\n\nstruct __IOSurface;\ntypedef __IOSurface* IOSurfaceRef;\n\n#ifdef __OBJC__\n#import <Metal/Metal.h>\n#endif  // __OBJC__\n\nnamespace dawn::native::metal {\n\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptions\n    : public PhysicalDeviceDiscoveryOptionsBase {\n    PhysicalDeviceDiscoveryOptions();\n};\n\n// TODO(dawn:1774): Deprecated.\nusing AdapterDiscoveryOptions = PhysicalDeviceDiscoveryOptions;\n\nstruct DAWN_NATIVE_EXPORT ExternalImageMTLSharedEventDescriptor {\n    // Shared event handle `id<MTLSharedEvent>`.\n    // This never passes ownership to the callee (when used as an input\n    // parameter) or to the caller (when used as a return value or output parameter).\n#ifdef __OBJC__\n    id<MTLSharedEvent> sharedEvent = nil;\n    static_assert(sizeof(id<MTLSharedEvent>) == sizeof(void*));\n    static_assert(alignof(id<MTLSharedEvent>) == alignof(void*));\n#else\n    void* sharedEvent = nullptr;\n#endif\n\n    // The value that was previously signaled on this event and should be waited on.\n    uint64_t signaledValue = 0;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorIOSurface : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorIOSurface();\n    ~ExternalImageDescriptorIOSurface();\n\n    IOSurfaceRef ioSurface;\n\n    // A list of events to wait on before accessing the texture.\n    std::vector<ExternalImageMTLSharedEventDescriptor> waitEvents;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageIOSurfaceEndAccessDescriptor\n    : ExternalImageMTLSharedEventDescriptor {\n    bool isInitialized;\n};\n\nDAWN_NATIVE_EXPORT WGPUTexture WrapIOSurface(WGPUDevice device,\n                                             const ExternalImageDescriptorIOSurface* descriptor);\n\nDAWN_NATIVE_EXPORT void IOSurfaceEndAccess(WGPUTexture texture,\n                                           ExternalImageIOSurfaceEndAccessDescriptor* descriptor);\n\n// When making Metal interop with other APIs, we need to be careful that QueueSubmit doesn't\n// mean that the operations will be visible to other APIs/Metal devices right away. macOS\n// does have a global queue of graphics operations, but the command buffers are inserted there\n// when they are \"scheduled\". Submitting other operations before the command buffer is\n// scheduled could lead to races in who gets scheduled first and incorrect rendering.\nDAWN_NATIVE_EXPORT void WaitForCommandsToBeScheduled(WGPUDevice device);\n\n}  // namespace dawn::native::metal\n\n#pragma clang diagnostic pop\n\n#endif  // INCLUDE_DAWN_NATIVE_METALBACKEND_H_\n", "./include/dawn/native/D3D11Backend.h": "// Copyright 2023 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_D3D11BACKEND_H_\n#define INCLUDE_DAWN_NATIVE_D3D11BACKEND_H_\n\n#include <d3d11_1.h>\n#include <windows.h>\n#include <wrl/client.h>\n\n#include <memory>\n\n#include \"dawn/native/D3DBackend.h\"\n\nnamespace dawn::native::d3d11 {\n\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptions\n    : public d3d::PhysicalDeviceDiscoveryOptions {\n    PhysicalDeviceDiscoveryOptions();\n    explicit PhysicalDeviceDiscoveryOptions(Microsoft::WRL::ComPtr<IDXGIAdapter> adapter);\n};\n\n// TODO(dawn:1774): Deprecated.\nusing AdapterDiscoveryOptions = PhysicalDeviceDiscoveryOptions;\n\nDAWN_NATIVE_EXPORT Microsoft::WRL::ComPtr<ID3D11Device> GetD3D11Device(WGPUDevice device);\n\n}  // namespace dawn::native::d3d11\n\n#endif  // INCLUDE_DAWN_NATIVE_D3D11BACKEND_H_\n", "./include/dawn/native/DawnNative.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_DAWNNATIVE_H_\n#define INCLUDE_DAWN_NATIVE_DAWNNATIVE_H_\n\n#include <string>\n#include <vector>\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/native/dawn_native_export.h\"\n#include \"dawn/webgpu.h\"\n#include \"dawn/webgpu_cpp_chained_struct.h\"\n\nnamespace dawn::platform {\nclass Platform;\n}  // namespace dawn::platform\n\nnamespace wgpu {\nstruct AdapterProperties;\nstruct DeviceDescriptor;\nstruct RequestAdapterOptions;\n}  // namespace wgpu\n\nnamespace dawn::native {\n\nclass InstanceBase;\nclass AdapterBase;\n\n// Each toggle is assigned with a TogglesStage, indicating the validation and earliest usage\n// time of the toggle.\nenum class ToggleStage { Instance, Adapter, Device };\n\n// A struct to record the information of a toggle. A toggle is a code path in Dawn device that\n// can be manually configured to run or not outside Dawn, including workarounds, special\n// features and optimizations.\nstruct ToggleInfo {\n    const char* name;\n    const char* description;\n    const char* url;\n    ToggleStage stage;\n};\n\n// A struct to record the information of a feature. A feature is a GPU feature that is not\n// required to be supported by all Dawn backends and can only be used when it is enabled on the\n// creation of device.\nstruct FeatureInfo {\n    const char* name;\n    const char* description;\n    const char* url;\n    // The enum of feature state, could be stable or experimental. Using an experimental feature\n    // requires the AllowUnsafeAPIs toggle to be enabled.\n    enum class FeatureState { Stable = 0, Experimental };\n    FeatureState featureState;\n};\n\n// An adapter is an object that represent on possibility of creating devices in the system.\n// Most of the time it will represent a combination of a physical GPU and an API. Not that the\n// same GPU can be represented by multiple adapters but on different APIs.\n//\n// The underlying Dawn adapter is owned by the Dawn instance so this class is not RAII but just\n// a reference to an underlying adapter.\nclass DAWN_NATIVE_EXPORT Adapter {\n  public:\n    Adapter();\n    // NOLINTNEXTLINE(runtime/explicit)\n    Adapter(AdapterBase* impl);\n    ~Adapter();\n\n    Adapter(const Adapter& other);\n    Adapter& operator=(const Adapter& other);\n\n    // Essentially webgpu.h's wgpuAdapterGetProperties while we don't have WGPUAdapter in\n    // dawn.json\n    void GetProperties(wgpu::AdapterProperties* properties) const;\n    void GetProperties(WGPUAdapterProperties* properties) const;\n\n    std::vector<const char*> GetSupportedExtensions() const;\n    std::vector<const char*> GetSupportedFeatures() const;\n    bool GetLimits(WGPUSupportedLimits* limits) const;\n\n    void SetUseTieredLimits(bool useTieredLimits);\n\n    // Check that the Adapter is able to support importing external images. This is necessary\n    // to implement the swapchain and interop APIs in Chromium.\n    bool SupportsExternalImages() const;\n\n    explicit operator bool() const;\n\n    // Create a device on this adapter. On an error, nullptr is returned.\n    WGPUDevice CreateDevice(const wgpu::DeviceDescriptor* deviceDescriptor);\n    WGPUDevice CreateDevice(const WGPUDeviceDescriptor* deviceDescriptor = nullptr);\n\n    void RequestDevice(const wgpu::DeviceDescriptor* descriptor,\n                       WGPURequestDeviceCallback callback,\n                       void* userdata);\n    void RequestDevice(const WGPUDeviceDescriptor* descriptor,\n                       WGPURequestDeviceCallback callback,\n                       void* userdata);\n    void RequestDevice(std::nullptr_t descriptor,\n                       WGPURequestDeviceCallback callback,\n                       void* userdata) {\n        RequestDevice(static_cast<const wgpu::DeviceDescriptor*>(descriptor), callback, userdata);\n    }\n\n    // Returns the underlying WGPUAdapter object.\n    WGPUAdapter Get() const;\n\n    // Reset the backend device object for testing purposes.\n    void ResetInternalDeviceForTesting();\n\n  private:\n    AdapterBase* mImpl = nullptr;\n};\n\n// Base class for options passed to Instance::DiscoverPhysicalDevices.\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptionsBase {\n  public:\n    const WGPUBackendType backendType;\n\n  protected:\n    explicit PhysicalDeviceDiscoveryOptionsBase(WGPUBackendType type);\n};\n\n// Deprecated, use PhysicalDeviceDiscoveryOptionsBase instead.\n// TODO(dawn:1774): Remove this.\nusing AdapterDiscoveryOptionsBase = PhysicalDeviceDiscoveryOptionsBase;\n\nenum BackendValidationLevel { Full, Partial, Disabled };\n\n// Can be chained in InstanceDescriptor\nstruct DAWN_NATIVE_EXPORT DawnInstanceDescriptor : wgpu::ChainedStruct {\n    DawnInstanceDescriptor();\n    static constexpr size_t kFirstMemberAlignment =\n        wgpu::detail::ConstexprMax(alignof(wgpu::ChainedStruct), alignof(uint32_t));\n    alignas(kFirstMemberAlignment) uint32_t additionalRuntimeSearchPathsCount = 0;\n    const char* const* additionalRuntimeSearchPaths;\n    dawn::platform::Platform* platform = nullptr;\n\n    // Equality operators, mostly for testing. Note that this tests\n    // strict pointer-pointer equality if the struct contains member pointers.\n    bool operator==(const DawnInstanceDescriptor& rhs) const;\n};\n\n// Represents a connection to dawn_native and is used for dependency injection, discovering\n// system adapters and injecting custom adapters (like a Swiftshader Vulkan adapter).\n//\n// This is an RAII class for Dawn instances and also controls the lifetime of all adapters\n// for this instance.\nclass DAWN_NATIVE_EXPORT Instance {\n  public:\n    explicit Instance(const WGPUInstanceDescriptor* desc = nullptr);\n    ~Instance();\n\n    Instance(const Instance& other) = delete;\n    Instance& operator=(const Instance& other) = delete;\n\n    // Gather all physical devices in the system that can be accessed with no special options.\n    void DiscoverDefaultPhysicalDevices();\n\n    // Adds physical devices that can be discovered with the options provided (like a\n    // getProcAddress). The backend is chosen based on the type of the options used. Returns true on\n    // success.\n    bool DiscoverPhysicalDevices(const PhysicalDeviceDiscoveryOptionsBase* options);\n\n    // Deprecated, use DiscoverDefaultPhysicalDevices and DiscoverPhysicalDevices instead.\n    // TODO(Dawn:1774): Remove these.\n    void DiscoverDefaultAdapters();\n    bool DiscoverAdapters(const AdapterDiscoveryOptionsBase* options);\n\n    // Discovers and returns a vector of adapters.\n    // All systems adapters that can be found are returned if no options are passed.\n    // Otherwise, returns adapters based on the `options`. Adapter toggles descriptor can chained\n    // after options.\n    std::vector<Adapter> EnumerateAdapters(const WGPURequestAdapterOptions* options) const;\n    std::vector<Adapter> EnumerateAdapters(\n        const wgpu::RequestAdapterOptions* options = nullptr) const;\n\n    // Deprecated. Call EnumerateAdapters instead.\n    std::vector<Adapter> GetAdapters() const;\n\n    const ToggleInfo* GetToggleInfo(const char* toggleName);\n    const FeatureInfo* GetFeatureInfo(WGPUFeatureName feature);\n\n    // Enables backend validation layers\n    void EnableBackendValidation(bool enableBackendValidation);\n    void SetBackendValidationLevel(BackendValidationLevel validationLevel);\n\n    // Enable debug capture on Dawn startup\n    void EnableBeginCaptureOnStartup(bool beginCaptureOnStartup);\n\n    // Enable / disable the adapter blocklist.\n    void EnableAdapterBlocklist(bool enable);\n\n    uint64_t GetDeviceCountForTesting() const;\n\n    // Returns the underlying WGPUInstance object.\n    WGPUInstance Get() const;\n\n  private:\n    InstanceBase* mImpl = nullptr;\n};\n\n// Backend-agnostic API for dawn_native\nDAWN_NATIVE_EXPORT const DawnProcTable& GetProcs();\n\n// Query the names of all the toggles that are enabled in device\nDAWN_NATIVE_EXPORT std::vector<const char*> GetTogglesUsed(WGPUDevice device);\n\n// Backdoor to get the number of lazy clears for testing\nDAWN_NATIVE_EXPORT size_t GetLazyClearCountForTesting(WGPUDevice device);\n\n// Backdoor to get the number of deprecation warnings for testing\nDAWN_NATIVE_EXPORT size_t GetDeprecationWarningCountForTesting(WGPUDevice device);\n\n// Backdoor to get the number of physical devices an instance knows about for testing\nDAWN_NATIVE_EXPORT size_t GetPhysicalDeviceCountForTesting(WGPUInstance instance);\n\n//  Query if texture has been initialized\nDAWN_NATIVE_EXPORT bool IsTextureSubresourceInitialized(\n    WGPUTexture texture,\n    uint32_t baseMipLevel,\n    uint32_t levelCount,\n    uint32_t baseArrayLayer,\n    uint32_t layerCount,\n    WGPUTextureAspect aspect = WGPUTextureAspect_All);\n\n// Backdoor to get the order of the ProcMap for testing\nDAWN_NATIVE_EXPORT std::vector<const char*> GetProcMapNamesForTesting();\n\nDAWN_NATIVE_EXPORT bool DeviceTick(WGPUDevice device);\n\nDAWN_NATIVE_EXPORT bool InstanceProcessEvents(WGPUInstance instance);\n\n// ErrorInjector functions used for testing only. Defined in dawn_native/ErrorInjector.cpp\nDAWN_NATIVE_EXPORT void EnableErrorInjector();\nDAWN_NATIVE_EXPORT void DisableErrorInjector();\nDAWN_NATIVE_EXPORT void ClearErrorInjector();\nDAWN_NATIVE_EXPORT uint64_t AcquireErrorInjectorCallCount();\nDAWN_NATIVE_EXPORT void InjectErrorAt(uint64_t index);\n\n// The different types of external images\nenum ExternalImageType {\n    OpaqueFD,\n    DmaBuf,\n    IOSurface,\n    DXGISharedHandle,\n    D3D11Texture,\n    EGLImage,\n    GLTexture,\n    AHardwareBuffer,\n    Last = AHardwareBuffer,\n};\n\n// Common properties of external images\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptor {\n  public:\n    const WGPUTextureDescriptor* cTextureDescriptor;  // Must match image creation params\n    bool isInitialized;  // Whether the texture is initialized on import\n    ExternalImageType GetType() const;\n\n  protected:\n    explicit ExternalImageDescriptor(ExternalImageType type);\n\n  private:\n    ExternalImageType mType;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfo {\n  public:\n    bool isInitialized = false;  // Whether the texture is initialized after export\n    ExternalImageType GetType() const;\n\n  protected:\n    explicit ExternalImageExportInfo(ExternalImageType type);\n\n  private:\n    ExternalImageType mType;\n};\n\nDAWN_NATIVE_EXPORT bool CheckIsErrorForTesting(void* objectHandle);\n\nDAWN_NATIVE_EXPORT const char* GetObjectLabelForTesting(void* objectHandle);\n\nDAWN_NATIVE_EXPORT uint64_t GetAllocatedSizeForTesting(WGPUBuffer buffer);\n\n}  // namespace dawn::native\n\n// Alias the DawnInstanceDescriptor up to wgpu.\n// TODO(dawn:1374) Remove this aliasing once the usages are updated.\nnamespace wgpu {\nusing dawn::native::DawnInstanceDescriptor;\n}  // namespace wgpu\n\n#endif  // INCLUDE_DAWN_NATIVE_DAWNNATIVE_H_\n", "./include/dawn/native/OpenGLBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_OPENGLBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_OPENGLBACKEND_H_\n\nusing EGLDisplay = void*;\nusing EGLImage = void*;\nusing GLuint = unsigned int;\n\n#include \"dawn/native/DawnNative.h\"\n#include \"dawn/webgpu_cpp_chained_struct.h\"\n\nnamespace dawn::native::opengl {\n\n// Can be chained in WGPURequestAdapterOptions\nstruct DAWN_NATIVE_EXPORT RequestAdapterOptionsGetGLProc : wgpu::ChainedStruct {\n    RequestAdapterOptionsGetGLProc();\n\n    void* (*getProc)(const char*);\n    EGLDisplay display;\n};\n\nstruct DAWN_NATIVE_EXPORT PhysicalDeviceDiscoveryOptions\n    : public PhysicalDeviceDiscoveryOptionsBase {\n    explicit PhysicalDeviceDiscoveryOptions(WGPUBackendType type);\n\n    void* (*getProc)(const char*);\n    EGLDisplay display;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorEGLImage : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorEGLImage();\n\n    ::EGLImage image;\n};\n\nDAWN_NATIVE_EXPORT WGPUTexture\nWrapExternalEGLImage(WGPUDevice device, const ExternalImageDescriptorEGLImage* descriptor);\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorGLTexture : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorGLTexture();\n\n    GLuint texture;\n};\n\nDAWN_NATIVE_EXPORT WGPUTexture\nWrapExternalGLTexture(WGPUDevice device, const ExternalImageDescriptorGLTexture* descriptor);\n\n}  // namespace dawn::native::opengl\n\n#endif  // INCLUDE_DAWN_NATIVE_OPENGLBACKEND_H_\n", "./include/dawn/platform/dawn_platform_export.h": "// Copyright 2020 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_PLATFORM_DAWN_PLATFORM_EXPORT_H_\n#define INCLUDE_DAWN_PLATFORM_DAWN_PLATFORM_EXPORT_H_\n\n#if defined(DAWN_PLATFORM_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(DAWN_PLATFORM_IMPLEMENTATION)\n#define DAWN_PLATFORM_EXPORT __declspec(dllexport)\n#else\n#define DAWN_PLATFORM_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(DAWN_PLATFORM_IMPLEMENTATION)\n#define DAWN_PLATFORM_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define DAWN_PLATFORM_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(DAWN_PLATFORM_SHARED_LIBRARY)\n#define DAWN_PLATFORM_EXPORT\n#endif  // defined(DAWN_PLATFORM_SHARED_LIBRARY)\n\n#endif  // INCLUDE_DAWN_PLATFORM_DAWN_PLATFORM_EXPORT_H_\n", "./include/dawn/platform/DawnPlatform.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_PLATFORM_DAWNPLATFORM_H_\n#define INCLUDE_DAWN_PLATFORM_DAWNPLATFORM_H_\n\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n\n#include \"dawn/platform/dawn_platform_export.h\"\n#include \"dawn/webgpu.h\"\n\nnamespace dawn::platform {\n\nenum class TraceCategory {\n    General,     // General trace events\n    Validation,  // Dawn validation\n    Recording,   // Native command recording\n    GPUWork,     // Actual GPU work\n};\n\nclass DAWN_PLATFORM_EXPORT CachingInterface {\n  public:\n    CachingInterface();\n    virtual ~CachingInterface();\n\n    // LoadData has two modes. The first mode is used to get a value which\n    // corresponds to the |key|. The |valueOut| is a caller provided buffer\n    // allocated to the size |valueSize| which is loaded with data of the\n    // size returned. The second mode is used to query for the existence of\n    // the |key| where |valueOut| is nullptr and |valueSize| must be 0.\n    // The return size is non-zero if the |key| exists.\n    virtual size_t LoadData(const void* key, size_t keySize, void* valueOut, size_t valueSize) = 0;\n\n    // StoreData puts a |value| in the cache which corresponds to the |key|.\n    virtual void StoreData(const void* key,\n                           size_t keySize,\n                           const void* value,\n                           size_t valueSize) = 0;\n\n  private:\n    CachingInterface(const CachingInterface&) = delete;\n    CachingInterface& operator=(const CachingInterface&) = delete;\n};\n\nclass DAWN_PLATFORM_EXPORT WaitableEvent {\n  public:\n    WaitableEvent() = default;\n    virtual ~WaitableEvent() = default;\n    virtual void Wait() = 0;        // Wait for completion\n    virtual bool IsComplete() = 0;  // Non-blocking check if the event is complete\n};\n\nusing PostWorkerTaskCallback = void (*)(void* userdata);\n\nclass DAWN_PLATFORM_EXPORT WorkerTaskPool {\n  public:\n    WorkerTaskPool() = default;\n    virtual ~WorkerTaskPool() = default;\n    virtual std::unique_ptr<WaitableEvent> PostWorkerTask(PostWorkerTaskCallback,\n                                                          void* userdata) = 0;\n};\n\nclass DAWN_PLATFORM_EXPORT Platform {\n  public:\n    Platform();\n    virtual ~Platform();\n\n    virtual const unsigned char* GetTraceCategoryEnabledFlag(TraceCategory category);\n\n    virtual double MonotonicallyIncreasingTime();\n\n    virtual uint64_t AddTraceEvent(char phase,\n                                   const unsigned char* categoryGroupEnabled,\n                                   const char* name,\n                                   uint64_t id,\n                                   double timestamp,\n                                   int numArgs,\n                                   const char** argNames,\n                                   const unsigned char* argTypes,\n                                   const uint64_t* argValues,\n                                   unsigned char flags);\n\n    // Invoked to add a UMA histogram count-based sample\n    virtual void HistogramCustomCounts(const char* name,\n                                       int sample,\n                                       int min,\n                                       int max,\n                                       int bucketCount);\n\n    // Invoked to add a UMA histogram count-based sample that requires high-performance\n    // counter (HPC) support.\n    virtual void HistogramCustomCountsHPC(const char* name,\n                                          int sample,\n                                          int min,\n                                          int max,\n                                          int bucketCount);\n\n    // Invoked to add a UMA histogram enumeration sample\n    virtual void HistogramEnumeration(const char* name, int sample, int boundaryValue);\n\n    // Invoked to add a UMA histogram sparse sample\n    virtual void HistogramSparse(const char* name, int sample);\n\n    // Invoked to add a UMA histogram boolean sample\n    virtual void HistogramBoolean(const char* name, bool sample);\n\n    // The returned CachingInterface is expected to outlive the device which uses it to persistently\n    // cache objects.\n    virtual CachingInterface* GetCachingInterface();\n\n    virtual std::unique_ptr<WorkerTaskPool> CreateWorkerTaskPool();\n\n  private:\n    Platform(const Platform&) = delete;\n    Platform& operator=(const Platform&) = delete;\n};\n\n}  // namespace dawn::platform\n\n// TODO(dawn:824): Remove once the deprecation period is passed.\nnamespace dawn_platform = dawn::platform;\n\n#endif  // INCLUDE_DAWN_PLATFORM_DAWNPLATFORM_H_\n"}
